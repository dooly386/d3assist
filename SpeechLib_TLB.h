// ************************************************************************ //
// WARNING                                                                    
// -------                                                                    
// The types declared in this file were generated from data read from a       
// Type Library. If this type library is explicitly or indirectly (via        
// another type library referring to this type library) re-imported, or the   
// 'Refresh' command of the Type Library Editor activated while editing the   
// Type Library, the contents of this file will be regenerated and all        
// manual modifications will be lost.                                         
// ************************************************************************ //

// $Rev: 52393 $
// File generated on 2017-07-18 오전 8:40:25 from Type Library described below.

// ************************************************************************  //
// Type Lib: C:\WINDOWS\System32\Speech\Common\sapi.dll (1)
// LIBID: {C866CA3A-32F7-11D2-9602-00C04F8EE628}
// LCID: 0
// Helpfile: 
// HelpString: Microsoft Speech Object Library
// DepndLst: 
//   (1) v2.0 stdole, (C:\Windows\SysWOW64\stdole2.tlb)
// SYS_KIND: SYS_WIN32
// ************************************************************************ //
#ifndef   SpeechLib_TLBH
#define   SpeechLib_TLBH

#pragma option push -b -a4 -w-inl -w-8118

#if !defined(__UTILCLS_H)
#include <utilcls.h>
#endif
#if !defined(__UTILCLS_H_VERSION) || (__UTILCLS_H_VERSION < 0x0700)
//
// The code generated by the TLIBIMP utility or the Import|TypeLibrary 
// and Import|ActiveX feature of C++Builder rely on specific versions of
// the header file UTILCLS.H found in the INCLUDE\VCL directory. If an 
// older version of the file is detected, you probably need an update/patch.
//
#error "This file requires a newer version of the header UTILCLS.H" \
       "You need to apply an update/patch to your copy of C++Builder"
#endif
#include <olectl.h>
#include <ocidl.h>
#if defined(USING_ATLVCL) || defined(USING_ATL)
#if !defined(__TLB_NO_EVENT_WRAPPERS)
#include <atl/atlmod.h>
#endif
#endif

#include <System.Win.StdVCL.hpp>

typedef TComInterface<System::Win::Stdvcl::IStrings> IStringsPtr;
typedef TComInterface<System::Win::Stdvcl::IStringsDisp> IStringsDispPtr;

namespace Speechlib_tlb
{

// *********************************************************************//
// HelpString: Microsoft Speech Object Library
// Version:    5.4
// *********************************************************************//


// *********************************************************************//
// GUIDS declared in the TypeLibrary. Following prefixes are used:        
//   Type Libraries     : LIBID_xxxx                                      
//   CoClasses          : CLSID_xxxx                                      
//   DISPInterfaces     : DIID_xxxx                                       
//   Non-DISP interfaces: IID_xxxx                                        
// *********************************************************************//
extern __declspec (package) const GUID LIBID_SpeechLib;
extern __declspec (package) const GUID IID_ISpeechDataKey;
extern __declspec (package) const GUID IID_ISpeechObjectToken;
extern __declspec (package) const GUID IID_ISpeechObjectTokenCategory;
extern __declspec (package) const GUID GUID_SpeechDataKeyLocation;
extern __declspec (package) const GUID IID_ISpeechObjectTokens;
extern __declspec (package) const GUID GUID_SpeechTokenContext;
extern __declspec (package) const GUID GUID_SpeechTokenShellFolder;
extern __declspec (package) const GUID IID_ISpeechAudioBufferInfo;
extern __declspec (package) const GUID IID_ISpeechAudioStatus;
extern __declspec (package) const GUID GUID_SpeechAudioState;
extern __declspec (package) const GUID IID_ISpeechAudioFormat;
extern __declspec (package) const GUID GUID_SpeechAudioFormatType;
extern __declspec (package) const GUID IID_ISpeechWaveFormatEx;
extern __declspec (package) const GUID IID_ISpeechBaseStream;
extern __declspec (package) const GUID GUID_SpeechStreamSeekPositionType;
extern __declspec (package) const GUID IID_ISpeechFileStream;
extern __declspec (package) const GUID GUID_SpeechStreamFileMode;
extern __declspec (package) const GUID IID_ISpeechMemoryStream;
extern __declspec (package) const GUID IID_ISpeechCustomStream;
extern __declspec (package) const GUID IID_ISpeechAudio;
extern __declspec (package) const GUID IID_ISpeechMMSysAudio;
extern __declspec (package) const GUID IID_ISpeechVoice;
extern __declspec (package) const GUID IID_ISpeechVoiceStatus;
extern __declspec (package) const GUID GUID_SpeechRunState;
extern __declspec (package) const GUID GUID_SpeechVoiceEvents;
extern __declspec (package) const GUID GUID_SpeechVoicePriority;
extern __declspec (package) const GUID GUID_SpeechVoiceSpeakFlags;
extern __declspec (package) const GUID DIID__ISpeechVoiceEvents;
extern __declspec (package) const GUID GUID_SpeechVisemeFeature;
extern __declspec (package) const GUID GUID_SpeechVisemeType;
extern __declspec (package) const GUID IID_ISpeechRecognizer;
extern __declspec (package) const GUID GUID_SpeechRecognizerState;
extern __declspec (package) const GUID IID_ISpeechRecognizerStatus;
extern __declspec (package) const GUID IID_ISpeechRecoContext;
extern __declspec (package) const GUID GUID_SpeechInterference;
extern __declspec (package) const GUID GUID_SpeechRecoEvents;
extern __declspec (package) const GUID GUID_SpeechRecoContextState;
extern __declspec (package) const GUID GUID_SpeechRetainedAudioOptions;
extern __declspec (package) const GUID IID_ISpeechRecoGrammar;
extern __declspec (package) const GUID GUID_SpeechGrammarState;
extern __declspec (package) const GUID IID_ISpeechGrammarRules;
extern __declspec (package) const GUID IID_ISpeechGrammarRule;
extern __declspec (package) const GUID GUID_SpeechRuleAttributes;
extern __declspec (package) const GUID IID_ISpeechGrammarRuleState;
extern __declspec (package) const GUID IID_ISpeechGrammarRuleStateTransitions;
extern __declspec (package) const GUID IID_ISpeechGrammarRuleStateTransition;
extern __declspec (package) const GUID GUID_SpeechGrammarRuleStateTransitionType;
extern __declspec (package) const GUID GUID_SpeechGrammarWordType;
extern __declspec (package) const GUID GUID_SpeechSpecialTransitionType;
extern __declspec (package) const GUID GUID_SpeechLoadOption;
extern __declspec (package) const GUID GUID_SpeechRuleState;
extern __declspec (package) const GUID IID_ISpeechTextSelectionInformation;
extern __declspec (package) const GUID GUID_SpeechWordPronounceable;
extern __declspec (package) const GUID IID_ISpeechRecoResult;
extern __declspec (package) const GUID IID_ISpeechRecoResultTimes;
extern __declspec (package) const GUID IID_ISpeechPhraseInfo;
extern __declspec (package) const GUID IID_ISpeechPhraseRule;
extern __declspec (package) const GUID IID_ISpeechPhraseRules;
extern __declspec (package) const GUID GUID_SpeechEngineConfidence;
extern __declspec (package) const GUID IID_ISpeechPhraseProperties;
extern __declspec (package) const GUID IID_ISpeechPhraseProperty;
extern __declspec (package) const GUID IID_ISpeechPhraseElements;
extern __declspec (package) const GUID IID_ISpeechPhraseElement;
extern __declspec (package) const GUID GUID_SpeechDisplayAttributes;
extern __declspec (package) const GUID IID_ISpeechPhraseReplacements;
extern __declspec (package) const GUID IID_ISpeechPhraseReplacement;
extern __declspec (package) const GUID IID_ISpeechPhraseAlternates;
extern __declspec (package) const GUID IID_ISpeechPhraseAlternate;
extern __declspec (package) const GUID GUID_SpeechDiscardType;
extern __declspec (package) const GUID GUID_SpeechBookmarkOptions;
extern __declspec (package) const GUID GUID_SpeechFormatType;
extern __declspec (package) const GUID DIID__ISpeechRecoContextEvents;
extern __declspec (package) const GUID GUID_SpeechRecognitionType;
extern __declspec (package) const GUID IID_ISpeechRecoResult2;
extern __declspec (package) const GUID IID_ISpeechLexicon;
extern __declspec (package) const GUID GUID_SpeechLexiconType;
extern __declspec (package) const GUID IID_ISpeechLexiconWords;
extern __declspec (package) const GUID IID_ISpeechLexiconWord;
extern __declspec (package) const GUID GUID_SpeechWordType;
extern __declspec (package) const GUID IID_ISpeechLexiconPronunciations;
extern __declspec (package) const GUID IID_ISpeechLexiconPronunciation;
extern __declspec (package) const GUID GUID_SpeechPartOfSpeech;
extern __declspec (package) const GUID GUID_SpeechStringConstants;
extern __declspec (package) const GUID GUID_SpeechConstants;
extern __declspec (package) const GUID GUID_DISPID_SpeechDataKey;
extern __declspec (package) const GUID GUID_DISPID_SpeechObjectToken;
extern __declspec (package) const GUID GUID_DISPID_SpeechObjectTokens;
extern __declspec (package) const GUID GUID_DISPID_SpeechObjectTokenCategory;
extern __declspec (package) const GUID GUID_DISPID_SpeechAudioFormat;
extern __declspec (package) const GUID GUID_DISPID_SpeechBaseStream;
extern __declspec (package) const GUID GUID_DISPID_SpeechAudio;
extern __declspec (package) const GUID GUID_DISPID_SpeechMMSysAudio;
extern __declspec (package) const GUID GUID_DISPID_SpeechFileStream;
extern __declspec (package) const GUID GUID_DISPID_SpeechCustomStream;
extern __declspec (package) const GUID GUID_DISPID_SpeechMemoryStream;
extern __declspec (package) const GUID GUID_DISPID_SpeechAudioStatus;
extern __declspec (package) const GUID GUID_DISPID_SpeechAudioBufferInfo;
extern __declspec (package) const GUID GUID_DISPID_SpeechWaveFormatEx;
extern __declspec (package) const GUID GUID_DISPID_SpeechVoice;
extern __declspec (package) const GUID GUID_DISPID_SpeechVoiceStatus;
extern __declspec (package) const GUID GUID_DISPID_SpeechVoiceEvent;
extern __declspec (package) const GUID GUID_DISPID_SpeechRecognizer;
extern __declspec (package) const GUID GUID_SpeechEmulationCompareFlags;
extern __declspec (package) const GUID GUID_DISPID_SpeechRecognizerStatus;
extern __declspec (package) const GUID GUID_DISPID_SpeechRecoContext;
extern __declspec (package) const GUID GUID_DISPIDSPRG;
extern __declspec (package) const GUID GUID_DISPID_SpeechRecoContextEvents;
extern __declspec (package) const GUID GUID_DISPID_SpeechGrammarRule;
extern __declspec (package) const GUID GUID_DISPID_SpeechGrammarRules;
extern __declspec (package) const GUID GUID_DISPID_SpeechGrammarRuleState;
extern __declspec (package) const GUID GUID_DISPID_SpeechGrammarRuleStateTransitions;
extern __declspec (package) const GUID GUID_DISPID_SpeechGrammarRuleStateTransition;
extern __declspec (package) const GUID GUID_DISPIDSPTSI;
extern __declspec (package) const GUID GUID_DISPID_SpeechRecoResult;
extern __declspec (package) const GUID GUID_DISPID_SpeechXMLRecoResult;
extern __declspec (package) const GUID IID_ISpeechXMLRecoResult;
extern __declspec (package) const GUID GUID_SPXMLRESULTOPTIONS;
extern __declspec (package) const GUID GUID_DISPID_SpeechRecoResult2;
extern __declspec (package) const GUID IID_ISpeechRecoResultDispatch;
extern __declspec (package) const GUID GUID_DISPID_SpeechPhraseBuilder;
extern __declspec (package) const GUID IID_ISpeechPhraseInfoBuilder;
extern __declspec (package) const GUID GUID_DISPID_SpeechRecoResultTimes;
extern __declspec (package) const GUID GUID_DISPID_SpeechPhraseAlternate;
extern __declspec (package) const GUID GUID_DISPID_SpeechPhraseAlternates;
extern __declspec (package) const GUID GUID_DISPID_SpeechPhraseInfo;
extern __declspec (package) const GUID GUID_DISPID_SpeechPhraseElement;
extern __declspec (package) const GUID GUID_DISPID_SpeechPhraseElements;
extern __declspec (package) const GUID GUID_DISPID_SpeechPhraseReplacement;
extern __declspec (package) const GUID GUID_DISPID_SpeechPhraseReplacements;
extern __declspec (package) const GUID GUID_DISPID_SpeechPhraseProperty;
extern __declspec (package) const GUID GUID_DISPID_SpeechPhraseProperties;
extern __declspec (package) const GUID GUID_DISPID_SpeechPhraseRule;
extern __declspec (package) const GUID GUID_DISPID_SpeechPhraseRules;
extern __declspec (package) const GUID GUID_DISPID_SpeechLexicon;
extern __declspec (package) const GUID GUID_DISPID_SpeechLexiconWords;
extern __declspec (package) const GUID GUID_DISPID_SpeechLexiconWord;
extern __declspec (package) const GUID GUID_DISPID_SpeechLexiconProns;
extern __declspec (package) const GUID GUID_DISPID_SpeechLexiconPronunciation;
extern __declspec (package) const GUID GUID_DISPID_SpeechPhoneConverter;
extern __declspec (package) const GUID IID_ISpeechPhoneConverter;
extern __declspec (package) const GUID IID_ISpNotifySink;
extern __declspec (package) const GUID IID_ISpNotifyTranslator;
extern __declspec (package) const GUID CLSID_SpNotifyTranslator;
extern __declspec (package) const GUID GUID_wireHWND;
extern __declspec (package) const GUID GUID___MIDL_IWinTypes_0009;
extern __declspec (package) const GUID GUID__RemotableHandle;
extern __declspec (package) const GUID GUID_UINT_PTR;
extern __declspec (package) const GUID GUID_LONG_PTR;
extern __declspec (package) const GUID IID_ISpDataKey;
extern __declspec (package) const GUID IID_ISpObjectTokenCategory;
extern __declspec (package) const GUID CLSID_SpObjectTokenCategory;
extern __declspec (package) const GUID GUID_SPDATAKEYLOCATION;
extern __declspec (package) const GUID IID_IEnumSpObjectTokens;
extern __declspec (package) const GUID IID_ISpObjectToken;
extern __declspec (package) const GUID CLSID_SpObjectToken;
extern __declspec (package) const GUID IID_IServiceProvider;
extern __declspec (package) const GUID IID_ISpResourceManager;
extern __declspec (package) const GUID CLSID_SpResourceManager;
extern __declspec (package) const GUID IID_ISequentialStream;
extern __declspec (package) const GUID IID_IStream;
extern __declspec (package) const GUID IID_ISpStreamFormat;
extern __declspec (package) const GUID IID_ISpStreamFormatConverter;
extern __declspec (package) const GUID CLSID_SpStreamFormatConverter;
extern __declspec (package) const GUID GUID__LARGE_INTEGER;
extern __declspec (package) const GUID GUID__ULARGE_INTEGER;
extern __declspec (package) const GUID GUID__FILETIME;
extern __declspec (package) const GUID GUID_tagSTATSTG;
extern __declspec (package) const GUID GUID_WAVEFORMATEX;
extern __declspec (package) const GUID CLSID_SpMMAudioEnum;
extern __declspec (package) const GUID IID_ISpNotifySource;
extern __declspec (package) const GUID IID_ISpEventSource;
extern __declspec (package) const GUID IID_ISpEventSink;
extern __declspec (package) const GUID GUID_SPEVENT;
extern __declspec (package) const GUID GUID_SPEVENTSOURCEINFO;
extern __declspec (package) const GUID IID_ISpObjectWithToken;
extern __declspec (package) const GUID IID_ISpAudio;
extern __declspec (package) const GUID IID_ISpMMSysAudio;
extern __declspec (package) const GUID CLSID_SpMMAudioIn;
extern __declspec (package) const GUID GUID__SPAUDIOSTATE;
extern __declspec (package) const GUID GUID_SPAUDIOSTATE;
extern __declspec (package) const GUID GUID_SPAUDIOSTATUS;
extern __declspec (package) const GUID GUID_SPAUDIOBUFFERINFO;
extern __declspec (package) const GUID CLSID_SpMMAudioOut;
extern __declspec (package) const GUID IID_ISpStream;
extern __declspec (package) const GUID CLSID_SpStream;
extern __declspec (package) const GUID GUID_SPFILEMODE;
extern __declspec (package) const GUID IID_ISpVoice;
extern __declspec (package) const GUID IID_ISpPhoneticAlphabetSelection;
extern __declspec (package) const GUID GUID_SPVOICESTATUS;
extern __declspec (package) const GUID GUID_SPVISEMES;
extern __declspec (package) const GUID GUID_SPVPRIORITY;
extern __declspec (package) const GUID GUID_SPEVENTENUM;
extern __declspec (package) const GUID CLSID_SpVoice;
extern __declspec (package) const GUID IID_ISpRecoContext;
extern __declspec (package) const GUID IID_ISpRecoContext2;
extern __declspec (package) const GUID IID_ISpProperties;
extern __declspec (package) const GUID IID_ISpRecognizer;
extern __declspec (package) const GUID GUID_SPRECOSTATE;
extern __declspec (package) const GUID GUID_SPRECOGNIZERSTATUS;
extern __declspec (package) const GUID GUID_SPWAVEFORMATTYPE;
extern __declspec (package) const GUID GUID_SPSTREAMFORMATTYPE;
extern __declspec (package) const GUID IID_ISpPhrase;
extern __declspec (package) const GUID GUID_SPPHRASERULE;
extern __declspec (package) const GUID GUID___MIDL___MIDL_itf_sapi_0000_0020_0002;
extern __declspec (package) const GUID GUID___MIDL___MIDL_itf_sapi_0000_0020_0001;
extern __declspec (package) const GUID GUID_SPPHRASEPROPERTY;
extern __declspec (package) const GUID GUID_SPPHRASEELEMENT;
extern __declspec (package) const GUID GUID_SPPHRASEREPLACEMENT;
extern __declspec (package) const GUID GUID_SPSEMANTICERRORINFO;
extern __declspec (package) const GUID GUID_SPPHRASE;
extern __declspec (package) const GUID GUID_SPSEMANTICFORMAT;
extern __declspec (package) const GUID GUID_SPSERIALIZEDPHRASE;
extern __declspec (package) const GUID IID_ISpGrammarBuilder;
extern __declspec (package) const GUID IID_ISpRecoGrammar;
extern __declspec (package) const GUID GUID_SPGRAMMARWORDTYPE;
extern __declspec (package) const GUID GUID_tagSPPROPERTYINFO;
extern __declspec (package) const GUID GUID_SPPROPERTYINFO;
extern __declspec (package) const GUID GUID_SPLOADOPTIONS;
extern __declspec (package) const GUID GUID_SPBINARYGRAMMAR;
extern __declspec (package) const GUID GUID_SPRULESTATE;
extern __declspec (package) const GUID GUID_tagSPTEXTSELECTIONINFO;
extern __declspec (package) const GUID GUID_SPTEXTSELECTIONINFO;
extern __declspec (package) const GUID GUID_SPWORDPRONOUNCEABLE;
extern __declspec (package) const GUID GUID_SPGRAMMARSTATE;
extern __declspec (package) const GUID GUID_SPRECOCONTEXTSTATUS;
extern __declspec (package) const GUID GUID_SPINTERFERENCE;
extern __declspec (package) const GUID GUID_SPAUDIOOPTIONS;
extern __declspec (package) const GUID GUID_SPSERIALIZEDRESULT;
extern __declspec (package) const GUID IID_ISpRecoResult;
extern __declspec (package) const GUID GUID_SPRECORESULTTIMES;
extern __declspec (package) const GUID IID_ISpPhraseAlt;
extern __declspec (package) const GUID GUID_SPBOOKMARKOPTIONS;
extern __declspec (package) const GUID GUID_SPCONTEXTSTATE;
extern __declspec (package) const GUID CLSID_SpSharedRecoContext;
extern __declspec (package) const GUID GUID_SPADAPTATIONRELEVANCE;
extern __declspec (package) const GUID IID_ISpRecognizer2;
extern __declspec (package) const GUID IID_ISpRecognizer3;
extern __declspec (package) const GUID IID_ISpSerializeState;
extern __declspec (package) const GUID GUID_SPCATEGORYTYPE;
extern __declspec (package) const GUID IID_ISpRecoCategory;
extern __declspec (package) const GUID CLSID_SpInprocRecognizer;
extern __declspec (package) const GUID CLSID_SpSharedRecognizer;
extern __declspec (package) const GUID IID_ISpLexicon;
extern __declspec (package) const GUID CLSID_SpLexicon;
extern __declspec (package) const GUID GUID_SPWORDPRONUNCIATION;
extern __declspec (package) const GUID GUID_SPWORDPRONUNCIATIONLIST;
extern __declspec (package) const GUID GUID_SPLEXICONTYPE;
extern __declspec (package) const GUID GUID_SPPARTOFSPEECH;
extern __declspec (package) const GUID GUID_SPWORD;
extern __declspec (package) const GUID GUID_SPWORDLIST;
extern __declspec (package) const GUID GUID_SPWORDTYPE;
extern __declspec (package) const GUID CLSID_SpUnCompressedLexicon;
extern __declspec (package) const GUID CLSID_SpCompressedLexicon;
extern __declspec (package) const GUID IID_ISpShortcut;
extern __declspec (package) const GUID CLSID_SpShortcut;
extern __declspec (package) const GUID GUID_SPSHORTCUTTYPE;
extern __declspec (package) const GUID GUID_SPSHORTCUTPAIR;
extern __declspec (package) const GUID GUID_SPSHORTCUTPAIRLIST;
extern __declspec (package) const GUID IID_ISpPhoneConverter;
extern __declspec (package) const GUID CLSID_SpPhoneConverter;
extern __declspec (package) const GUID IID_ISpPhoneticAlphabetConverter;
extern __declspec (package) const GUID CLSID_SpPhoneticAlphabetConverter;
extern __declspec (package) const GUID CLSID_SpNullPhoneConverter;
extern __declspec (package) const GUID CLSID_SpTextSelectionInformation;
extern __declspec (package) const GUID CLSID_SpPhraseInfoBuilder;
extern __declspec (package) const GUID CLSID_SpAudioFormat;
extern __declspec (package) const GUID CLSID_SpWaveFormatEx;
extern __declspec (package) const GUID CLSID_SpInProcRecoContext;
extern __declspec (package) const GUID CLSID_SpCustomStream;
extern __declspec (package) const GUID CLSID_SpFileStream;
extern __declspec (package) const GUID CLSID_SpMemoryStream;
extern __declspec (package) const GUID IID_ISpXMLRecoResult;
extern __declspec (package) const GUID IID_ISpRecoGrammar2;
extern __declspec (package) const GUID GUID_SPRULE;
extern __declspec (package) const GUID IID_ISpeechResourceLoader;
extern __declspec (package) const GUID IID_IInternetSecurityManager;
extern __declspec (package) const GUID IID_IInternetSecurityMgrSite;
extern __declspec (package) const GUID GUID_ULONG_PTR;
extern __declspec (package) const GUID IID_IEnumString;

// *********************************************************************//
// Forward declaration of types defined in TypeLibrary                    
// *********************************************************************//
enum class    SpeechDataKeyLocation;
enum class    SpeechTokenContext;
enum class    SpeechTokenShellFolder;
enum class    SpeechAudioState;
enum class    SpeechAudioFormatType;
enum class    SpeechStreamSeekPositionType;
enum class    SpeechStreamFileMode;
enum class    SpeechRunState;
enum class    SpeechVoiceEvents;
enum class    SpeechVoicePriority;
enum class    SpeechVoiceSpeakFlags;
enum class    SpeechVisemeFeature;
enum class    SpeechVisemeType;
enum class    SpeechRecognizerState;
enum class    SpeechInterference;
enum class    SpeechRecoEvents;
enum class    SpeechRecoContextState;
enum class    SpeechRetainedAudioOptions;
enum class    SpeechGrammarState;
enum class    SpeechRuleAttributes;
enum class    SpeechGrammarRuleStateTransitionType;
enum class    SpeechGrammarWordType;
enum class    SpeechSpecialTransitionType;
enum class    SpeechLoadOption;
enum class    SpeechRuleState;
enum class    SpeechWordPronounceable;
enum class    SpeechEngineConfidence;
enum class    SpeechDisplayAttributes;
enum class    SpeechDiscardType;
enum class    SpeechBookmarkOptions;
enum class    SpeechFormatType;
enum class    SpeechRecognitionType;
enum class    SpeechLexiconType;
enum class    SpeechWordType;
enum class    SpeechPartOfSpeech;
enum class    DISPID_SpeechDataKey;
enum class    DISPID_SpeechObjectToken;
enum class    DISPID_SpeechObjectTokens;
enum class    DISPID_SpeechObjectTokenCategory;
enum class    DISPID_SpeechAudioFormat;
enum class    DISPID_SpeechBaseStream;
enum class    DISPID_SpeechAudio;
enum class    DISPID_SpeechMMSysAudio;
enum class    DISPID_SpeechFileStream;
enum class    DISPID_SpeechCustomStream;
enum class    DISPID_SpeechMemoryStream;
enum class    DISPID_SpeechAudioStatus;
enum class    DISPID_SpeechAudioBufferInfo;
enum class    DISPID_SpeechWaveFormatEx;
enum class    DISPID_SpeechVoice;
enum class    DISPID_SpeechVoiceStatus;
enum class    DISPID_SpeechVoiceEvent;
enum class    DISPID_SpeechRecognizer;
enum class    SpeechEmulationCompareFlags;
enum class    DISPID_SpeechRecognizerStatus;
enum class    DISPID_SpeechRecoContext;
enum class    DISPIDSPRG;
enum class    DISPID_SpeechRecoContextEvents;
enum class    DISPID_SpeechGrammarRule;
enum class    DISPID_SpeechGrammarRules;
enum class    DISPID_SpeechGrammarRuleState;
enum class    DISPID_SpeechGrammarRuleStateTransitions;
enum class    DISPID_SpeechGrammarRuleStateTransition;
enum class    DISPIDSPTSI;
enum class    DISPID_SpeechRecoResult;
enum class    DISPID_SpeechXMLRecoResult;
enum class    SPXMLRESULTOPTIONS;
enum class    DISPID_SpeechRecoResult2;
enum class    DISPID_SpeechPhraseBuilder;
enum class    DISPID_SpeechRecoResultTimes;
enum class    DISPID_SpeechPhraseAlternate;
enum class    DISPID_SpeechPhraseAlternates;
enum class    DISPID_SpeechPhraseInfo;
enum class    DISPID_SpeechPhraseElement;
enum class    DISPID_SpeechPhraseElements;
enum class    DISPID_SpeechPhraseReplacement;
enum class    DISPID_SpeechPhraseReplacements;
enum class    DISPID_SpeechPhraseProperty;
enum class    DISPID_SpeechPhraseProperties;
enum class    DISPID_SpeechPhraseRule;
enum class    DISPID_SpeechPhraseRules;
enum class    DISPID_SpeechLexicon;
enum class    DISPID_SpeechLexiconWords;
enum class    DISPID_SpeechLexiconWord;
enum class    DISPID_SpeechLexiconProns;
enum class    DISPID_SpeechLexiconPronunciation;
enum class    DISPID_SpeechPhoneConverter;
union     __MIDL_IWinTypes_0009;
struct    _RemotableHandle;
enum class    SPDATAKEYLOCATION;
struct    _LARGE_INTEGER;
struct    _ULARGE_INTEGER;
struct    _FILETIME;
struct    tagSTATSTG;
struct    WAVEFORMATEX;
struct    SPEVENT;
struct    SPEVENTSOURCEINFO;
enum class    _SPAUDIOSTATE;
struct    SPAUDIOSTATUS;
struct    SPAUDIOBUFFERINFO;
enum class    SPFILEMODE;
struct    SPVOICESTATUS;
enum class    SPVISEMES;
enum class    SPVPRIORITY;
enum class    SPEVENTENUM;
enum class    SPRECOSTATE;
struct    SPRECOGNIZERSTATUS;
enum class    SPWAVEFORMATTYPE;
struct    SPPHRASERULE;
struct    __MIDL___MIDL_itf_sapi_0000_0020_0002;
union     __MIDL___MIDL_itf_sapi_0000_0020_0001;
struct    SPPHRASEPROPERTY;
struct    SPPHRASEELEMENT;
struct    SPPHRASEREPLACEMENT;
struct    SPSEMANTICERRORINFO;
struct    SPPHRASE;
enum class    SPSEMANTICFORMAT;
struct    SPSERIALIZEDPHRASE;
enum class    SPGRAMMARWORDTYPE;
struct    tagSPPROPERTYINFO;
enum class    SPLOADOPTIONS;
struct    SPBINARYGRAMMAR;
enum class    SPRULESTATE;
struct    tagSPTEXTSELECTIONINFO;
enum class    SPWORDPRONOUNCEABLE;
enum class    SPGRAMMARSTATE;
struct    SPRECOCONTEXTSTATUS;
enum class    SPINTERFERENCE;
enum class    SPAUDIOOPTIONS;
struct    SPSERIALIZEDRESULT;
struct    SPRECORESULTTIMES;
enum class    SPBOOKMARKOPTIONS;
enum class    SPCONTEXTSTATE;
enum class    SPADAPTATIONRELEVANCE;
enum class    SPCATEGORYTYPE;
struct    SPWORDPRONUNCIATION;
struct    SPWORDPRONUNCIATIONLIST;
enum class    SPLEXICONTYPE;
enum class    SPPARTOFSPEECH;
struct    SPWORD;
struct    SPWORDLIST;
enum class    SPWORDTYPE;
enum class    SPSHORTCUTTYPE;
struct    SPSHORTCUTPAIR;
struct    SPSHORTCUTPAIRLIST;
struct    SPRULE;
interface DECLSPEC_UUID("{CE17C09B-4EFA-44D5-A4C9-59D9585AB0CD}") ISpeechDataKey;
typedef TComInterface<ISpeechDataKey, &IID_ISpeechDataKey> ISpeechDataKeyPtr;

interface DECLSPEC_UUID("{C74A3ADC-B727-4500-A84A-B526721C8B8C}") ISpeechObjectToken;
typedef TComInterface<ISpeechObjectToken, &IID_ISpeechObjectToken> ISpeechObjectTokenPtr;

interface DECLSPEC_UUID("{CA7EAC50-2D01-4145-86D4-5AE7D70F4469}") ISpeechObjectTokenCategory;
typedef TComInterface<ISpeechObjectTokenCategory, &IID_ISpeechObjectTokenCategory> ISpeechObjectTokenCategoryPtr;

interface DECLSPEC_UUID("{9285B776-2E7B-4BC0-B53E-580EB6FA967F}") ISpeechObjectTokens;
typedef TComInterface<ISpeechObjectTokens, &IID_ISpeechObjectTokens> ISpeechObjectTokensPtr;

interface DECLSPEC_UUID("{11B103D8-1142-4EDF-A093-82FB3915F8CC}") ISpeechAudioBufferInfo;
typedef TComInterface<ISpeechAudioBufferInfo, &IID_ISpeechAudioBufferInfo> ISpeechAudioBufferInfoPtr;

interface DECLSPEC_UUID("{C62D9C91-7458-47F6-862D-1EF86FB0B278}") ISpeechAudioStatus;
typedef TComInterface<ISpeechAudioStatus, &IID_ISpeechAudioStatus> ISpeechAudioStatusPtr;

interface DECLSPEC_UUID("{E6E9C590-3E18-40E3-8299-061F98BDE7C7}") ISpeechAudioFormat;
typedef TComInterface<ISpeechAudioFormat, &IID_ISpeechAudioFormat> ISpeechAudioFormatPtr;

interface DECLSPEC_UUID("{7A1EF0D5-1581-4741-88E4-209A49F11A10}") ISpeechWaveFormatEx;
typedef TComInterface<ISpeechWaveFormatEx, &IID_ISpeechWaveFormatEx> ISpeechWaveFormatExPtr;

interface DECLSPEC_UUID("{6450336F-7D49-4CED-8097-49D6DEE37294}") ISpeechBaseStream;
typedef TComInterface<ISpeechBaseStream, &IID_ISpeechBaseStream> ISpeechBaseStreamPtr;

interface DECLSPEC_UUID("{AF67F125-AB39-4E93-B4A2-CC2E66E182A7}") ISpeechFileStream;
typedef TComInterface<ISpeechFileStream, &IID_ISpeechFileStream> ISpeechFileStreamPtr;

interface DECLSPEC_UUID("{EEB14B68-808B-4ABE-A5EA-B51DA7588008}") ISpeechMemoryStream;
typedef TComInterface<ISpeechMemoryStream, &IID_ISpeechMemoryStream> ISpeechMemoryStreamPtr;

interface DECLSPEC_UUID("{1A9E9F4F-104F-4DB8-A115-EFD7FD0C97AE}") ISpeechCustomStream;
typedef TComInterface<ISpeechCustomStream, &IID_ISpeechCustomStream> ISpeechCustomStreamPtr;

interface DECLSPEC_UUID("{CFF8E175-019E-11D3-A08E-00C04F8EF9B5}") ISpeechAudio;
typedef TComInterface<ISpeechAudio, &IID_ISpeechAudio> ISpeechAudioPtr;

interface DECLSPEC_UUID("{3C76AF6D-1FD7-4831-81D1-3B71D5A13C44}") ISpeechMMSysAudio;
typedef TComInterface<ISpeechMMSysAudio, &IID_ISpeechMMSysAudio> ISpeechMMSysAudioPtr;

interface DECLSPEC_UUID("{269316D8-57BD-11D2-9EEE-00C04F797396}") ISpeechVoice;
typedef TComInterface<ISpeechVoice, &IID_ISpeechVoice> ISpeechVoicePtr;

interface DECLSPEC_UUID("{8BE47B07-57F6-11D2-9EEE-00C04F797396}") ISpeechVoiceStatus;
typedef TComInterface<ISpeechVoiceStatus, &IID_ISpeechVoiceStatus> ISpeechVoiceStatusPtr;

interface DECLSPEC_UUID("{A372ACD1-3BEF-4BBD-8FFB-CB3E2B416AF8}") _ISpeechVoiceEvents;
typedef TComInterface<_ISpeechVoiceEvents, &DIID__ISpeechVoiceEvents> _ISpeechVoiceEventsPtr;

interface DECLSPEC_UUID("{2D5F1C0C-BD75-4B08-9478-3B11FEA2586C}") ISpeechRecognizer;
typedef TComInterface<ISpeechRecognizer, &IID_ISpeechRecognizer> ISpeechRecognizerPtr;

interface DECLSPEC_UUID("{BFF9E781-53EC-484E-BB8A-0E1B5551E35C}") ISpeechRecognizerStatus;
typedef TComInterface<ISpeechRecognizerStatus, &IID_ISpeechRecognizerStatus> ISpeechRecognizerStatusPtr;

interface DECLSPEC_UUID("{580AA49D-7E1E-4809-B8E2-57DA806104B8}") ISpeechRecoContext;
typedef TComInterface<ISpeechRecoContext, &IID_ISpeechRecoContext> ISpeechRecoContextPtr;

interface DECLSPEC_UUID("{B6D6F79F-2158-4E50-B5BC-9A9CCD852A09}") ISpeechRecoGrammar;
typedef TComInterface<ISpeechRecoGrammar, &IID_ISpeechRecoGrammar> ISpeechRecoGrammarPtr;

interface DECLSPEC_UUID("{6FFA3B44-FC2D-40D1-8AFC-32911C7F1AD1}") ISpeechGrammarRules;
typedef TComInterface<ISpeechGrammarRules, &IID_ISpeechGrammarRules> ISpeechGrammarRulesPtr;

interface DECLSPEC_UUID("{AFE719CF-5DD1-44F2-999C-7A399F1CFCCC}") ISpeechGrammarRule;
typedef TComInterface<ISpeechGrammarRule, &IID_ISpeechGrammarRule> ISpeechGrammarRulePtr;

interface DECLSPEC_UUID("{D4286F2C-EE67-45AE-B928-28D695362EDA}") ISpeechGrammarRuleState;
typedef TComInterface<ISpeechGrammarRuleState, &IID_ISpeechGrammarRuleState> ISpeechGrammarRuleStatePtr;

interface DECLSPEC_UUID("{EABCE657-75BC-44A2-AA7F-C56476742963}") ISpeechGrammarRuleStateTransitions;
typedef TComInterface<ISpeechGrammarRuleStateTransitions, &IID_ISpeechGrammarRuleStateTransitions> ISpeechGrammarRuleStateTransitionsPtr;

interface DECLSPEC_UUID("{CAFD1DB1-41D1-4A06-9863-E2E81DA17A9A}") ISpeechGrammarRuleStateTransition;
typedef TComInterface<ISpeechGrammarRuleStateTransition, &IID_ISpeechGrammarRuleStateTransition> ISpeechGrammarRuleStateTransitionPtr;

interface DECLSPEC_UUID("{3B9C7E7A-6EEE-4DED-9092-11657279ADBE}") ISpeechTextSelectionInformation;
typedef TComInterface<ISpeechTextSelectionInformation, &IID_ISpeechTextSelectionInformation> ISpeechTextSelectionInformationPtr;

interface DECLSPEC_UUID("{ED2879CF-CED9-4EE6-A534-DE0191D5468D}") ISpeechRecoResult;
typedef TComInterface<ISpeechRecoResult, &IID_ISpeechRecoResult> ISpeechRecoResultPtr;

interface DECLSPEC_UUID("{62B3B8FB-F6E7-41BE-BDCB-056B1C29EFC0}") ISpeechRecoResultTimes;
typedef TComInterface<ISpeechRecoResultTimes, &IID_ISpeechRecoResultTimes> ISpeechRecoResultTimesPtr;

interface DECLSPEC_UUID("{961559CF-4E67-4662-8BF0-D93F1FCD61B3}") ISpeechPhraseInfo;
typedef TComInterface<ISpeechPhraseInfo, &IID_ISpeechPhraseInfo> ISpeechPhraseInfoPtr;

interface DECLSPEC_UUID("{A7BFE112-A4A0-48D9-B602-C313843F6964}") ISpeechPhraseRule;
typedef TComInterface<ISpeechPhraseRule, &IID_ISpeechPhraseRule> ISpeechPhraseRulePtr;

interface DECLSPEC_UUID("{9047D593-01DD-4B72-81A3-E4A0CA69F407}") ISpeechPhraseRules;
typedef TComInterface<ISpeechPhraseRules, &IID_ISpeechPhraseRules> ISpeechPhraseRulesPtr;

interface DECLSPEC_UUID("{08166B47-102E-4B23-A599-BDB98DBFD1F4}") ISpeechPhraseProperties;
typedef TComInterface<ISpeechPhraseProperties, &IID_ISpeechPhraseProperties> ISpeechPhrasePropertiesPtr;

interface DECLSPEC_UUID("{CE563D48-961E-4732-A2E1-378A42B430BE}") ISpeechPhraseProperty;
typedef TComInterface<ISpeechPhraseProperty, &IID_ISpeechPhraseProperty> ISpeechPhrasePropertyPtr;

interface DECLSPEC_UUID("{0626B328-3478-467D-A0B3-D0853B93DDA3}") ISpeechPhraseElements;
typedef TComInterface<ISpeechPhraseElements, &IID_ISpeechPhraseElements> ISpeechPhraseElementsPtr;

interface DECLSPEC_UUID("{E6176F96-E373-4801-B223-3B62C068C0B4}") ISpeechPhraseElement;
typedef TComInterface<ISpeechPhraseElement, &IID_ISpeechPhraseElement> ISpeechPhraseElementPtr;

interface DECLSPEC_UUID("{38BC662F-2257-4525-959E-2069D2596C05}") ISpeechPhraseReplacements;
typedef TComInterface<ISpeechPhraseReplacements, &IID_ISpeechPhraseReplacements> ISpeechPhraseReplacementsPtr;

interface DECLSPEC_UUID("{2890A410-53A7-4FB5-94EC-06D4998E3D02}") ISpeechPhraseReplacement;
typedef TComInterface<ISpeechPhraseReplacement, &IID_ISpeechPhraseReplacement> ISpeechPhraseReplacementPtr;

interface DECLSPEC_UUID("{B238B6D5-F276-4C3D-A6C1-2974801C3CC2}") ISpeechPhraseAlternates;
typedef TComInterface<ISpeechPhraseAlternates, &IID_ISpeechPhraseAlternates> ISpeechPhraseAlternatesPtr;

interface DECLSPEC_UUID("{27864A2A-2B9F-4CB8-92D3-0D2722FD1E73}") ISpeechPhraseAlternate;
typedef TComInterface<ISpeechPhraseAlternate, &IID_ISpeechPhraseAlternate> ISpeechPhraseAlternatePtr;

interface DECLSPEC_UUID("{7B8FCB42-0E9D-4F00-A048-7B04D6179D3D}") _ISpeechRecoContextEvents;
typedef TComInterface<_ISpeechRecoContextEvents, &DIID__ISpeechRecoContextEvents> _ISpeechRecoContextEventsPtr;

interface DECLSPEC_UUID("{8E0A246D-D3C8-45DE-8657-04290C458C3C}") ISpeechRecoResult2;
typedef TComInterface<ISpeechRecoResult2, &IID_ISpeechRecoResult2> ISpeechRecoResult2Ptr;

interface DECLSPEC_UUID("{3DA7627A-C7AE-4B23-8708-638C50362C25}") ISpeechLexicon;
typedef TComInterface<ISpeechLexicon, &IID_ISpeechLexicon> ISpeechLexiconPtr;

interface DECLSPEC_UUID("{8D199862-415E-47D5-AC4F-FAA608B424E6}") ISpeechLexiconWords;
typedef TComInterface<ISpeechLexiconWords, &IID_ISpeechLexiconWords> ISpeechLexiconWordsPtr;

interface DECLSPEC_UUID("{4E5B933C-C9BE-48ED-8842-1EE51BB1D4FF}") ISpeechLexiconWord;
typedef TComInterface<ISpeechLexiconWord, &IID_ISpeechLexiconWord> ISpeechLexiconWordPtr;

interface DECLSPEC_UUID("{72829128-5682-4704-A0D4-3E2BB6F2EAD3}") ISpeechLexiconPronunciations;
typedef TComInterface<ISpeechLexiconPronunciations, &IID_ISpeechLexiconPronunciations> ISpeechLexiconPronunciationsPtr;

interface DECLSPEC_UUID("{95252C5D-9E43-4F4A-9899-48EE73352F9F}") ISpeechLexiconPronunciation;
typedef TComInterface<ISpeechLexiconPronunciation, &IID_ISpeechLexiconPronunciation> ISpeechLexiconPronunciationPtr;

interface DECLSPEC_UUID("{AAEC54AF-8F85-4924-944D-B79D39D72E19}") ISpeechXMLRecoResult;
typedef TComInterface<ISpeechXMLRecoResult, &IID_ISpeechXMLRecoResult> ISpeechXMLRecoResultPtr;

interface DECLSPEC_UUID("{6D60EB64-ACED-40A6-BBF3-4E557F71DEE2}") ISpeechRecoResultDispatch;
typedef TComInterface<ISpeechRecoResultDispatch, &IID_ISpeechRecoResultDispatch> ISpeechRecoResultDispatchPtr;

interface DECLSPEC_UUID("{3B151836-DF3A-4E0A-846C-D2ADC9334333}") ISpeechPhraseInfoBuilder;
typedef TComInterface<ISpeechPhraseInfoBuilder, &IID_ISpeechPhraseInfoBuilder> ISpeechPhraseInfoBuilderPtr;

interface DECLSPEC_UUID("{C3E4F353-433F-43D6-89A1-6A62A7054C3D}") ISpeechPhoneConverter;
typedef TComInterface<ISpeechPhoneConverter, &IID_ISpeechPhoneConverter> ISpeechPhoneConverterPtr;

interface DECLSPEC_UUID("{259684DC-37C3-11D2-9603-00C04F8EE628}") ISpNotifySink;
typedef TComInterface<ISpNotifySink, &IID_ISpNotifySink> ISpNotifySinkPtr;

interface DECLSPEC_UUID("{ACA16614-5D3D-11D2-960E-00C04F8EE628}") ISpNotifyTranslator;
typedef TComInterface<ISpNotifyTranslator, &IID_ISpNotifyTranslator> ISpNotifyTranslatorPtr;

interface DECLSPEC_UUID("{14056581-E16C-11D2-BB90-00C04F8EE6C0}") ISpDataKey;
typedef TComInterface<ISpDataKey, &IID_ISpDataKey> ISpDataKeyPtr;

interface DECLSPEC_UUID("{2D3D3845-39AF-4850-BBF9-40B49780011D}") ISpObjectTokenCategory;
typedef TComInterface<ISpObjectTokenCategory, &IID_ISpObjectTokenCategory> ISpObjectTokenCategoryPtr;

interface DECLSPEC_UUID("{06B64F9E-7FDA-11D2-B4F2-00C04F797396}") IEnumSpObjectTokens;
typedef TComInterface<IEnumSpObjectTokens, &IID_IEnumSpObjectTokens> IEnumSpObjectTokensPtr;

interface DECLSPEC_UUID("{14056589-E16C-11D2-BB90-00C04F8EE6C0}") ISpObjectToken;
typedef TComInterface<ISpObjectToken, &IID_ISpObjectToken> ISpObjectTokenPtr;

interface DECLSPEC_UUID("{6D5140C1-7436-11CE-8034-00AA006009FA}") IServiceProvider;
typedef TComInterface<IServiceProvider, &IID_IServiceProvider> IServiceProviderPtr;

interface DECLSPEC_UUID("{93384E18-5014-43D5-ADBB-A78E055926BD}") ISpResourceManager;
typedef TComInterface<ISpResourceManager, &IID_ISpResourceManager> ISpResourceManagerPtr;

interface DECLSPEC_UUID("{0C733A30-2A1C-11CE-ADE5-00AA0044773D}") ISequentialStream;
typedef TComInterface<ISequentialStream, &IID_ISequentialStream> ISequentialStreamPtr;

interface DECLSPEC_UUID("{0000000C-0000-0000-C000-000000000046}") IStream;
typedef TComInterface<IStream, &IID_IStream> IStreamPtr;

interface DECLSPEC_UUID("{BED530BE-2606-4F4D-A1C0-54C5CDA5566F}") ISpStreamFormat;
typedef TComInterface<ISpStreamFormat, &IID_ISpStreamFormat> ISpStreamFormatPtr;

interface DECLSPEC_UUID("{678A932C-EA71-4446-9B41-78FDA6280A29}") ISpStreamFormatConverter;
typedef TComInterface<ISpStreamFormatConverter, &IID_ISpStreamFormatConverter> ISpStreamFormatConverterPtr;

interface DECLSPEC_UUID("{5EFF4AEF-8487-11D2-961C-00C04F8EE628}") ISpNotifySource;
typedef TComInterface<ISpNotifySource, &IID_ISpNotifySource> ISpNotifySourcePtr;

interface DECLSPEC_UUID("{BE7A9CCE-5F9E-11D2-960F-00C04F8EE628}") ISpEventSource;
typedef TComInterface<ISpEventSource, &IID_ISpEventSource> ISpEventSourcePtr;

interface DECLSPEC_UUID("{BE7A9CC9-5F9E-11D2-960F-00C04F8EE628}") ISpEventSink;
typedef TComInterface<ISpEventSink, &IID_ISpEventSink> ISpEventSinkPtr;

interface DECLSPEC_UUID("{5B559F40-E952-11D2-BB91-00C04F8EE6C0}") ISpObjectWithToken;
typedef TComInterface<ISpObjectWithToken, &IID_ISpObjectWithToken> ISpObjectWithTokenPtr;

interface DECLSPEC_UUID("{C05C768F-FAE8-4EC2-8E07-338321C12452}") ISpAudio;
typedef TComInterface<ISpAudio, &IID_ISpAudio> ISpAudioPtr;

interface DECLSPEC_UUID("{15806F6E-1D70-4B48-98E6-3B1A007509AB}") ISpMMSysAudio;
typedef TComInterface<ISpMMSysAudio, &IID_ISpMMSysAudio> ISpMMSysAudioPtr;

interface DECLSPEC_UUID("{12E3CCA9-7518-44C5-A5E7-BA5A79CB929E}") ISpStream;
typedef TComInterface<ISpStream, &IID_ISpStream> ISpStreamPtr;

interface DECLSPEC_UUID("{6C44DF74-72B9-4992-A1EC-EF996E0422D4}") ISpVoice;
typedef TComInterface<ISpVoice, &IID_ISpVoice> ISpVoicePtr;

interface DECLSPEC_UUID("{B2745EFD-42CE-48CA-81F1-A96E02538A90}") ISpPhoneticAlphabetSelection;
typedef TComInterface<ISpPhoneticAlphabetSelection, &IID_ISpPhoneticAlphabetSelection> ISpPhoneticAlphabetSelectionPtr;

interface DECLSPEC_UUID("{F740A62F-7C15-489E-8234-940A33D9272D}") ISpRecoContext;
typedef TComInterface<ISpRecoContext, &IID_ISpRecoContext> ISpRecoContextPtr;

interface DECLSPEC_UUID("{BEAD311C-52FF-437F-9464-6B21054CA73D}") ISpRecoContext2;
typedef TComInterface<ISpRecoContext2, &IID_ISpRecoContext2> ISpRecoContext2Ptr;

interface DECLSPEC_UUID("{5B4FB971-B115-4DE1-AD97-E482E3BF6EE4}") ISpProperties;
typedef TComInterface<ISpProperties, &IID_ISpProperties> ISpPropertiesPtr;

interface DECLSPEC_UUID("{C2B5F241-DAA0-4507-9E16-5A1EAA2B7A5C}") ISpRecognizer;
typedef TComInterface<ISpRecognizer, &IID_ISpRecognizer> ISpRecognizerPtr;

interface DECLSPEC_UUID("{1A5C0354-B621-4B5A-8791-D306ED379E53}") ISpPhrase;
typedef TComInterface<ISpPhrase, &IID_ISpPhrase> ISpPhrasePtr;

interface DECLSPEC_UUID("{8137828F-591A-4A42-BE58-49EA7EBAAC68}") ISpGrammarBuilder;
typedef TComInterface<ISpGrammarBuilder, &IID_ISpGrammarBuilder> ISpGrammarBuilderPtr;

interface DECLSPEC_UUID("{2177DB29-7F45-47D0-8554-067E91C80502}") ISpRecoGrammar;
typedef TComInterface<ISpRecoGrammar, &IID_ISpRecoGrammar> ISpRecoGrammarPtr;

interface DECLSPEC_UUID("{20B053BE-E235-43CD-9A2A-8D17A48B7842}") ISpRecoResult;
typedef TComInterface<ISpRecoResult, &IID_ISpRecoResult> ISpRecoResultPtr;

interface DECLSPEC_UUID("{8FCEBC98-4E49-4067-9C6C-D86A0E092E3D}") ISpPhraseAlt;
typedef TComInterface<ISpPhraseAlt, &IID_ISpPhraseAlt> ISpPhraseAltPtr;

interface DECLSPEC_UUID("{8FC6D974-C81E-4098-93C5-0147F61ED4D3}") ISpRecognizer2;
typedef TComInterface<ISpRecognizer2, &IID_ISpRecognizer2> ISpRecognizer2Ptr;

interface DECLSPEC_UUID("{DF1B943C-5838-4AA2-8706-D7CD5B333499}") ISpRecognizer3;
typedef TComInterface<ISpRecognizer3, &IID_ISpRecognizer3> ISpRecognizer3Ptr;

interface DECLSPEC_UUID("{21B501A0-0EC7-46C9-92C3-A2BC784C54B9}") ISpSerializeState;
typedef TComInterface<ISpSerializeState, &IID_ISpSerializeState> ISpSerializeStatePtr;

interface DECLSPEC_UUID("{DA0CD0F9-14A2-4F09-8C2A-85CC48979345}") ISpRecoCategory;
typedef TComInterface<ISpRecoCategory, &IID_ISpRecoCategory> ISpRecoCategoryPtr;

interface DECLSPEC_UUID("{DA41A7C2-5383-4DB2-916B-6C1719E3DB58}") ISpLexicon;
typedef TComInterface<ISpLexicon, &IID_ISpLexicon> ISpLexiconPtr;

interface DECLSPEC_UUID("{3DF681E2-EA56-11D9-8BDE-F66BAD1E3F3A}") ISpShortcut;
typedef TComInterface<ISpShortcut, &IID_ISpShortcut> ISpShortcutPtr;

interface DECLSPEC_UUID("{8445C581-0CAC-4A38-ABFE-9B2CE2826455}") ISpPhoneConverter;
typedef TComInterface<ISpPhoneConverter, &IID_ISpPhoneConverter> ISpPhoneConverterPtr;

interface DECLSPEC_UUID("{133ADCD4-19B4-4020-9FDC-842E78253B17}") ISpPhoneticAlphabetConverter;
typedef TComInterface<ISpPhoneticAlphabetConverter, &IID_ISpPhoneticAlphabetConverter> ISpPhoneticAlphabetConverterPtr;

interface DECLSPEC_UUID("{AE39362B-45A8-4074-9B9E-CCF49AA2D0B6}") ISpXMLRecoResult;
typedef TComInterface<ISpXMLRecoResult, &IID_ISpXMLRecoResult> ISpXMLRecoResultPtr;

interface DECLSPEC_UUID("{4B37BC9E-9ED6-44A3-93D3-18F022B79EC3}") ISpRecoGrammar2;
typedef TComInterface<ISpRecoGrammar2, &IID_ISpRecoGrammar2> ISpRecoGrammar2Ptr;

interface DECLSPEC_UUID("{B9AC5783-FCD0-4B21-B119-B4F8DA8FD2C3}") ISpeechResourceLoader;
typedef TComInterface<ISpeechResourceLoader, &IID_ISpeechResourceLoader> ISpeechResourceLoaderPtr;

interface DECLSPEC_UUID("{79EAC9EE-BAF9-11CE-8C82-00AA004BA90B}") IInternetSecurityManager;
typedef TComInterface<IInternetSecurityManager, &IID_IInternetSecurityManager> IInternetSecurityManagerPtr;

interface DECLSPEC_UUID("{79EAC9ED-BAF9-11CE-8C82-00AA004BA90B}") IInternetSecurityMgrSite;
typedef TComInterface<IInternetSecurityMgrSite, &IID_IInternetSecurityMgrSite> IInternetSecurityMgrSitePtr;

interface DECLSPEC_UUID("{00000101-0000-0000-C000-000000000046}") IEnumString;
typedef TComInterface<IEnumString, &IID_IEnumString> IEnumStringPtr;


// *********************************************************************//
// Declaration of CoClasses defined in Type Library                       
// (NOTE: Here we map each CoClass to its Default Interface)              
//                                                                        
// The LIBID_OF_ macro(s) map a LIBID_OF_CoClassName to the GUID of this  
// TypeLibrary. It simplifies the updating of macros when CoClass name    
// change.                                                                
// *********************************************************************//
typedef ISpNotifyTranslator SpNotifyTranslator;
typedef ISpNotifyTranslatorPtr SpNotifyTranslatorPtr;
typedef ISpeechObjectTokenCategory SpObjectTokenCategory;
typedef ISpeechObjectTokenCategoryPtr SpObjectTokenCategoryPtr;
typedef ISpeechObjectToken SpObjectToken;
typedef ISpeechObjectTokenPtr SpObjectTokenPtr;
typedef ISpResourceManager SpResourceManager;
typedef ISpResourceManagerPtr SpResourceManagerPtr;
typedef ISpStreamFormatConverter SpStreamFormatConverter;
typedef ISpStreamFormatConverterPtr SpStreamFormatConverterPtr;
typedef IEnumSpObjectTokens SpMMAudioEnum;
typedef IEnumSpObjectTokensPtr SpMMAudioEnumPtr;
typedef ISpeechMMSysAudio SpMMAudioIn;
typedef ISpeechMMSysAudioPtr SpMMAudioInPtr;
typedef ISpeechMMSysAudio SpMMAudioOut;
typedef ISpeechMMSysAudioPtr SpMMAudioOutPtr;
typedef ISpStream SpStream;
typedef ISpStreamPtr SpStreamPtr;
typedef ISpeechVoice SpVoice;
typedef ISpeechVoicePtr SpVoicePtr;
typedef ISpeechRecoContext SpSharedRecoContext;
typedef ISpeechRecoContextPtr SpSharedRecoContextPtr;
typedef ISpeechRecognizer SpInprocRecognizer;
typedef ISpeechRecognizerPtr SpInprocRecognizerPtr;
typedef ISpeechRecognizer SpSharedRecognizer;
typedef ISpeechRecognizerPtr SpSharedRecognizerPtr;
typedef ISpeechLexicon SpLexicon;
typedef ISpeechLexiconPtr SpLexiconPtr;
typedef ISpeechLexicon SpUnCompressedLexicon;
typedef ISpeechLexiconPtr SpUnCompressedLexiconPtr;
typedef ISpLexicon SpCompressedLexicon;
typedef ISpLexiconPtr SpCompressedLexiconPtr;
typedef ISpShortcut SpShortcut;
typedef ISpShortcutPtr SpShortcutPtr;
typedef ISpeechPhoneConverter SpPhoneConverter;
typedef ISpeechPhoneConverterPtr SpPhoneConverterPtr;
typedef ISpPhoneticAlphabetConverter SpPhoneticAlphabetConverter;
typedef ISpPhoneticAlphabetConverterPtr SpPhoneticAlphabetConverterPtr;
typedef ISpPhoneConverter SpNullPhoneConverter;
typedef ISpPhoneConverterPtr SpNullPhoneConverterPtr;
typedef ISpeechTextSelectionInformation SpTextSelectionInformation;
typedef ISpeechTextSelectionInformationPtr SpTextSelectionInformationPtr;
typedef ISpeechPhraseInfoBuilder SpPhraseInfoBuilder;
typedef ISpeechPhraseInfoBuilderPtr SpPhraseInfoBuilderPtr;
typedef ISpeechAudioFormat SpAudioFormat;
typedef ISpeechAudioFormatPtr SpAudioFormatPtr;
typedef ISpeechWaveFormatEx SpWaveFormatEx;
typedef ISpeechWaveFormatExPtr SpWaveFormatExPtr;
typedef ISpeechRecoContext SpInProcRecoContext;
typedef ISpeechRecoContextPtr SpInProcRecoContextPtr;
typedef ISpeechCustomStream SpCustomStream;
typedef ISpeechCustomStreamPtr SpCustomStreamPtr;
typedef ISpeechFileStream SpFileStream;
typedef ISpeechFileStreamPtr SpFileStreamPtr;
typedef ISpeechMemoryStream SpMemoryStream;
typedef ISpeechMemoryStreamPtr SpMemoryStreamPtr;

#define LIBID_OF_SpNotifyTranslator (&LIBID_SpeechLib)
#define LIBID_OF_SpObjectTokenCategory (&LIBID_SpeechLib)
#define LIBID_OF_SpObjectToken (&LIBID_SpeechLib)
#define LIBID_OF_SpResourceManager (&LIBID_SpeechLib)
#define LIBID_OF_SpStreamFormatConverter (&LIBID_SpeechLib)
#define LIBID_OF_SpMMAudioEnum (&LIBID_SpeechLib)
#define LIBID_OF_SpMMAudioIn (&LIBID_SpeechLib)
#define LIBID_OF_SpMMAudioOut (&LIBID_SpeechLib)
#define LIBID_OF_SpStream (&LIBID_SpeechLib)
#define LIBID_OF_SpVoice (&LIBID_SpeechLib)
#define LIBID_OF_SpSharedRecoContext (&LIBID_SpeechLib)
#define LIBID_OF_SpInprocRecognizer (&LIBID_SpeechLib)
#define LIBID_OF_SpSharedRecognizer (&LIBID_SpeechLib)
#define LIBID_OF_SpLexicon (&LIBID_SpeechLib)
#define LIBID_OF_SpUnCompressedLexicon (&LIBID_SpeechLib)
#define LIBID_OF_SpCompressedLexicon (&LIBID_SpeechLib)
#define LIBID_OF_SpShortcut (&LIBID_SpeechLib)
#define LIBID_OF_SpPhoneConverter (&LIBID_SpeechLib)
#define LIBID_OF_SpPhoneticAlphabetConverter (&LIBID_SpeechLib)
#define LIBID_OF_SpNullPhoneConverter (&LIBID_SpeechLib)
#define LIBID_OF_SpTextSelectionInformation (&LIBID_SpeechLib)
#define LIBID_OF_SpPhraseInfoBuilder (&LIBID_SpeechLib)
#define LIBID_OF_SpAudioFormat (&LIBID_SpeechLib)
#define LIBID_OF_SpWaveFormatEx (&LIBID_SpeechLib)
#define LIBID_OF_SpInProcRecoContext (&LIBID_SpeechLib)
#define LIBID_OF_SpCustomStream (&LIBID_SpeechLib)
#define LIBID_OF_SpFileStream (&LIBID_SpeechLib)
#define LIBID_OF_SpMemoryStream (&LIBID_SpeechLib)

// *********************************************************************//
// Declaration of Aliases defined in Type Library                         
// *********************************************************************//
typedef Speechlib_tlb::_RemotableHandle* wireHWND;
typedef unsigned_long UINT_PTR;
typedef long LONG_PTR;
typedef Speechlib_tlb::_SPAUDIOSTATE SPAUDIOSTATE;
typedef Speechlib_tlb::SPWAVEFORMATTYPE SPSTREAMFORMATTYPE;
typedef Speechlib_tlb::tagSPPROPERTYINFO SPPROPERTYINFO;
typedef Speechlib_tlb::tagSPTEXTSELECTIONINFO SPTEXTSELECTIONINFO;
typedef unsigned_long ULONG_PTR;

// *********************************************************************//
// Declaration of Enumerations defined in Type Library                    
// *********************************************************************//
enum class SpeechDataKeyLocation
{
  SDKLDefaultLocation = 0, 
  SDKLCurrentUser = 1, 
  SDKLLocalMachine = 2, 
  SDKLCurrentConfig = 5
};

enum class SpeechTokenContext
{
  STCInprocServer = 1, 
  STCInprocHandler = 2, 
  STCLocalServer = 4, 
  STCRemoteServer = 16, 
  STCAll = 23
};

enum class SpeechTokenShellFolder
{
  STSF_AppData = 26, 
  STSF_LocalAppData = 28, 
  STSF_CommonAppData = 35, 
  STSF_FlagCreate = 32768
};

enum class SpeechAudioState
{
  SASClosed = 0, 
  SASStop = 1, 
  SASPause = 2, 
  SASRun = 3
};

enum class SpeechAudioFormatType
{
  SAFTDefault = (int)-1,  //0xFFFFFFFF
  SAFTNoAssignedFormat = 0, 
  SAFTText = 1, 
  SAFTNonStandardFormat = 2, 
  SAFTExtendedAudioFormat = 3, 
  SAFT8kHz8BitMono = 4, 
  SAFT8kHz8BitStereo = 5, 
  SAFT8kHz16BitMono = 6, 
  SAFT8kHz16BitStereo = 7, 
  SAFT11kHz8BitMono = 8, 
  SAFT11kHz8BitStereo = 9, 
  SAFT11kHz16BitMono = 10, 
  SAFT11kHz16BitStereo = 11, 
  SAFT12kHz8BitMono = 12, 
  SAFT12kHz8BitStereo = 13, 
  SAFT12kHz16BitMono = 14, 
  SAFT12kHz16BitStereo = 15, 
  SAFT16kHz8BitMono = 16, 
  SAFT16kHz8BitStereo = 17, 
  SAFT16kHz16BitMono = 18, 
  SAFT16kHz16BitStereo = 19, 
  SAFT22kHz8BitMono = 20, 
  SAFT22kHz8BitStereo = 21, 
  SAFT22kHz16BitMono = 22, 
  SAFT22kHz16BitStereo = 23, 
  SAFT24kHz8BitMono = 24, 
  SAFT24kHz8BitStereo = 25, 
  SAFT24kHz16BitMono = 26, 
  SAFT24kHz16BitStereo = 27, 
  SAFT32kHz8BitMono = 28, 
  SAFT32kHz8BitStereo = 29, 
  SAFT32kHz16BitMono = 30, 
  SAFT32kHz16BitStereo = 31, 
  SAFT44kHz8BitMono = 32, 
  SAFT44kHz8BitStereo = 33, 
  SAFT44kHz16BitMono = 34, 
  SAFT44kHz16BitStereo = 35, 
  SAFT48kHz8BitMono = 36, 
  SAFT48kHz8BitStereo = 37, 
  SAFT48kHz16BitMono = 38, 
  SAFT48kHz16BitStereo = 39, 
  SAFTTrueSpeech_8kHz1BitMono = 40, 
  SAFTCCITT_ALaw_8kHzMono = 41, 
  SAFTCCITT_ALaw_8kHzStereo = 42, 
  SAFTCCITT_ALaw_11kHzMono = 43, 
  SAFTCCITT_ALaw_11kHzStereo = 44, 
  SAFTCCITT_ALaw_22kHzMono = 45, 
  SAFTCCITT_ALaw_22kHzStereo = 46, 
  SAFTCCITT_ALaw_44kHzMono = 47, 
  SAFTCCITT_ALaw_44kHzStereo = 48, 
  SAFTCCITT_uLaw_8kHzMono = 49, 
  SAFTCCITT_uLaw_8kHzStereo = 50, 
  SAFTCCITT_uLaw_11kHzMono = 51, 
  SAFTCCITT_uLaw_11kHzStereo = 52, 
  SAFTCCITT_uLaw_22kHzMono = 53, 
  SAFTCCITT_uLaw_22kHzStereo = 54, 
  SAFTCCITT_uLaw_44kHzMono = 55, 
  SAFTCCITT_uLaw_44kHzStereo = 56, 
  SAFTADPCM_8kHzMono = 57, 
  SAFTADPCM_8kHzStereo = 58, 
  SAFTADPCM_11kHzMono = 59, 
  SAFTADPCM_11kHzStereo = 60, 
  SAFTADPCM_22kHzMono = 61, 
  SAFTADPCM_22kHzStereo = 62, 
  SAFTADPCM_44kHzMono = 63, 
  SAFTADPCM_44kHzStereo = 64, 
  SAFTGSM610_8kHzMono = 65, 
  SAFTGSM610_11kHzMono = 66, 
  SAFTGSM610_22kHzMono = 67, 
  SAFTGSM610_44kHzMono = 68
};

enum class SpeechStreamSeekPositionType
{
  SSSPTRelativeToStart = 0, 
  SSSPTRelativeToCurrentPosition = 1, 
  SSSPTRelativeToEnd = 2
};

enum class SpeechStreamFileMode
{
  SSFMOpenForRead = 0, 
  SSFMOpenReadWrite = 1, 
  SSFMCreate = 2, 
  SSFMCreateForWrite = 3
};

enum class SpeechRunState
{
  SRSEDone = 1, 
  SRSEIsSpeaking = 2
};

enum class SpeechVoiceEvents
{
  SVEStartInputStream = 2, 
  SVEEndInputStream = 4, 
  SVEVoiceChange = 8, 
  SVEBookmark = 16, 
  SVEWordBoundary = 32, 
  SVEPhoneme = 64, 
  SVESentenceBoundary = 128, 
  SVEViseme = 256, 
  SVEAudioLevel = 512, 
  SVEPrivate = 32768, 
  SVEAllEvents = 33790
};

enum class SpeechVoicePriority
{
  SVPNormal = 0, 
  SVPAlert = 1, 
  SVPOver = 2
};

enum class SpeechVoiceSpeakFlags
{
  SVSFDefault = 0, 
  SVSFlagsAsync = 1, 
  SVSFPurgeBeforeSpeak = 2, 
  SVSFIsFilename = 4, 
  SVSFIsXML = 8, 
  SVSFIsNotXML = 16, 
  SVSFPersistXML = 32, 
  SVSFNLPSpeakPunc = 64, 
  SVSFParseSapi = 128, 
  SVSFParseSsml = 256, 
  SVSFParseAutodetect = 0, 
  SVSFNLPMask = 64, 
  SVSFParseMask = 384, 
  SVSFVoiceMask = 511, 
  SVSFUnusedFlags = (int)-512 //0xFFFFFE00
};

enum class SpeechVisemeFeature
{
  SVF_None = 0, 
  SVF_Stressed = 1, 
  SVF_Emphasis = 2
};

enum class SpeechVisemeType
{
  SVP_0 = 0, 
  SVP_1 = 1, 
  SVP_2 = 2, 
  SVP_3 = 3, 
  SVP_4 = 4, 
  SVP_5 = 5, 
  SVP_6 = 6, 
  SVP_7 = 7, 
  SVP_8 = 8, 
  SVP_9 = 9, 
  SVP_10 = 10, 
  SVP_11 = 11, 
  SVP_12 = 12, 
  SVP_13 = 13, 
  SVP_14 = 14, 
  SVP_15 = 15, 
  SVP_16 = 16, 
  SVP_17 = 17, 
  SVP_18 = 18, 
  SVP_19 = 19, 
  SVP_20 = 20, 
  SVP_21 = 21
};

enum class SpeechRecognizerState
{
  SRSInactive = 0, 
  SRSActive = 1, 
  SRSActiveAlways = 2, 
  SRSInactiveWithPurge = 3
};

enum class SpeechInterference
{
  SINone = 0, 
  SINoise = 1, 
  SINoSignal = 2, 
  SITooLoud = 3, 
  SITooQuiet = 4, 
  SITooFast = 5, 
  SITooSlow = 6
};

enum class SpeechRecoEvents
{
  SREStreamEnd = 1, 
  SRESoundStart = 2, 
  SRESoundEnd = 4, 
  SREPhraseStart = 8, 
  SRERecognition = 16, 
  SREHypothesis = 32, 
  SREBookmark = 64, 
  SREPropertyNumChange = 128, 
  SREPropertyStringChange = 256, 
  SREFalseRecognition = 512, 
  SREInterference = 1024, 
  SRERequestUI = 2048, 
  SREStateChange = 4096, 
  SREAdaptation = 8192, 
  SREStreamStart = 16384, 
  SRERecoOtherContext = 32768, 
  SREAudioLevel = 65536, 
  SREPrivate = 262144, 
  SREAllEvents = 393215
};

enum class SpeechRecoContextState
{
  SRCS_Disabled = 0, 
  SRCS_Enabled = 1
};

enum class SpeechRetainedAudioOptions
{
  SRAONone = 0, 
  SRAORetainAudio = 1
};

enum class SpeechGrammarState
{
  SGSEnabled = 1, 
  SGSDisabled = 0, 
  SGSExclusive = 3
};

enum class SpeechRuleAttributes
{
  SRATopLevel = 1, 
  SRADefaultToActive = 2, 
  SRAExport = 4, 
  SRAImport = 8, 
  SRAInterpreter = 16, 
  SRADynamic = 32, 
  SRARoot = 64
};

enum class SpeechGrammarRuleStateTransitionType
{
  SGRSTTEpsilon = 0, 
  SGRSTTWord = 1, 
  SGRSTTRule = 2, 
  SGRSTTDictation = 3, 
  SGRSTTWildcard = 4, 
  SGRSTTTextBuffer = 5
};

enum class SpeechGrammarWordType
{
  SGDisplay = 0, 
  SGLexical = 1, 
  SGPronounciation = 2, 
  SGLexicalNoSpecialChars = 3
};

enum class SpeechSpecialTransitionType
{
  SSTTWildcard = 1, 
  SSTTDictation = 2, 
  SSTTTextBuffer = 3
};

enum class SpeechLoadOption
{
  SLOStatic = 0, 
  SLODynamic = 1
};

enum class SpeechRuleState
{
  SGDSInactive = 0, 
  SGDSActive = 1, 
  SGDSActiveWithAutoPause = 3, 
  SGDSActiveUserDelimited = 4
};

enum class SpeechWordPronounceable
{
  SWPUnknownWordUnpronounceable = 0, 
  SWPUnknownWordPronounceable = 1, 
  SWPKnownWordPronounceable = 2
};

enum class SpeechEngineConfidence
{
  SECLowConfidence = (int)-1,  //0xFFFFFFFF
  SECNormalConfidence = 0, 
  SECHighConfidence = 1
};

enum class SpeechDisplayAttributes
{
  SDA_No_Trailing_Space = 0, 
  SDA_One_Trailing_Space = 2, 
  SDA_Two_Trailing_Spaces = 4, 
  SDA_Consume_Leading_Spaces = 8
};

enum class SpeechDiscardType
{
  SDTProperty = 1, 
  SDTReplacement = 2, 
  SDTRule = 4, 
  SDTDisplayText = 8, 
  SDTLexicalForm = 16, 
  SDTPronunciation = 32, 
  SDTAudio = 64, 
  SDTAlternates = 128, 
  SDTAll = 255
};

enum class SpeechBookmarkOptions
{
  SBONone = 0, 
  SBOPause = 1
};

enum class SpeechFormatType
{
  SFTInput = 0, 
  SFTSREngine = 1
};

enum class SpeechRecognitionType
{
  SRTStandard = 0, 
  SRTAutopause = 1, 
  SRTEmulated = 2, 
  SRTSMLTimeout = 4, 
  SRTExtendableParse = 8, 
  SRTReSent = 16
};

enum class SpeechLexiconType
{
  SLTUser = 1, 
  SLTApp = 2
};

enum class SpeechWordType
{
  SWTAdded = 1, 
  SWTDeleted = 2
};

enum class SpeechPartOfSpeech
{
  SPSNotOverriden = (int)-1,  //0xFFFFFFFF
  SPSUnknown = 0, 
  SPSNoun = 4096, 
  SPSVerb = 8192, 
  SPSModifier = 12288, 
  SPSFunction = 16384, 
  SPSInterjection = 20480, 
  SPSLMA = 28672, 
  SPSSuppressWord = 61440
};

enum class DISPID_SpeechDataKey
{
  DISPID_SDKSetBinaryValue = 1, 
  DISPID_SDKGetBinaryValue = 2, 
  DISPID_SDKSetStringValue = 3, 
  DISPID_SDKGetStringValue = 4, 
  DISPID_SDKSetLongValue = 5, 
  DISPID_SDKGetlongValue = 6, 
  DISPID_SDKOpenKey = 7, 
  DISPID_SDKCreateKey = 8, 
  DISPID_SDKDeleteKey = 9, 
  DISPID_SDKDeleteValue = 10, 
  DISPID_SDKEnumKeys = 11, 
  DISPID_SDKEnumValues = 12
};

enum class DISPID_SpeechObjectToken
{
  DISPID_SOTId = 1, 
  DISPID_SOTDataKey = 2, 
  DISPID_SOTCategory = 3, 
  DISPID_SOTGetDescription = 4, 
  DISPID_SOTSetId = 5, 
  DISPID_SOTGetAttribute = 6, 
  DISPID_SOTCreateInstance = 7, 
  DISPID_SOTRemove = 8, 
  DISPID_SOTGetStorageFileName = 9, 
  DISPID_SOTRemoveStorageFileName = 10, 
  DISPID_SOTIsUISupported = 11, 
  DISPID_SOTDisplayUI = 12, 
  DISPID_SOTMatchesAttributes = 13
};

enum class DISPID_SpeechObjectTokens
{
  DISPID_SOTsCount = 1, 
  DISPID_SOTsItem = 0, 
  DISPID_SOTs_NewEnum = (int)-4 //0xFFFFFFFC
};

enum class DISPID_SpeechObjectTokenCategory
{
  DISPID_SOTCId = 1, 
  DISPID_SOTCDefault = 2, 
  DISPID_SOTCSetId = 3, 
  DISPID_SOTCGetDataKey = 4, 
  DISPID_SOTCEnumerateTokens = 5
};

enum class DISPID_SpeechAudioFormat
{
  DISPID_SAFType = 1, 
  DISPID_SAFGuid = 2, 
  DISPID_SAFGetWaveFormatEx = 3, 
  DISPID_SAFSetWaveFormatEx = 4
};

enum class DISPID_SpeechBaseStream
{
  DISPID_SBSFormat = 1, 
  DISPID_SBSRead = 2, 
  DISPID_SBSWrite = 3, 
  DISPID_SBSSeek = 4
};

enum class DISPID_SpeechAudio
{
  DISPID_SAStatus = 200, 
  DISPID_SABufferInfo = 201, 
  DISPID_SADefaultFormat = 202, 
  DISPID_SAVolume = 203, 
  DISPID_SABufferNotifySize = 204, 
  DISPID_SAEventHandle = 205, 
  DISPID_SASetState = 206
};

enum class DISPID_SpeechMMSysAudio
{
  DISPID_SMSADeviceId = 300, 
  DISPID_SMSALineId = 301, 
  DISPID_SMSAMMHandle = 302
};

enum class DISPID_SpeechFileStream
{
  DISPID_SFSOpen = 100, 
  DISPID_SFSClose = 101
};

enum class DISPID_SpeechCustomStream
{
  DISPID_SCSBaseStream = 100
};

enum class DISPID_SpeechMemoryStream
{
  DISPID_SMSSetData = 100, 
  DISPID_SMSGetData = 101
};

enum class DISPID_SpeechAudioStatus
{
  DISPID_SASFreeBufferSpace = 1, 
  DISPID_SASNonBlockingIO = 2, 
  DISPID_SASState = 3, 
  DISPID_SASCurrentSeekPosition = 4, 
  DISPID_SASCurrentDevicePosition = 5
};

enum class DISPID_SpeechAudioBufferInfo
{
  DISPID_SABIMinNotification = 1, 
  DISPID_SABIBufferSize = 2, 
  DISPID_SABIEventBias = 3
};

enum class DISPID_SpeechWaveFormatEx
{
  DISPID_SWFEFormatTag = 1, 
  DISPID_SWFEChannels = 2, 
  DISPID_SWFESamplesPerSec = 3, 
  DISPID_SWFEAvgBytesPerSec = 4, 
  DISPID_SWFEBlockAlign = 5, 
  DISPID_SWFEBitsPerSample = 6, 
  DISPID_SWFEExtraData = 7
};

enum class DISPID_SpeechVoice
{
  DISPID_SVStatus = 1, 
  DISPID_SVVoice = 2, 
  DISPID_SVAudioOutput = 3, 
  DISPID_SVAudioOutputStream = 4, 
  DISPID_SVRate = 5, 
  DISPID_SVVolume = 6, 
  DISPID_SVAllowAudioOuputFormatChangesOnNextSet = 7, 
  DISPID_SVEventInterests = 8, 
  DISPID_SVPriority = 9, 
  DISPID_SVAlertBoundary = 10, 
  DISPID_SVSyncronousSpeakTimeout = 11, 
  DISPID_SVSpeak = 12, 
  DISPID_SVSpeakStream = 13, 
  DISPID_SVPause = 14, 
  DISPID_SVResume = 15, 
  DISPID_SVSkip = 16, 
  DISPID_SVGetVoices = 17, 
  DISPID_SVGetAudioOutputs = 18, 
  DISPID_SVWaitUntilDone = 19, 
  DISPID_SVSpeakCompleteEvent = 20, 
  DISPID_SVIsUISupported = 21, 
  DISPID_SVDisplayUI = 22
};

enum class DISPID_SpeechVoiceStatus
{
  DISPID_SVSCurrentStreamNumber = 1, 
  DISPID_SVSLastStreamNumberQueued = 2, 
  DISPID_SVSLastResult = 3, 
  DISPID_SVSRunningState = 4, 
  DISPID_SVSInputWordPosition = 5, 
  DISPID_SVSInputWordLength = 6, 
  DISPID_SVSInputSentencePosition = 7, 
  DISPID_SVSInputSentenceLength = 8, 
  DISPID_SVSLastBookmark = 9, 
  DISPID_SVSLastBookmarkId = 10, 
  DISPID_SVSPhonemeId = 11, 
  DISPID_SVSVisemeId = 12
};

enum class DISPID_SpeechVoiceEvent
{
  DISPID_SVEStreamStart = 1, 
  DISPID_SVEStreamEnd = 2, 
  DISPID_SVEVoiceChange = 3, 
  DISPID_SVEBookmark = 4, 
  DISPID_SVEWord = 5, 
  DISPID_SVEPhoneme = 6, 
  DISPID_SVESentenceBoundary = 7, 
  DISPID_SVEViseme = 8, 
  DISPID_SVEAudioLevel = 9, 
  DISPID_SVEEnginePrivate = 10
};

enum class DISPID_SpeechRecognizer
{
  DISPID_SRRecognizer = 1, 
  DISPID_SRAllowAudioInputFormatChangesOnNextSet = 2, 
  DISPID_SRAudioInput = 3, 
  DISPID_SRAudioInputStream = 4, 
  DISPID_SRIsShared = 5, 
  DISPID_SRState = 6, 
  DISPID_SRStatus = 7, 
  DISPID_SRProfile = 8, 
  DISPID_SREmulateRecognition = 9, 
  DISPID_SRCreateRecoContext = 10, 
  DISPID_SRGetFormat = 11, 
  DISPID_SRSetPropertyNumber = 12, 
  DISPID_SRGetPropertyNumber = 13, 
  DISPID_SRSetPropertyString = 14, 
  DISPID_SRGetPropertyString = 15, 
  DISPID_SRIsUISupported = 16, 
  DISPID_SRDisplayUI = 17, 
  DISPID_SRGetRecognizers = 18, 
  DISPID_SVGetAudioInputs = 19, 
  DISPID_SVGetProfiles = 20
};

enum class SpeechEmulationCompareFlags
{
  SECFIgnoreCase = 1, 
  SECFIgnoreKanaType = 65536, 
  SECFIgnoreWidth = 131072, 
  SECFNoSpecialChars = 536870912, 
  SECFEmulateResult = 1073741824, 
  SECFDefault = 196609
};

enum class DISPID_SpeechRecognizerStatus
{
  DISPID_SRSAudioStatus = 1, 
  DISPID_SRSCurrentStreamPosition = 2, 
  DISPID_SRSCurrentStreamNumber = 3, 
  DISPID_SRSNumberOfActiveRules = 4, 
  DISPID_SRSClsidEngine = 5, 
  DISPID_SRSSupportedLanguages = 6
};

enum class DISPID_SpeechRecoContext
{
  DISPID_SRCRecognizer = 1, 
  DISPID_SRCAudioInInterferenceStatus = 2, 
  DISPID_SRCRequestedUIType = 3, 
  DISPID_SRCVoice = 4, 
  DISPID_SRAllowVoiceFormatMatchingOnNextSet = 5, 
  DISPID_SRCVoicePurgeEvent = 6, 
  DISPID_SRCEventInterests = 7, 
  DISPID_SRCCmdMaxAlternates = 8, 
  DISPID_SRCState = 9, 
  DISPID_SRCRetainedAudio = 10, 
  DISPID_SRCRetainedAudioFormat = 11, 
  DISPID_SRCPause = 12, 
  DISPID_SRCResume = 13, 
  DISPID_SRCCreateGrammar = 14, 
  DISPID_SRCCreateResultFromMemory = 15, 
  DISPID_SRCBookmark = 16, 
  DISPID_SRCSetAdaptationData = 17
};

enum class DISPIDSPRG
{
  DISPID_SRGId = 1, 
  DISPID_SRGRecoContext = 2, 
  DISPID_SRGState = 3, 
  DISPID_SRGRules = 4, 
  DISPID_SRGReset = 5, 
  DISPID_SRGCommit = 6, 
  DISPID_SRGCmdLoadFromFile = 7, 
  DISPID_SRGCmdLoadFromObject = 8, 
  DISPID_SRGCmdLoadFromResource = 9, 
  DISPID_SRGCmdLoadFromMemory = 10, 
  DISPID_SRGCmdLoadFromProprietaryGrammar = 11, 
  DISPID_SRGCmdSetRuleState = 12, 
  DISPID_SRGCmdSetRuleIdState = 13, 
  DISPID_SRGDictationLoad = 14, 
  DISPID_SRGDictationUnload = 15, 
  DISPID_SRGDictationSetState = 16, 
  DISPID_SRGSetWordSequenceData = 17, 
  DISPID_SRGSetTextSelection = 18, 
  DISPID_SRGIsPronounceable = 19
};

enum class DISPID_SpeechRecoContextEvents
{
  DISPID_SRCEStartStream = 1, 
  DISPID_SRCEEndStream = 2, 
  DISPID_SRCEBookmark = 3, 
  DISPID_SRCESoundStart = 4, 
  DISPID_SRCESoundEnd = 5, 
  DISPID_SRCEPhraseStart = 6, 
  DISPID_SRCERecognition = 7, 
  DISPID_SRCEHypothesis = 8, 
  DISPID_SRCEPropertyNumberChange = 9, 
  DISPID_SRCEPropertyStringChange = 10, 
  DISPID_SRCEFalseRecognition = 11, 
  DISPID_SRCEInterference = 12, 
  DISPID_SRCERequestUI = 13, 
  DISPID_SRCERecognizerStateChange = 14, 
  DISPID_SRCEAdaptation = 15, 
  DISPID_SRCERecognitionForOtherContext = 16, 
  DISPID_SRCEAudioLevel = 17, 
  DISPID_SRCEEnginePrivate = 18
};

enum class DISPID_SpeechGrammarRule
{
  DISPID_SGRAttributes = 1, 
  DISPID_SGRInitialState = 2, 
  DISPID_SGRName = 3, 
  DISPID_SGRId = 4, 
  DISPID_SGRClear = 5, 
  DISPID_SGRAddResource = 6, 
  DISPID_SGRAddState = 7
};

enum class DISPID_SpeechGrammarRules
{
  DISPID_SGRsCount = 1, 
  DISPID_SGRsDynamic = 2, 
  DISPID_SGRsAdd = 3, 
  DISPID_SGRsCommit = 4, 
  DISPID_SGRsCommitAndSave = 5, 
  DISPID_SGRsFindRule = 6, 
  DISPID_SGRsItem = 0, 
  DISPID_SGRs_NewEnum = (int)-4 //0xFFFFFFFC
};

enum class DISPID_SpeechGrammarRuleState
{
  DISPID_SGRSRule = 1, 
  DISPID_SGRSTransitions = 2, 
  DISPID_SGRSAddWordTransition = 3, 
  DISPID_SGRSAddRuleTransition = 4, 
  DISPID_SGRSAddSpecialTransition = 5
};

enum class DISPID_SpeechGrammarRuleStateTransitions
{
  DISPID_SGRSTsCount = 1, 
  DISPID_SGRSTsItem = 0, 
  DISPID_SGRSTs_NewEnum = (int)-4 //0xFFFFFFFC
};

enum class DISPID_SpeechGrammarRuleStateTransition
{
  DISPID_SGRSTType = 1, 
  DISPID_SGRSTText = 2, 
  DISPID_SGRSTRule = 3, 
  DISPID_SGRSTWeight = 4, 
  DISPID_SGRSTPropertyName = 5, 
  DISPID_SGRSTPropertyId = 6, 
  DISPID_SGRSTPropertyValue = 7, 
  DISPID_SGRSTNextState = 8
};

enum class DISPIDSPTSI
{
  DISPIDSPTSI_ActiveOffset = 1, 
  DISPIDSPTSI_ActiveLength = 2, 
  DISPIDSPTSI_SelectionOffset = 3, 
  DISPIDSPTSI_SelectionLength = 4
};

enum class DISPID_SpeechRecoResult
{
  DISPID_SRRRecoContext = 1, 
  DISPID_SRRTimes = 2, 
  DISPID_SRRAudioFormat = 3, 
  DISPID_SRRPhraseInfo = 4, 
  DISPID_SRRAlternates = 5, 
  DISPID_SRRAudio = 6, 
  DISPID_SRRSpeakAudio = 7, 
  DISPID_SRRSaveToMemory = 8, 
  DISPID_SRRDiscardResultInfo = 9
};

enum class DISPID_SpeechXMLRecoResult
{
  DISPID_SRRGetXMLResult = 10, 
  DISPID_SRRGetXMLErrorInfo = 11
};

enum class SPXMLRESULTOPTIONS
{
  SPXRO_SML = 0, 
  SPXRO_Alternates_SML = 1
};

enum class DISPID_SpeechRecoResult2
{
  DISPID_SRRSetTextFeedback = 12
};

enum class DISPID_SpeechPhraseBuilder
{
  DISPID_SPPBRestorePhraseFromMemory = 1
};

enum class DISPID_SpeechRecoResultTimes
{
  DISPID_SRRTStreamTime = 1, 
  DISPID_SRRTLength = 2, 
  DISPID_SRRTTickCount = 3, 
  DISPID_SRRTOffsetFromStart = 4
};

enum class DISPID_SpeechPhraseAlternate
{
  DISPID_SPARecoResult = 1, 
  DISPID_SPAStartElementInResult = 2, 
  DISPID_SPANumberOfElementsInResult = 3, 
  DISPID_SPAPhraseInfo = 4, 
  DISPID_SPACommit = 5
};

enum class DISPID_SpeechPhraseAlternates
{
  DISPID_SPAsCount = 1, 
  DISPID_SPAsItem = 0, 
  DISPID_SPAs_NewEnum = (int)-4 //0xFFFFFFFC
};

enum class DISPID_SpeechPhraseInfo
{
  DISPID_SPILanguageId = 1, 
  DISPID_SPIGrammarId = 2, 
  DISPID_SPIStartTime = 3, 
  DISPID_SPIAudioStreamPosition = 4, 
  DISPID_SPIAudioSizeBytes = 5, 
  DISPID_SPIRetainedSizeBytes = 6, 
  DISPID_SPIAudioSizeTime = 7, 
  DISPID_SPIRule = 8, 
  DISPID_SPIProperties = 9, 
  DISPID_SPIElements = 10, 
  DISPID_SPIReplacements = 11, 
  DISPID_SPIEngineId = 12, 
  DISPID_SPIEnginePrivateData = 13, 
  DISPID_SPISaveToMemory = 14, 
  DISPID_SPIGetText = 15, 
  DISPID_SPIGetDisplayAttributes = 16
};

enum class DISPID_SpeechPhraseElement
{
  DISPID_SPEAudioTimeOffset = 1, 
  DISPID_SPEAudioSizeTime = 2, 
  DISPID_SPEAudioStreamOffset = 3, 
  DISPID_SPEAudioSizeBytes = 4, 
  DISPID_SPERetainedStreamOffset = 5, 
  DISPID_SPERetainedSizeBytes = 6, 
  DISPID_SPEDisplayText = 7, 
  DISPID_SPELexicalForm = 8, 
  DISPID_SPEPronunciation = 9, 
  DISPID_SPEDisplayAttributes = 10, 
  DISPID_SPERequiredConfidence = 11, 
  DISPID_SPEActualConfidence = 12, 
  DISPID_SPEEngineConfidence = 13
};

enum class DISPID_SpeechPhraseElements
{
  DISPID_SPEsCount = 1, 
  DISPID_SPEsItem = 0, 
  DISPID_SPEs_NewEnum = (int)-4 //0xFFFFFFFC
};

enum class DISPID_SpeechPhraseReplacement
{
  DISPID_SPRDisplayAttributes = 1, 
  DISPID_SPRText = 2, 
  DISPID_SPRFirstElement = 3, 
  DISPID_SPRNumberOfElements = 4
};

enum class DISPID_SpeechPhraseReplacements
{
  DISPID_SPRsCount = 1, 
  DISPID_SPRsItem = 0, 
  DISPID_SPRs_NewEnum = (int)-4 //0xFFFFFFFC
};

enum class DISPID_SpeechPhraseProperty
{
  DISPID_SPPName = 1, 
  DISPID_SPPId = 2, 
  DISPID_SPPValue = 3, 
  DISPID_SPPFirstElement = 4, 
  DISPID_SPPNumberOfElements = 5, 
  DISPID_SPPEngineConfidence = 6, 
  DISPID_SPPConfidence = 7, 
  DISPID_SPPParent = 8, 
  DISPID_SPPChildren = 9
};

enum class DISPID_SpeechPhraseProperties
{
  DISPID_SPPsCount = 1, 
  DISPID_SPPsItem = 0, 
  DISPID_SPPs_NewEnum = (int)-4 //0xFFFFFFFC
};

enum class DISPID_SpeechPhraseRule
{
  DISPID_SPRuleName = 1, 
  DISPID_SPRuleId = 2, 
  DISPID_SPRuleFirstElement = 3, 
  DISPID_SPRuleNumberOfElements = 4, 
  DISPID_SPRuleParent = 5, 
  DISPID_SPRuleChildren = 6, 
  DISPID_SPRuleConfidence = 7, 
  DISPID_SPRuleEngineConfidence = 8
};

enum class DISPID_SpeechPhraseRules
{
  DISPID_SPRulesCount = 1, 
  DISPID_SPRulesItem = 0, 
  DISPID_SPRules_NewEnum = (int)-4 //0xFFFFFFFC
};

enum class DISPID_SpeechLexicon
{
  DISPID_SLGenerationId = 1, 
  DISPID_SLGetWords = 2, 
  DISPID_SLAddPronunciation = 3, 
  DISPID_SLAddPronunciationByPhoneIds = 4, 
  DISPID_SLRemovePronunciation = 5, 
  DISPID_SLRemovePronunciationByPhoneIds = 6, 
  DISPID_SLGetPronunciations = 7, 
  DISPID_SLGetGenerationChange = 8
};

enum class DISPID_SpeechLexiconWords
{
  DISPID_SLWsCount = 1, 
  DISPID_SLWsItem = 0, 
  DISPID_SLWs_NewEnum = (int)-4 //0xFFFFFFFC
};

enum class DISPID_SpeechLexiconWord
{
  DISPID_SLWLangId = 1, 
  DISPID_SLWType = 2, 
  DISPID_SLWWord = 3, 
  DISPID_SLWPronunciations = 4
};

enum class DISPID_SpeechLexiconProns
{
  DISPID_SLPsCount = 1, 
  DISPID_SLPsItem = 0, 
  DISPID_SLPs_NewEnum = (int)-4 //0xFFFFFFFC
};

enum class DISPID_SpeechLexiconPronunciation
{
  DISPID_SLPType = 1, 
  DISPID_SLPLangId = 2, 
  DISPID_SLPPartOfSpeech = 3, 
  DISPID_SLPPhoneIds = 4, 
  DISPID_SLPSymbolic = 5
};

enum class DISPID_SpeechPhoneConverter
{
  DISPID_SPCLangId = 1, 
  DISPID_SPCPhoneToId = 2, 
  DISPID_SPCIdToPhone = 3
};

enum class SPDATAKEYLOCATION
{
  SPDKL_DefaultLocation = 0, 
  SPDKL_CurrentUser = 1, 
  SPDKL_LocalMachine = 2, 
  SPDKL_CurrentConfig = 5
};

enum class _SPAUDIOSTATE
{
  SPAS_CLOSED = 0, 
  SPAS_STOP = 1, 
  SPAS_PAUSE = 2, 
  SPAS_RUN = 3
};

enum class SPFILEMODE
{
  SPFM_OPEN_READONLY = 0, 
  SPFM_OPEN_READWRITE = 1, 
  SPFM_CREATE = 2, 
  SPFM_CREATE_ALWAYS = 3, 
  SPFM_NUM_MODES = 4
};

enum class SPVISEMES
{
  SP_VISEME_0 = 0, 
  SP_VISEME_1 = 1, 
  SP_VISEME_2 = 2, 
  SP_VISEME_3 = 3, 
  SP_VISEME_4 = 4, 
  SP_VISEME_5 = 5, 
  SP_VISEME_6 = 6, 
  SP_VISEME_7 = 7, 
  SP_VISEME_8 = 8, 
  SP_VISEME_9 = 9, 
  SP_VISEME_10 = 10, 
  SP_VISEME_11 = 11, 
  SP_VISEME_12 = 12, 
  SP_VISEME_13 = 13, 
  SP_VISEME_14 = 14, 
  SP_VISEME_15 = 15, 
  SP_VISEME_16 = 16, 
  SP_VISEME_17 = 17, 
  SP_VISEME_18 = 18, 
  SP_VISEME_19 = 19, 
  SP_VISEME_20 = 20, 
  SP_VISEME_21 = 21
};

enum class SPVPRIORITY
{
  SPVPRI_NORMAL = 0, 
  SPVPRI_ALERT = 1, 
  SPVPRI_OVER = 2
};

enum class SPEVENTENUM
{
  SPEI_UNDEFINED = 0, 
  SPEI_START_INPUT_STREAM = 1, 
  SPEI_END_INPUT_STREAM = 2, 
  SPEI_VOICE_CHANGE = 3, 
  SPEI_TTS_BOOKMARK = 4, 
  SPEI_WORD_BOUNDARY = 5, 
  SPEI_PHONEME = 6, 
  SPEI_SENTENCE_BOUNDARY = 7, 
  SPEI_VISEME = 8, 
  SPEI_TTS_AUDIO_LEVEL = 9, 
  SPEI_TTS_PRIVATE = 15, 
  SPEI_MIN_TTS = 1, 
  SPEI_MAX_TTS = 15, 
  SPEI_END_SR_STREAM = 34, 
  SPEI_SOUND_START = 35, 
  SPEI_SOUND_END = 36, 
  SPEI_PHRASE_START = 37, 
  SPEI_RECOGNITION = 38, 
  SPEI_HYPOTHESIS = 39, 
  SPEI_SR_BOOKMARK = 40, 
  SPEI_PROPERTY_NUM_CHANGE = 41, 
  SPEI_PROPERTY_STRING_CHANGE = 42, 
  SPEI_FALSE_RECOGNITION = 43, 
  SPEI_INTERFERENCE = 44, 
  SPEI_REQUEST_UI = 45, 
  SPEI_RECO_STATE_CHANGE = 46, 
  SPEI_ADAPTATION = 47, 
  SPEI_START_SR_STREAM = 48, 
  SPEI_RECO_OTHER_CONTEXT = 49, 
  SPEI_SR_AUDIO_LEVEL = 50, 
  SPEI_SR_RETAINEDAUDIO = 51, 
  SPEI_SR_PRIVATE = 52, 
  SPEI_ACTIVE_CATEGORY_CHANGED = 53, 
  SPEI_RESERVED5 = 54, 
  SPEI_RESERVED6 = 55, 
  SPEI_MIN_SR = 34, 
  SPEI_MAX_SR = 55, 
  SPEI_RESERVED1 = 30, 
  SPEI_RESERVED2 = 33, 
  SPEI_RESERVED3 = 63
};

enum class SPRECOSTATE
{
  SPRST_INACTIVE = 0, 
  SPRST_ACTIVE = 1, 
  SPRST_ACTIVE_ALWAYS = 2, 
  SPRST_INACTIVE_WITH_PURGE = 3, 
  SPRST_NUM_STATES = 4
};

enum class SPWAVEFORMATTYPE
{
  SPWF_INPUT = 0, 
  SPWF_SRENGINE = 1
};

enum class SPSEMANTICFORMAT
{
  SPSMF_SAPI_PROPERTIES = 0, 
  SPSMF_SRGS_SEMANTICINTERPRETATION_MS = 1, 
  SPSMF_SRGS_SAPIPROPERTIES = 2, 
  SPSMF_UPS = 4, 
  SPSMF_SRGS_SEMANTICINTERPRETATION_W3C = 8
};

enum class SPGRAMMARWORDTYPE
{
  SPWT_DISPLAY = 0, 
  SPWT_LEXICAL = 1, 
  SPWT_PRONUNCIATION = 2, 
  SPWT_LEXICAL_NO_SPECIAL_CHARS = 3
};

enum class SPLOADOPTIONS
{
  SPLO_STATIC = 0, 
  SPLO_DYNAMIC = 1
};

enum class SPRULESTATE
{
  SPRS_INACTIVE = 0, 
  SPRS_ACTIVE = 1, 
  SPRS_ACTIVE_WITH_AUTO_PAUSE = 3, 
  SPRS_ACTIVE_USER_DELIMITED = 4
};

enum class SPWORDPRONOUNCEABLE
{
  SPWP_UNKNOWN_WORD_UNPRONOUNCEABLE = 0, 
  SPWP_UNKNOWN_WORD_PRONOUNCEABLE = 1, 
  SPWP_KNOWN_WORD_PRONOUNCEABLE = 2
};

enum class SPGRAMMARSTATE
{
  SPGS_DISABLED = 0, 
  SPGS_ENABLED = 1, 
  SPGS_EXCLUSIVE = 3
};

enum class SPINTERFERENCE
{
  SPINTERFERENCE_NONE = 0, 
  SPINTERFERENCE_NOISE = 1, 
  SPINTERFERENCE_NOSIGNAL = 2, 
  SPINTERFERENCE_TOOLOUD = 3, 
  SPINTERFERENCE_TOOQUIET = 4, 
  SPINTERFERENCE_TOOFAST = 5, 
  SPINTERFERENCE_TOOSLOW = 6, 
  SPINTERFERENCE_LATENCY_WARNING = 7, 
  SPINTERFERENCE_LATENCY_TRUNCATE_BEGIN = 8, 
  SPINTERFERENCE_LATENCY_TRUNCATE_END = 9
};

enum class SPAUDIOOPTIONS
{
  SPAO_NONE = 0, 
  SPAO_RETAIN_AUDIO = 1
};

enum class SPBOOKMARKOPTIONS
{
  SPBO_NONE = 0, 
  SPBO_PAUSE = 1, 
  SPBO_AHEAD = 2, 
  SPBO_TIME_UNITS = 4
};

enum class SPCONTEXTSTATE
{
  SPCS_DISABLED = 0, 
  SPCS_ENABLED = 1
};

enum class SPADAPTATIONRELEVANCE
{
  SPAR_Unknown = 0, 
  SPAR_Low = 1, 
  SPAR_Medium = 2, 
  SPAR_High = 3
};

enum class SPCATEGORYTYPE
{
  SPCT_COMMAND = 0, 
  SPCT_DICTATION = 1, 
  SPCT_SLEEP = 2, 
  SPCT_SUB_COMMAND = 3, 
  SPCT_SUB_DICTATION = 4
};

enum class SPLEXICONTYPE
{
  eLEXTYPE_USER = 1, 
  eLEXTYPE_APP = 2, 
  eLEXTYPE_VENDORLEXICON = 4, 
  eLEXTYPE_LETTERTOSOUND = 8, 
  eLEXTYPE_MORPHOLOGY = 16, 
  eLEXTYPE_RESERVED4 = 32, 
  eLEXTYPE_USER_SHORTCUT = 64, 
  eLEXTYPE_RESERVED6 = 128, 
  eLEXTYPE_RESERVED7 = 256, 
  eLEXTYPE_RESERVED8 = 512, 
  eLEXTYPE_RESERVED9 = 1024, 
  eLEXTYPE_RESERVED10 = 2048, 
  eLEXTYPE_PRIVATE1 = 4096, 
  eLEXTYPE_PRIVATE2 = 8192, 
  eLEXTYPE_PRIVATE3 = 16384, 
  eLEXTYPE_PRIVATE4 = 32768, 
  eLEXTYPE_PRIVATE5 = 65536, 
  eLEXTYPE_PRIVATE6 = 131072, 
  eLEXTYPE_PRIVATE7 = 262144, 
  eLEXTYPE_PRIVATE8 = 524288, 
  eLEXTYPE_PRIVATE9 = 1048576, 
  eLEXTYPE_PRIVATE10 = 2097152, 
  eLEXTYPE_PRIVATE11 = 4194304, 
  eLEXTYPE_PRIVATE12 = 8388608, 
  eLEXTYPE_PRIVATE13 = 16777216, 
  eLEXTYPE_PRIVATE14 = 33554432, 
  eLEXTYPE_PRIVATE15 = 67108864, 
  eLEXTYPE_PRIVATE16 = 134217728, 
  eLEXTYPE_PRIVATE17 = 268435456, 
  eLEXTYPE_PRIVATE18 = 536870912, 
  eLEXTYPE_PRIVATE19 = 1073741824, 
  eLEXTYPE_PRIVATE20 = (int)-2147483648 //0x80000000
};

enum class SPPARTOFSPEECH
{
  SPPS_NotOverriden = (int)-1,  //0xFFFFFFFF
  SPPS_Unknown = 0, 
  SPPS_Noun = 4096, 
  SPPS_Verb = 8192, 
  SPPS_Modifier = 12288, 
  SPPS_Function = 16384, 
  SPPS_Interjection = 20480, 
  SPPS_Noncontent = 24576, 
  SPPS_LMA = 28672, 
  SPPS_SuppressWord = 61440
};

enum class SPWORDTYPE
{
  eWORDTYPE_ADDED = 1, 
  eWORDTYPE_DELETED = 2
};

enum class SPSHORTCUTTYPE
{
  SPSHT_NotOverriden = (int)-1,  //0xFFFFFFFF
  SPSHT_Unknown = 0, 
  SPSHT_EMAIL = 4096, 
  SPSHT_OTHER = 8192, 
  SPPS_RESERVED1 = 12288, 
  SPPS_RESERVED2 = 16384, 
  SPPS_RESERVED3 = 20480, 
  SPPS_RESERVED4 = 61440
};


// *********************************************************************//
// Declaration of Structures and Unions defined in Type Library           
// *********************************************************************//
union  __MIDL_IWinTypes_0009
{
  long hInproc;
  long hRemote;
};

struct _RemotableHandle
{
  long fContext;
  Speechlib_tlb::__MIDL_IWinTypes_0009 u;
};

#pragma pack(push, 8)
struct _LARGE_INTEGER
{
  __int64 QuadPart;
};
#pragma pack(pop)

#pragma pack(push, 8)
struct _ULARGE_INTEGER
{
  unsigned_int64 QuadPart;
};
#pragma pack(pop)

struct _FILETIME
{
  unsigned_long dwLowDateTime;
  unsigned_long dwHighDateTime;
};

#pragma pack(push, 8)
struct tagSTATSTG
{
  LPWSTR pwcsName;
  unsigned_long Type;
  Speechlib_tlb::_ULARGE_INTEGER cbSize;
  Speechlib_tlb::_FILETIME mtime;
  Speechlib_tlb::_FILETIME ctime;
  Speechlib_tlb::_FILETIME atime;
  unsigned_long grfMode;
  unsigned_long grfLocksSupported;
  System::TGUID clsid;
  unsigned_long grfStateBits;
  unsigned_long reserved;
};
#pragma pack(pop)

struct WAVEFORMATEX
{
  unsigned_short wFormatTag;
  unsigned_short nChannels;
  unsigned_long nSamplesPerSec;
  unsigned_long nAvgBytesPerSec;
  unsigned_short nBlockAlign;
  unsigned_short wBitsPerSample;
  unsigned_short cbSize;
};

#pragma pack(push, 8)
struct SPEVENT
{
  unsigned_short eEventId;
  unsigned_short elParamType;
  unsigned_long ulStreamNum;
  unsigned_int64 ullAudioStreamOffset;
  Speechlib_tlb::UINT_PTR wParam;
  Speechlib_tlb::LONG_PTR lParam;
};
#pragma pack(pop)

#pragma pack(push, 8)
struct SPEVENTSOURCEINFO
{
  unsigned_int64 ullEventInterest;
  unsigned_int64 ullQueuedInterest;
  unsigned_long ulCount;
};
#pragma pack(pop)

#pragma pack(push, 8)
struct SPAUDIOSTATUS
{
  long cbFreeBuffSpace;
  unsigned_long cbNonBlockingIO;
  Speechlib_tlb::SPAUDIOSTATE State;
  unsigned_int64 CurSeekPos;
  unsigned_int64 CurDevicePos;
  unsigned_long dwAudioLevel;
  unsigned_long dwReserved2;
};
#pragma pack(pop)

struct SPAUDIOBUFFERINFO
{
  unsigned_long ulMsMinNotification;
  unsigned_long ulMsBufferSize;
  unsigned_long ulMsEventBias;
};

struct SPVOICESTATUS
{
  unsigned_long ulCurrentStream;
  unsigned_long ulLastStreamQueued;
  HRESULT hrLastResult;
  unsigned_long dwRunningState;
  unsigned_long ulInputWordPos;
  unsigned_long ulInputWordLen;
  unsigned_long ulInputSentPos;
  unsigned_long ulInputSentLen;
  long lBookmarkId;
  unsigned_short PhonemeId;
  Speechlib_tlb::SPVISEMES VisemeId;
  unsigned_long dwReserved1;
  unsigned_long dwReserved2;
};

#pragma pack(push, 8)
struct SPRECOGNIZERSTATUS
{
  Speechlib_tlb::SPAUDIOSTATUS AudioStatus;
  unsigned_int64 ullRecognitionStreamPos;
  unsigned_long ulStreamNumber;
  unsigned_long ulNumActive;
  System::TGUID ClsidEngine;
  unsigned_long cLangIDs;
  unsigned_short aLangID[20];
  unsigned_int64 ullRecognitionStreamTime;
};
#pragma pack(pop)

struct SPPHRASERULE
{
  LPWSTR pszName;
  unsigned_long ulId;
  unsigned_long ulFirstElement;
  unsigned_long ulCountOfElements;
  Speechlib_tlb::SPPHRASERULE* pNextSibling;
  Speechlib_tlb::SPPHRASERULE* pFirstChild;
  float SREngineConfidence;
  signed_char Confidence;
};

#pragma pack(push, 2)
struct __MIDL___MIDL_itf_sapi_0000_0020_0002
{
  unsigned_char bType;
  unsigned_char bReserved;
  unsigned_short usArrayIndex;
};
#pragma pack(pop)

union  __MIDL___MIDL_itf_sapi_0000_0020_0001
{
  unsigned_long ulId;
  Speechlib_tlb::__MIDL___MIDL_itf_sapi_0000_0020_0002 __MIDL____MIDL_itf_sapi_0000_00200000;
};

#pragma pack(push, 8)
struct SPPHRASEPROPERTY
{
  LPWSTR pszName;
  Speechlib_tlb::__MIDL___MIDL_itf_sapi_0000_0020_0001 __MIDL____MIDL_itf_sapi_0000_00200001;
  LPWSTR pszValue;
  VARIANT vValue;
  unsigned_long ulFirstElement;
  unsigned_long ulCountOfElements;
  Speechlib_tlb::SPPHRASEPROPERTY* pNextSibling;
  Speechlib_tlb::SPPHRASEPROPERTY* pFirstChild;
  float SREngineConfidence;
  signed_char Confidence;
};
#pragma pack(pop)

struct SPPHRASEELEMENT
{
  unsigned_long ulAudioTimeOffset;
  unsigned_long ulAudioSizeTime;
  unsigned_long ulAudioStreamOffset;
  unsigned_long ulAudioSizeBytes;
  unsigned_long ulRetainedStreamOffset;
  unsigned_long ulRetainedSizeBytes;
  LPWSTR pszDisplayText;
  LPWSTR pszLexicalForm;
  unsigned_short* pszPronunciation;
  unsigned_char bDisplayAttributes;
  signed_char RequiredConfidence;
  signed_char ActualConfidence;
  unsigned_char reserved;
  float SREngineConfidence;
};

struct SPPHRASEREPLACEMENT
{
  unsigned_char bDisplayAttributes;
  LPWSTR pszReplacementText;
  unsigned_long ulFirstElement;
  unsigned_long ulCountOfElements;
};

struct SPSEMANTICERRORINFO
{
  unsigned_long ulLineNumber;
  LPWSTR pszScriptLine;
  LPWSTR pszSource;
  LPWSTR pszDescription;
  HRESULT hrResultCode;
};

#pragma pack(push, 8)
struct SPPHRASE
{
  unsigned_long cbSize;
  unsigned_short LangId;
  unsigned_short wHomophoneGroupId;
  unsigned_int64 ullGrammarID;
  unsigned_int64 ftStartTime;
  unsigned_int64 ullAudioStreamPosition;
  unsigned_long ulAudioSizeBytes;
  unsigned_long ulRetainedSizeBytes;
  unsigned_long ulAudioSizeTime;
  Speechlib_tlb::SPPHRASERULE Rule;
  Speechlib_tlb::SPPHRASEPROPERTY* pProperties;
  Speechlib_tlb::SPPHRASEELEMENT* pElements;
  unsigned_long cReplacements;
  Speechlib_tlb::SPPHRASEREPLACEMENT* pReplacements;
  System::TGUID SREngineID;
  unsigned_long ulSREnginePrivateDataSize;
  unsigned_char* pSREnginePrivateData;
  LPWSTR pSML;
  Speechlib_tlb::SPSEMANTICERRORINFO* pSemanticErrorInfo;
  Speechlib_tlb::SPSEMANTICFORMAT SemanticTagFormat;
};
#pragma pack(pop)

struct SPSERIALIZEDPHRASE
{
  unsigned_long ulSerializedSize;
};

#pragma pack(push, 8)
struct tagSPPROPERTYINFO
{
  LPWSTR pszName;
  unsigned_long ulId;
  LPWSTR pszValue;
  VARIANT vValue;
};
#pragma pack(pop)

struct SPBINARYGRAMMAR
{
  unsigned_long ulTotalSerializedSize;
};

struct tagSPTEXTSELECTIONINFO
{
  unsigned_long ulStartActiveOffset;
  unsigned_long cchActiveChars;
  unsigned_long ulStartSelection;
  unsigned_long cchSelection;
};

struct SPRECOCONTEXTSTATUS
{
  Speechlib_tlb::SPINTERFERENCE eInterference;
  unsigned_short szRequestTypeOfUI[255];
  unsigned_long dwReserved1;
  unsigned_long dwReserved2;
};

struct SPSERIALIZEDRESULT
{
  unsigned_long ulSerializedSize;
};

#pragma pack(push, 8)
struct SPRECORESULTTIMES
{
  Speechlib_tlb::_FILETIME ftStreamTime;
  unsigned_int64 ullLength;
  unsigned_long dwTickCount;
  unsigned_int64 ullStart;
};
#pragma pack(pop)

struct SPWORDPRONUNCIATION
{
  Speechlib_tlb::SPWORDPRONUNCIATION* pNextWordPronunciation;
  Speechlib_tlb::SPLEXICONTYPE eLexiconType;
  unsigned_short LangId;
  unsigned_short wPronunciationFlags;
  Speechlib_tlb::SPPARTOFSPEECH ePartOfSpeech;
  unsigned_short szPronunciation[1];
};

struct SPWORDPRONUNCIATIONLIST
{
  unsigned_long ulSize;
  unsigned_char* pvBuffer;
  Speechlib_tlb::SPWORDPRONUNCIATION* pFirstWordPronunciation;
};

struct SPWORD
{
  Speechlib_tlb::SPWORD* pNextWord;
  unsigned_short LangId;
  unsigned_short wReserved;
  Speechlib_tlb::SPWORDTYPE eWordType;
  LPWSTR pszWord;
  Speechlib_tlb::SPWORDPRONUNCIATION* pFirstWordPronunciation;
};

struct SPWORDLIST
{
  unsigned_long ulSize;
  unsigned_char* pvBuffer;
  Speechlib_tlb::SPWORD* pFirstWord;
};

struct SPSHORTCUTPAIR
{
  Speechlib_tlb::SPSHORTCUTPAIR* pNextSHORTCUTPAIR;
  unsigned_short LangId;
  Speechlib_tlb::SPSHORTCUTTYPE shType;
  LPWSTR pszDisplay;
  LPWSTR pszSpoken;
};

struct SPSHORTCUTPAIRLIST
{
  unsigned_long ulSize;
  unsigned_char* pvBuffer;
  Speechlib_tlb::SPSHORTCUTPAIR* pFirstShortcutPair;
};

struct SPRULE
{
  LPWSTR pszRuleName;
  unsigned_long ulRuleId;
  unsigned_long dwAttributes;
};

// *********************************************************************//
// Interface: ISpeechDataKey
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {CE17C09B-4EFA-44D5-A4C9-59D9585AB0CD}
// *********************************************************************//
interface ISpeechDataKey  : public IDispatch
{
public:
  // [1] SetBinaryValue
  virtual HRESULT STDMETHODCALLTYPE SetBinaryValue(BSTR ValueName/*[in]*/, VARIANT Value/*[in]*/) = 0;
  // [2] GetBinaryValue
  virtual HRESULT STDMETHODCALLTYPE GetBinaryValue(BSTR ValueName/*[in]*/, 
                                                   VARIANT* Value/*[out,retval]*/) = 0;
  // [3] SetStringValue
  virtual HRESULT STDMETHODCALLTYPE SetStringValue(BSTR ValueName/*[in]*/, BSTR Value/*[in]*/) = 0;
  // [4] GetStringValue
  virtual HRESULT STDMETHODCALLTYPE GetStringValue(BSTR ValueName/*[in]*/, 
                                                   BSTR* Value/*[out,retval]*/) = 0;
  // [5] SetLongValue
  virtual HRESULT STDMETHODCALLTYPE SetLongValue(BSTR ValueName/*[in]*/, long Value/*[in]*/) = 0;
  // [6] GetlongValue
  virtual HRESULT STDMETHODCALLTYPE GetLongValue(BSTR ValueName/*[in]*/, long* Value/*[out,retval]*/) = 0;
  // [7] OpenKey
  virtual HRESULT STDMETHODCALLTYPE OpenKey(BSTR SubKeyName/*[in]*/, 
                                            Speechlib_tlb::ISpeechDataKey** SubKey/*[out,retval]*/) = 0;
  // [8] CreateKey
  virtual HRESULT STDMETHODCALLTYPE CreateKey(BSTR SubKeyName/*[in]*/, 
                                              Speechlib_tlb::ISpeechDataKey** SubKey/*[out,retval]*/) = 0;
  // [9] DeleteKey
  virtual HRESULT STDMETHODCALLTYPE DeleteKey(BSTR SubKeyName/*[in]*/) = 0;
  // [10] DeleteValue
  virtual HRESULT STDMETHODCALLTYPE DeleteValue(BSTR ValueName/*[in]*/) = 0;
  // [11] EnumKeys
  virtual HRESULT STDMETHODCALLTYPE EnumKeys(long Index/*[in]*/, BSTR* SubKeyName/*[out,retval]*/) = 0;
  // [12] EnumValues
  virtual HRESULT STDMETHODCALLTYPE EnumValues(long Index/*[in]*/, BSTR* ValueName/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  VARIANT __fastcall GetBinaryValue(BSTR ValueName/*[in]*/)
  {
    VARIANT Value;
    OLECHECK(this->GetBinaryValue(ValueName, (VARIANT*)&Value));
    return Value;
  }

  BSTR __fastcall GetStringValue(BSTR ValueName/*[in]*/)
  {
    BSTR Value = 0;
    OLECHECK(this->GetStringValue(ValueName, (BSTR*)&Value));
    return Value;
  }

  long __fastcall GetLongValue(BSTR ValueName/*[in]*/)
  {
    long Value;
    OLECHECK(this->GetLongValue(ValueName, (long*)&Value));
    return Value;
  }

  Speechlib_tlb::ISpeechDataKey* __fastcall OpenKey(BSTR SubKeyName/*[in]*/)
  {
    Speechlib_tlb::ISpeechDataKey* SubKey = 0;
    OLECHECK(this->OpenKey(SubKeyName, (Speechlib_tlb::ISpeechDataKey**)&SubKey));
    return SubKey;
  }

  Speechlib_tlb::ISpeechDataKey* __fastcall CreateKey(BSTR SubKeyName/*[in]*/)
  {
    Speechlib_tlb::ISpeechDataKey* SubKey = 0;
    OLECHECK(this->CreateKey(SubKeyName, (Speechlib_tlb::ISpeechDataKey**)&SubKey));
    return SubKey;
  }

  BSTR __fastcall EnumKeys(long Index/*[in]*/)
  {
    BSTR SubKeyName = 0;
    OLECHECK(this->EnumKeys(Index, (BSTR*)&SubKeyName));
    return SubKeyName;
  }

  BSTR __fastcall EnumValues(long Index/*[in]*/)
  {
    BSTR ValueName = 0;
    OLECHECK(this->EnumValues(Index, (BSTR*)&ValueName));
    return ValueName;
  }



#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechObjectToken
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {C74A3ADC-B727-4500-A84A-B526721C8B8C}
// *********************************************************************//
interface ISpeechObjectToken  : public IDispatch
{
public:
  // [1] Id
  virtual HRESULT STDMETHODCALLTYPE get_Id(BSTR* ObjectId/*[out,retval]*/) = 0;
  // [2] DataKey
  virtual HRESULT STDMETHODCALLTYPE get_DataKey(Speechlib_tlb::ISpeechDataKey** DataKey/*[out,retval]*/) = 0;
  // [3] Category
  virtual HRESULT STDMETHODCALLTYPE get_Category(Speechlib_tlb::ISpeechObjectTokenCategory** Category/*[out,retval]*/) = 0;
  // [4] GetDescription
  virtual HRESULT STDMETHODCALLTYPE GetDescription(long Locale/*[in,def,opt]*/, 
                                                   BSTR* Description/*[out,retval]*/) = 0;
  // [5] SetId
  virtual HRESULT STDMETHODCALLTYPE SetId(BSTR Id/*[in]*/, BSTR CategoryID/*[in,def,opt]*/, 
                                          VARIANT_BOOL CreateIfNotExist/*[in,def,opt]*/) = 0;
  // [6] GetAttribute
  virtual HRESULT STDMETHODCALLTYPE GetAttribute(BSTR AttributeName/*[in]*/, 
                                                 BSTR* AttributeValue/*[out,retval]*/) = 0;
  // [7] CreateInstance
  virtual HRESULT STDMETHODCALLTYPE CreateInstance(LPUNKNOWN pUnkOuter/*[in,def,opt]*/, 
                                                   Speechlib_tlb::SpeechTokenContext ClsContext/*[in,def,opt]*/, 
                                                   LPUNKNOWN* Object/*[out,retval]*/) = 0;
  // [8] Remove
  virtual HRESULT STDMETHODCALLTYPE Remove(BSTR ObjectStorageCLSID/*[in]*/) = 0;
  // [9] GetStorageFileName
  virtual HRESULT STDMETHODCALLTYPE GetStorageFileName(BSTR ObjectStorageCLSID/*[in]*/, 
                                                       BSTR KeyName/*[in]*/, BSTR FileName/*[in]*/, 
                                                       Speechlib_tlb::SpeechTokenShellFolder Folder/*[in]*/, 
                                                       BSTR* FilePath/*[out,retval]*/) = 0;
  // [10] RemoveStorageFileName
  virtual HRESULT STDMETHODCALLTYPE RemoveStorageFileName(BSTR ObjectStorageCLSID/*[in]*/, 
                                                          BSTR KeyName/*[in]*/, 
                                                          VARIANT_BOOL DeleteFile/*[in]*/) = 0;
  // [11] IsUISupported
  virtual HRESULT STDMETHODCALLTYPE IsUISupported(BSTR TypeOfUI/*[in]*/, 
                                                  VARIANT* ExtraData/*[in,def,opt]*/, 
                                                  LPUNKNOWN Object/*[in,def,opt]*/, 
                                                  VARIANT_BOOL* Supported/*[out,retval]*/) = 0;
  // [12] DisplayUI
  virtual HRESULT STDMETHODCALLTYPE DisplayUI(long hWnd/*[in]*/, BSTR Title/*[in]*/, 
                                              BSTR TypeOfUI/*[in]*/, 
                                              VARIANT* ExtraData/*[in,def,opt]*/, 
                                              LPUNKNOWN Object/*[in,def,opt]*/) = 0;
  // [13] MatchesAttributes
  virtual HRESULT STDMETHODCALLTYPE MatchesAttributes(BSTR Attributes/*[in]*/, 
                                                      VARIANT_BOOL* Matches/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  BSTR __fastcall get_Id(void)
  {
    BSTR ObjectId = 0;
    OLECHECK(this->get_Id((BSTR*)&ObjectId));
    return ObjectId;
  }

  Speechlib_tlb::ISpeechDataKeyPtr __fastcall get_DataKey(void)
  {
    Speechlib_tlb::ISpeechDataKeyPtr DataKey;
    OLECHECK(this->get_DataKey(&DataKey));
    return DataKey;
  }

  Speechlib_tlb::ISpeechObjectTokenCategoryPtr __fastcall get_Category(void)
  {
    Speechlib_tlb::ISpeechObjectTokenCategoryPtr Category;
    OLECHECK(this->get_Category(&Category));
    return Category;
  }

  BSTR __fastcall GetDescription(long Locale/*[in,def,opt]*/)
  {
    BSTR Description = 0;
    OLECHECK(this->GetDescription(Locale, (BSTR*)&Description));
    return Description;
  }

  BSTR __fastcall GetAttribute(BSTR AttributeName/*[in]*/)
  {
    BSTR AttributeValue = 0;
    OLECHECK(this->GetAttribute(AttributeName, (BSTR*)&AttributeValue));
    return AttributeValue;
  }

  LPUNKNOWN __fastcall CreateInstance(LPUNKNOWN pUnkOuter/*[in,def,opt]*/, 
                                      Speechlib_tlb::SpeechTokenContext ClsContext/*[in,def,opt]*/)
  {
    LPUNKNOWN Object;
    OLECHECK(this->CreateInstance(pUnkOuter, ClsContext, (LPUNKNOWN*)&Object));
    return Object;
  }

  BSTR __fastcall GetStorageFileName(BSTR ObjectStorageCLSID/*[in]*/, BSTR KeyName/*[in]*/, 
                                     BSTR FileName/*[in]*/, 
                                     Speechlib_tlb::SpeechTokenShellFolder Folder/*[in]*/)
  {
    BSTR FilePath = 0;
    OLECHECK(this->GetStorageFileName(ObjectStorageCLSID, KeyName, FileName, Folder, (BSTR*)&FilePath));
    return FilePath;
  }

  VARIANT_BOOL __fastcall IsUISupported(BSTR TypeOfUI/*[in]*/, VARIANT* ExtraData/*[in,def,opt]*/, 
                                        LPUNKNOWN Object/*[in,def,opt]*/)
  {
    VARIANT_BOOL Supported;
    OLECHECK(this->IsUISupported(TypeOfUI, ExtraData, Object, (VARIANT_BOOL*)&Supported));
    return Supported;
  }

  VARIANT_BOOL __fastcall MatchesAttributes(BSTR Attributes/*[in]*/)
  {
    VARIANT_BOOL Matches;
    OLECHECK(this->MatchesAttributes(Attributes, (VARIANT_BOOL*)&Matches));
    return Matches;
  }


  __property   BSTR            Id = {read = get_Id};
  __property   Speechlib_tlb::ISpeechDataKeyPtr DataKey = {read = get_DataKey};
  __property   Speechlib_tlb::ISpeechObjectTokenCategoryPtr Category = {read = get_Category};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechObjectTokenCategory
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {CA7EAC50-2D01-4145-86D4-5AE7D70F4469}
// *********************************************************************//
interface ISpeechObjectTokenCategory  : public IDispatch
{
public:
  // [1] Id
  virtual HRESULT STDMETHODCALLTYPE get_Id(BSTR* Id/*[out,retval]*/) = 0;
  // [2] Default
  virtual HRESULT STDMETHODCALLTYPE set_Default(BSTR TokenId/*[in]*/) = 0;
  // [2] Default
  virtual HRESULT STDMETHODCALLTYPE get_Default(BSTR* TokenId/*[out,retval]*/) = 0;
  // [3] SetId
  virtual HRESULT STDMETHODCALLTYPE SetId(BSTR Id/*[in]*/, 
                                          VARIANT_BOOL CreateIfNotExist/*[in,def,opt]*/) = 0;
  // [4] GetDataKey
  virtual HRESULT STDMETHODCALLTYPE GetDataKey(Speechlib_tlb::SpeechDataKeyLocation Location/*[in,def,opt]*/, 
                                               Speechlib_tlb::ISpeechDataKey** DataKey/*[out,retval]*/) = 0;
  // [5] EnumerateTokens
  virtual HRESULT STDMETHODCALLTYPE EnumerateTokens(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                    BSTR OptionalAttributes/*[in,def,opt]*/, 
                                                    Speechlib_tlb::ISpeechObjectTokens** Tokens/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  BSTR __fastcall get_Id(void)
  {
    BSTR Id = 0;
    OLECHECK(this->get_Id((BSTR*)&Id));
    return Id;
  }

  BSTR __fastcall get_Default(void)
  {
    BSTR TokenId = 0;
    OLECHECK(this->get_Default((BSTR*)&TokenId));
    return TokenId;
  }

  Speechlib_tlb::ISpeechDataKey* __fastcall GetDataKey(Speechlib_tlb::SpeechDataKeyLocation Location/*[in,def,opt]*/)
  {
    Speechlib_tlb::ISpeechDataKey* DataKey = 0;
    OLECHECK(this->GetDataKey(Location, (Speechlib_tlb::ISpeechDataKey**)&DataKey));
    return DataKey;
  }

  Speechlib_tlb::ISpeechObjectTokens* __fastcall EnumerateTokens(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                                 BSTR OptionalAttributes/*[in,def,opt]*/)
  {
    Speechlib_tlb::ISpeechObjectTokens* Tokens = 0;
    OLECHECK(this->EnumerateTokens(RequiredAttributes, OptionalAttributes, (Speechlib_tlb::ISpeechObjectTokens**)&Tokens));
    return Tokens;
  }


  __property   BSTR            Id = {read = get_Id};
  __property   BSTR            Default = {read = get_Default, write = set_Default};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechObjectTokens
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {9285B776-2E7B-4BC0-B53E-580EB6FA967F}
// *********************************************************************//
interface ISpeechObjectTokens  : public IDispatch
{
public:
  // [1] Count
  virtual HRESULT STDMETHODCALLTYPE get_Count(long* Count/*[out,retval]*/) = 0;
  // [0] Item
  virtual HRESULT STDMETHODCALLTYPE Item(long Index/*[in]*/, 
                                         Speechlib_tlb::ISpeechObjectToken** Token/*[out,retval]*/) = 0;
  // [-4] Enumerates the tokens
  virtual HRESULT STDMETHODCALLTYPE get__NewEnum(LPUNKNOWN* ppEnumVARIANT/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  long __fastcall get_Count(void)
  {
    long Count;
    OLECHECK(this->get_Count((long*)&Count));
    return Count;
  }

  Speechlib_tlb::ISpeechObjectToken* __fastcall Item(long Index/*[in]*/)
  {
    Speechlib_tlb::ISpeechObjectToken* Token = 0;
    OLECHECK(this->Item(Index, (Speechlib_tlb::ISpeechObjectToken**)&Token));
    return Token;
  }

  LPUNKNOWN __fastcall get__NewEnum(void)
  {
    LPUNKNOWN ppEnumVARIANT;
    OLECHECK(this->get__NewEnum((LPUNKNOWN*)&ppEnumVARIANT));
    return ppEnumVARIANT;
  }


  __property   long            Count = {read = get_Count};
  __property   LPUNKNOWN       _NewEnum = {read = get__NewEnum};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechAudioBufferInfo
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {11B103D8-1142-4EDF-A093-82FB3915F8CC}
// *********************************************************************//
interface ISpeechAudioBufferInfo  : public IDispatch
{
public:
  // [1] MinNotification
  virtual HRESULT STDMETHODCALLTYPE get_MinNotification(long* MinNotification/*[out,retval]*/) = 0;
  // [1] MinNotification
  virtual HRESULT STDMETHODCALLTYPE set_MinNotification(long MinNotification/*[in]*/) = 0;
  // [2] BufferSize
  virtual HRESULT STDMETHODCALLTYPE get_BufferSize(long* BufferSize/*[out,retval]*/) = 0;
  // [2] BufferSize
  virtual HRESULT STDMETHODCALLTYPE set_BufferSize(long BufferSize/*[in]*/) = 0;
  // [3] EventBias
  virtual HRESULT STDMETHODCALLTYPE get_EventBias(long* EventBias/*[out,retval]*/) = 0;
  // [3] EventBias
  virtual HRESULT STDMETHODCALLTYPE set_EventBias(long EventBias/*[in]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  long __fastcall get_MinNotification(void)
  {
    long MinNotification;
    OLECHECK(this->get_MinNotification((long*)&MinNotification));
    return MinNotification;
  }

  long __fastcall get_BufferSize(void)
  {
    long BufferSize;
    OLECHECK(this->get_BufferSize((long*)&BufferSize));
    return BufferSize;
  }

  long __fastcall get_EventBias(void)
  {
    long EventBias;
    OLECHECK(this->get_EventBias((long*)&EventBias));
    return EventBias;
  }


  __property   long            MinNotification = {read = get_MinNotification, write = set_MinNotification};
  __property   long            BufferSize = {read = get_BufferSize, write = set_BufferSize};
  __property   long            EventBias = {read = get_EventBias, write = set_EventBias};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechAudioStatus
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {C62D9C91-7458-47F6-862D-1EF86FB0B278}
// *********************************************************************//
interface ISpeechAudioStatus  : public IDispatch
{
public:
  // [1] FreeBufferSpace
  virtual HRESULT STDMETHODCALLTYPE get_FreeBufferSpace(long* FreeBufferSpace/*[out,retval]*/) = 0;
  // [2] NonBlockingIO
  virtual HRESULT STDMETHODCALLTYPE get_NonBlockingIO(long* NonBlockingIO/*[out,retval]*/) = 0;
  // [3] State
  virtual HRESULT STDMETHODCALLTYPE get_State(Speechlib_tlb::SpeechAudioState* State/*[out,retval]*/) = 0;
  // [4] CurrentSeekPosition
  virtual HRESULT STDMETHODCALLTYPE get_CurrentSeekPosition(VARIANT* CurrentSeekPosition/*[out,retval]*/) = 0;
  // [5] CurrentDevicePosition
  virtual HRESULT STDMETHODCALLTYPE get_CurrentDevicePosition(VARIANT* CurrentDevicePosition/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  long __fastcall get_FreeBufferSpace(void)
  {
    long FreeBufferSpace;
    OLECHECK(this->get_FreeBufferSpace((long*)&FreeBufferSpace));
    return FreeBufferSpace;
  }

  long __fastcall get_NonBlockingIO(void)
  {
    long NonBlockingIO;
    OLECHECK(this->get_NonBlockingIO((long*)&NonBlockingIO));
    return NonBlockingIO;
  }

  Speechlib_tlb::SpeechAudioState __fastcall get_State(void)
  {
    Speechlib_tlb::SpeechAudioState State;
    OLECHECK(this->get_State((Speechlib_tlb::SpeechAudioState*)&State));
    return State;
  }

  VARIANT __fastcall get_CurrentSeekPosition(void)
  {
    VARIANT CurrentSeekPosition;
    OLECHECK(this->get_CurrentSeekPosition((VARIANT*)&CurrentSeekPosition));
    return CurrentSeekPosition;
  }

  VARIANT __fastcall get_CurrentDevicePosition(void)
  {
    VARIANT CurrentDevicePosition;
    OLECHECK(this->get_CurrentDevicePosition((VARIANT*)&CurrentDevicePosition));
    return CurrentDevicePosition;
  }


  __property   long            FreeBufferSpace = {read = get_FreeBufferSpace};
  __property   long            NonBlockingIO = {read = get_NonBlockingIO};
  __property   Speechlib_tlb::SpeechAudioState State = {read = get_State};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechAudioFormat
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {E6E9C590-3E18-40E3-8299-061F98BDE7C7}
// *********************************************************************//
interface ISpeechAudioFormat  : public IDispatch
{
public:
  // [1] Type
  virtual HRESULT STDMETHODCALLTYPE get_Type(Speechlib_tlb::SpeechAudioFormatType* AudioFormat/*[out,retval]*/) = 0;
  // [1] Type
  virtual HRESULT STDMETHODCALLTYPE set_Type(Speechlib_tlb::SpeechAudioFormatType AudioFormat/*[in]*/) = 0;
  // [2] Guid
  virtual HRESULT STDMETHODCALLTYPE get_Guid(BSTR* Guid/*[out,retval]*/) = 0;
  // [2] Guid
  virtual HRESULT STDMETHODCALLTYPE set_Guid(BSTR Guid/*[in]*/) = 0;
  // [3] GetWaveFormatEx
  virtual HRESULT STDMETHODCALLTYPE GetWaveFormatEx(Speechlib_tlb::ISpeechWaveFormatEx** SpeechWaveFormatEx/*[out,retval]*/) = 0;
  // [4] SetWaveFormatEx
  virtual HRESULT STDMETHODCALLTYPE SetWaveFormatEx(Speechlib_tlb::ISpeechWaveFormatEx* SpeechWaveFormatEx/*[in]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  Speechlib_tlb::SpeechAudioFormatType __fastcall get_Type(void)
  {
    Speechlib_tlb::SpeechAudioFormatType AudioFormat;
    OLECHECK(this->get_Type((Speechlib_tlb::SpeechAudioFormatType*)&AudioFormat));
    return AudioFormat;
  }

  BSTR __fastcall get_Guid(void)
  {
    BSTR Guid = 0;
    OLECHECK(this->get_Guid((BSTR*)&Guid));
    return Guid;
  }

  Speechlib_tlb::ISpeechWaveFormatEx* __fastcall GetWaveFormatEx(void)
  {
    Speechlib_tlb::ISpeechWaveFormatEx* SpeechWaveFormatEx = 0;
    OLECHECK(this->GetWaveFormatEx((Speechlib_tlb::ISpeechWaveFormatEx**)&SpeechWaveFormatEx));
    return SpeechWaveFormatEx;
  }


  __property   Speechlib_tlb::SpeechAudioFormatType Type = {read = get_Type, write = set_Type};
  __property   BSTR            Guid = {read = get_Guid, write = set_Guid};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechWaveFormatEx
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {7A1EF0D5-1581-4741-88E4-209A49F11A10}
// *********************************************************************//
interface ISpeechWaveFormatEx  : public IDispatch
{
public:
  // [1] FormatTag
  virtual HRESULT STDMETHODCALLTYPE get_FormatTag(short* FormatTag/*[out,retval]*/) = 0;
  // [1] FormatTag
  virtual HRESULT STDMETHODCALLTYPE set_FormatTag(short FormatTag/*[in]*/) = 0;
  // [2] Channels
  virtual HRESULT STDMETHODCALLTYPE get_Channels(short* Channels/*[out,retval]*/) = 0;
  // [2] Channels
  virtual HRESULT STDMETHODCALLTYPE set_Channels(short Channels/*[in]*/) = 0;
  // [3] SamplesPerSec
  virtual HRESULT STDMETHODCALLTYPE get_SamplesPerSec(long* SamplesPerSec/*[out,retval]*/) = 0;
  // [3] SamplesPerSec
  virtual HRESULT STDMETHODCALLTYPE set_SamplesPerSec(long SamplesPerSec/*[in]*/) = 0;
  // [4] AvgBytesPerSec
  virtual HRESULT STDMETHODCALLTYPE get_AvgBytesPerSec(long* AvgBytesPerSec/*[out,retval]*/) = 0;
  // [4] AvgBytesPerSec
  virtual HRESULT STDMETHODCALLTYPE set_AvgBytesPerSec(long AvgBytesPerSec/*[in]*/) = 0;
  // [5] BlockAlign
  virtual HRESULT STDMETHODCALLTYPE get_BlockAlign(short* BlockAlign/*[out,retval]*/) = 0;
  // [5] BlockAlign
  virtual HRESULT STDMETHODCALLTYPE set_BlockAlign(short BlockAlign/*[in]*/) = 0;
  // [6] BitsPerSample
  virtual HRESULT STDMETHODCALLTYPE get_BitsPerSample(short* BitsPerSample/*[out,retval]*/) = 0;
  // [6] BitsPerSample
  virtual HRESULT STDMETHODCALLTYPE set_BitsPerSample(short BitsPerSample/*[in]*/) = 0;
  // [7] ExtraData
  virtual HRESULT STDMETHODCALLTYPE get_ExtraData(VARIANT* ExtraData/*[out,retval]*/) = 0;
  // [7] ExtraData
  virtual HRESULT STDMETHODCALLTYPE set_ExtraData(VARIANT ExtraData/*[in]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  short __fastcall get_FormatTag(void)
  {
    short FormatTag;
    OLECHECK(this->get_FormatTag((short*)&FormatTag));
    return FormatTag;
  }

  short __fastcall get_Channels(void)
  {
    short Channels;
    OLECHECK(this->get_Channels((short*)&Channels));
    return Channels;
  }

  long __fastcall get_SamplesPerSec(void)
  {
    long SamplesPerSec;
    OLECHECK(this->get_SamplesPerSec((long*)&SamplesPerSec));
    return SamplesPerSec;
  }

  long __fastcall get_AvgBytesPerSec(void)
  {
    long AvgBytesPerSec;
    OLECHECK(this->get_AvgBytesPerSec((long*)&AvgBytesPerSec));
    return AvgBytesPerSec;
  }

  short __fastcall get_BlockAlign(void)
  {
    short BlockAlign;
    OLECHECK(this->get_BlockAlign((short*)&BlockAlign));
    return BlockAlign;
  }

  short __fastcall get_BitsPerSample(void)
  {
    short BitsPerSample;
    OLECHECK(this->get_BitsPerSample((short*)&BitsPerSample));
    return BitsPerSample;
  }

  VARIANT __fastcall get_ExtraData(void)
  {
    VARIANT ExtraData;
    OLECHECK(this->get_ExtraData((VARIANT*)&ExtraData));
    return ExtraData;
  }


  __property   short           FormatTag = {read = get_FormatTag, write = set_FormatTag};
  __property   short           Channels = {read = get_Channels, write = set_Channels};
  __property   long            SamplesPerSec = {read = get_SamplesPerSec, write = set_SamplesPerSec};
  __property   long            AvgBytesPerSec = {read = get_AvgBytesPerSec, write = set_AvgBytesPerSec};
  __property   short           BlockAlign = {read = get_BlockAlign, write = set_BlockAlign};
  __property   short           BitsPerSample = {read = get_BitsPerSample, write = set_BitsPerSample};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechBaseStream
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {6450336F-7D49-4CED-8097-49D6DEE37294}
// *********************************************************************//
interface ISpeechBaseStream  : public IDispatch
{
public:
  // [1] Format
  virtual HRESULT STDMETHODCALLTYPE get_Format(Speechlib_tlb::ISpeechAudioFormat** AudioFormat/*[out,retval]*/) = 0;
  // [1] Format
  virtual HRESULT STDMETHODCALLTYPE _set_Format(Speechlib_tlb::ISpeechAudioFormat* AudioFormat/*[in]*/) = 0;
  // [2] Read
  virtual HRESULT STDMETHODCALLTYPE Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/, 
                                         long* BytesRead/*[out,retval]*/) = 0;
  // [3] Write
  virtual HRESULT STDMETHODCALLTYPE Write(VARIANT Buffer/*[in]*/, long* BytesWritten/*[out,retval]*/) = 0;
  // [4] Seek
  virtual HRESULT STDMETHODCALLTYPE Seek(VARIANT Position/*[in]*/, 
                                         Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/, 
                                         VARIANT* NewPosition/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  Speechlib_tlb::ISpeechAudioFormatPtr __fastcall get_Format(void)
  {
    Speechlib_tlb::ISpeechAudioFormatPtr AudioFormat;
    OLECHECK(this->get_Format(&AudioFormat));
    return AudioFormat;
  }

  long __fastcall Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/)
  {
    long BytesRead;
    OLECHECK(this->Read(Buffer, NumberOfBytes, (long*)&BytesRead));
    return BytesRead;
  }

  long __fastcall Write(VARIANT Buffer/*[in]*/)
  {
    long BytesWritten;
    OLECHECK(this->Write(Buffer, (long*)&BytesWritten));
    return BytesWritten;
  }

  VARIANT __fastcall Seek(VARIANT Position/*[in]*/, 
                          Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/)
  {
    VARIANT NewPosition;
    OLECHECK(this->Seek(Position, Origin, (VARIANT*)&NewPosition));
    return NewPosition;
  }


  __property   Speechlib_tlb::ISpeechAudioFormatPtr Format = {read = get_Format};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechFileStream
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {AF67F125-AB39-4E93-B4A2-CC2E66E182A7}
// *********************************************************************//
interface ISpeechFileStream  : public Speechlib_tlb::ISpeechBaseStream
{
public:
  // [100] Open
  virtual HRESULT STDMETHODCALLTYPE Open(BSTR FileName/*[in]*/, 
                                         Speechlib_tlb::SpeechStreamFileMode FileMode/*[in,def,opt]*/, 
                                         VARIANT_BOOL DoEvents/*[in,def,opt]*/) = 0;
  // [101] Close
  virtual HRESULT STDMETHODCALLTYPE Close(void) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)



#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechMemoryStream
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {EEB14B68-808B-4ABE-A5EA-B51DA7588008}
// *********************************************************************//
interface ISpeechMemoryStream  : public Speechlib_tlb::ISpeechBaseStream
{
public:
  // [100] SetData
  virtual HRESULT STDMETHODCALLTYPE SetData(VARIANT Data/*[in]*/) = 0;
  // [101] GetData
  virtual HRESULT STDMETHODCALLTYPE GetData(VARIANT* pData/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  VARIANT __fastcall GetData(void)
  {
    VARIANT pData;
    OLECHECK(this->GetData((VARIANT*)&pData));
    return pData;
  }



#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechCustomStream
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {1A9E9F4F-104F-4DB8-A115-EFD7FD0C97AE}
// *********************************************************************//
interface ISpeechCustomStream  : public Speechlib_tlb::ISpeechBaseStream
{
public:
  // [100] BaseStream
  virtual HRESULT STDMETHODCALLTYPE get_BaseStream(LPUNKNOWN* ppUnkStream/*[out,retval]*/) = 0;
  // [100] BaseStream
  virtual HRESULT STDMETHODCALLTYPE _set_BaseStream(LPUNKNOWN ppUnkStream/*[in]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  LPUNKNOWN __fastcall get_BaseStream(void)
  {
    LPUNKNOWN ppUnkStream;
    OLECHECK(this->get_BaseStream((LPUNKNOWN*)&ppUnkStream));
    return ppUnkStream;
  }


  __property   LPUNKNOWN       BaseStream = {read = get_BaseStream, write = _set_BaseStream};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechAudio
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {CFF8E175-019E-11D3-A08E-00C04F8EF9B5}
// *********************************************************************//
interface ISpeechAudio  : public Speechlib_tlb::ISpeechBaseStream
{
public:
  // [200] Status
  virtual HRESULT STDMETHODCALLTYPE get_Status(Speechlib_tlb::ISpeechAudioStatus** Status/*[out,retval]*/) = 0;
  // [201] BufferInfo
  virtual HRESULT STDMETHODCALLTYPE get_BufferInfo(Speechlib_tlb::ISpeechAudioBufferInfo** BufferInfo/*[out,retval]*/) = 0;
  // [202] DefaultFormat
  virtual HRESULT STDMETHODCALLTYPE get_DefaultFormat(Speechlib_tlb::ISpeechAudioFormat** StreamFormat/*[out,retval]*/) = 0;
  // [203] Volume
  virtual HRESULT STDMETHODCALLTYPE get_Volume(long* Volume/*[out,retval]*/) = 0;
  // [203] Volume
  virtual HRESULT STDMETHODCALLTYPE set_Volume(long Volume/*[in]*/) = 0;
  // [204] BufferNotifySize
  virtual HRESULT STDMETHODCALLTYPE get_BufferNotifySize(long* BufferNotifySize/*[out,retval]*/) = 0;
  // [204] BufferNotifySize
  virtual HRESULT STDMETHODCALLTYPE set_BufferNotifySize(long BufferNotifySize/*[in]*/) = 0;
  // [205] EventHandle
  virtual HRESULT STDMETHODCALLTYPE get_EventHandle(long* EventHandle/*[out,retval]*/) = 0;
  // [206] SetState
  virtual HRESULT STDMETHODCALLTYPE SetState(Speechlib_tlb::SpeechAudioState State/*[in]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  Speechlib_tlb::ISpeechAudioStatusPtr __fastcall get_Status(void)
  {
    Speechlib_tlb::ISpeechAudioStatusPtr Status;
    OLECHECK(this->get_Status(&Status));
    return Status;
  }

  Speechlib_tlb::ISpeechAudioBufferInfoPtr __fastcall get_BufferInfo(void)
  {
    Speechlib_tlb::ISpeechAudioBufferInfoPtr BufferInfo;
    OLECHECK(this->get_BufferInfo(&BufferInfo));
    return BufferInfo;
  }

  Speechlib_tlb::ISpeechAudioFormatPtr __fastcall get_DefaultFormat(void)
  {
    Speechlib_tlb::ISpeechAudioFormatPtr StreamFormat;
    OLECHECK(this->get_DefaultFormat(&StreamFormat));
    return StreamFormat;
  }

  long __fastcall get_Volume(void)
  {
    long Volume;
    OLECHECK(this->get_Volume((long*)&Volume));
    return Volume;
  }

  long __fastcall get_BufferNotifySize(void)
  {
    long BufferNotifySize;
    OLECHECK(this->get_BufferNotifySize((long*)&BufferNotifySize));
    return BufferNotifySize;
  }

  long __fastcall get_EventHandle(void)
  {
    long EventHandle;
    OLECHECK(this->get_EventHandle((long*)&EventHandle));
    return EventHandle;
  }


  __property   Speechlib_tlb::ISpeechAudioStatusPtr Status = {read = get_Status};
  __property   Speechlib_tlb::ISpeechAudioBufferInfoPtr BufferInfo = {read = get_BufferInfo};
  __property   Speechlib_tlb::ISpeechAudioFormatPtr DefaultFormat = {read = get_DefaultFormat};
  __property   long            Volume = {read = get_Volume, write = set_Volume};
  __property   long            BufferNotifySize = {read = get_BufferNotifySize, write = set_BufferNotifySize};
  __property   long            EventHandle = {read = get_EventHandle};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechMMSysAudio
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {3C76AF6D-1FD7-4831-81D1-3B71D5A13C44}
// *********************************************************************//
interface ISpeechMMSysAudio  : public Speechlib_tlb::ISpeechAudio
{
public:
  // [300] DeviceId
  virtual HRESULT STDMETHODCALLTYPE get_DeviceId(long* DeviceId/*[out,retval]*/) = 0;
  // [300] DeviceId
  virtual HRESULT STDMETHODCALLTYPE set_DeviceId(long DeviceId/*[in]*/) = 0;
  // [301] LineId
  virtual HRESULT STDMETHODCALLTYPE get_LineId(long* LineId/*[out,retval]*/) = 0;
  // [301] LineId
  virtual HRESULT STDMETHODCALLTYPE set_LineId(long LineId/*[in]*/) = 0;
  // [302] MMHandle
  virtual HRESULT STDMETHODCALLTYPE get_MMHandle(long* Handle/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  long __fastcall get_DeviceId(void)
  {
    long DeviceId;
    OLECHECK(this->get_DeviceId((long*)&DeviceId));
    return DeviceId;
  }

  long __fastcall get_LineId(void)
  {
    long LineId;
    OLECHECK(this->get_LineId((long*)&LineId));
    return LineId;
  }

  long __fastcall get_MMHandle(void)
  {
    long Handle;
    OLECHECK(this->get_MMHandle((long*)&Handle));
    return Handle;
  }


  __property   long            DeviceId = {read = get_DeviceId, write = set_DeviceId};
  __property   long            LineId = {read = get_LineId, write = set_LineId};
  __property   long            MMHandle = {read = get_MMHandle};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechVoice
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {269316D8-57BD-11D2-9EEE-00C04F797396}
// *********************************************************************//
interface ISpeechVoice  : public IDispatch
{
public:
  // [1] Status
  virtual HRESULT STDMETHODCALLTYPE get_Status(Speechlib_tlb::ISpeechVoiceStatus** Status/*[out,retval]*/) = 0;
  // [2] Voice
  virtual HRESULT STDMETHODCALLTYPE get_Voice(Speechlib_tlb::ISpeechObjectToken** Voice/*[out,retval]*/) = 0;
  // [2] Voice
  virtual HRESULT STDMETHODCALLTYPE _set_Voice(Speechlib_tlb::ISpeechObjectToken* Voice/*[in]*/) = 0;
  // [3] Gets the audio output object
  virtual HRESULT STDMETHODCALLTYPE get_AudioOutput(Speechlib_tlb::ISpeechObjectToken** AudioOutput/*[out,retval]*/) = 0;
  // [3] Gets the audio output object
  virtual HRESULT STDMETHODCALLTYPE _set_AudioOutput(Speechlib_tlb::ISpeechObjectToken* AudioOutput/*[in]*/) = 0;
  // [4] Gets the audio output stream
  virtual HRESULT STDMETHODCALLTYPE get_AudioOutputStream(Speechlib_tlb::ISpeechBaseStream** AudioOutputStream/*[out,retval]*/) = 0;
  // [4] Gets the audio output stream
  virtual HRESULT STDMETHODCALLTYPE _set_AudioOutputStream(Speechlib_tlb::ISpeechBaseStream* AudioOutputStream/*[in]*/) = 0;
  // [5] Rate
  virtual HRESULT STDMETHODCALLTYPE get_Rate(long* Rate/*[out,retval]*/) = 0;
  // [5] Rate
  virtual HRESULT STDMETHODCALLTYPE set_Rate(long Rate/*[in]*/) = 0;
  // [6] Volume
  virtual HRESULT STDMETHODCALLTYPE get_Volume(long* Volume/*[out,retval]*/) = 0;
  // [6] Volume
  virtual HRESULT STDMETHODCALLTYPE set_Volume(long Volume/*[in]*/) = 0;
  // [7] AllowAudioOutputFormatChangesOnNextSet
  virtual HRESULT STDMETHODCALLTYPE set_AllowAudioOutputFormatChangesOnNextSet(VARIANT_BOOL Allow/*[in]*/) = 0;
  // [7] AllowAudioOutputFormatChangesOnNextSet
  virtual HRESULT STDMETHODCALLTYPE get_AllowAudioOutputFormatChangesOnNextSet(VARIANT_BOOL* Allow/*[out,retval]*/) = 0;
  // [8] EventInterests
  virtual HRESULT STDMETHODCALLTYPE get_EventInterests(Speechlib_tlb::SpeechVoiceEvents* EventInterestFlags/*[out,retval]*/) = 0;
  // [8] EventInterests
  virtual HRESULT STDMETHODCALLTYPE set_EventInterests(Speechlib_tlb::SpeechVoiceEvents EventInterestFlags/*[in]*/) = 0;
  // [9] Priority
  virtual HRESULT STDMETHODCALLTYPE set_Priority(Speechlib_tlb::SpeechVoicePriority Priority/*[in]*/) = 0;
  // [9] Priority
  virtual HRESULT STDMETHODCALLTYPE get_Priority(Speechlib_tlb::SpeechVoicePriority* Priority/*[out,retval]*/) = 0;
  // [10] AlertBoundary
  virtual HRESULT STDMETHODCALLTYPE set_AlertBoundary(Speechlib_tlb::SpeechVoiceEvents Boundary/*[in]*/) = 0;
  // [10] AlertBoundary
  virtual HRESULT STDMETHODCALLTYPE get_AlertBoundary(Speechlib_tlb::SpeechVoiceEvents* Boundary/*[out,retval]*/) = 0;
  // [11] SyncSpeakTimeout
  virtual HRESULT STDMETHODCALLTYPE set_SynchronousSpeakTimeout(long msTimeout/*[in]*/) = 0;
  // [11] SyncSpeakTimeout
  virtual HRESULT STDMETHODCALLTYPE get_SynchronousSpeakTimeout(long* msTimeout/*[out,retval]*/) = 0;
  // [12] Speak
  virtual HRESULT STDMETHODCALLTYPE Speak(BSTR Text/*[in]*/, 
                                          Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/, 
                                          long* StreamNumber/*[out,retval]*/) = 0;
  // [13] SpeakStream
  virtual HRESULT STDMETHODCALLTYPE SpeakStream(Speechlib_tlb::ISpeechBaseStream* Stream/*[in]*/, 
                                                Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/, 
                                                long* StreamNumber/*[out,retval]*/) = 0;
  // [14] Pauses the voices rendering.
  virtual HRESULT STDMETHODCALLTYPE Pause(void) = 0;
  // [15] Resumes the voices rendering.
  virtual HRESULT STDMETHODCALLTYPE Resume(void) = 0;
  // [16] Skips rendering the specified number of items.
  virtual HRESULT STDMETHODCALLTYPE Skip(BSTR Type/*[in]*/, long NumItems/*[in]*/, 
                                         long* NumSkipped/*[out,retval]*/) = 0;
  // [17] GetVoices
  virtual HRESULT STDMETHODCALLTYPE GetVoices(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                              BSTR OptionalAttributes/*[in,def,opt]*/, 
                                              Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/) = 0;
  // [18] GetAudioOutputs
  virtual HRESULT STDMETHODCALLTYPE GetAudioOutputs(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                    BSTR OptionalAttributes/*[in,def,opt]*/, 
                                                    Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/) = 0;
  // [19] WaitUntilDone
  virtual HRESULT STDMETHODCALLTYPE WaitUntilDone(long msTimeout/*[in]*/, 
                                                  VARIANT_BOOL* Done/*[out,retval]*/) = 0;
  // [20] SpeakCompleteEvent
  virtual HRESULT STDMETHODCALLTYPE SpeakCompleteEvent(long* Handle/*[out,retval]*/) = 0;
  // [21] IsUISupported
  virtual HRESULT STDMETHODCALLTYPE IsUISupported(BSTR TypeOfUI/*[in]*/, 
                                                  VARIANT* ExtraData/*[in,def,opt]*/, 
                                                  VARIANT_BOOL* Supported/*[out,retval]*/) = 0;
  // [22] DisplayUI
  virtual HRESULT STDMETHODCALLTYPE DisplayUI(long hWndParent/*[in]*/, BSTR Title/*[in]*/, 
                                              BSTR TypeOfUI/*[in]*/, 
                                              VARIANT* ExtraData/*[in,def,opt]*/= TNoParam()) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  Speechlib_tlb::ISpeechVoiceStatusPtr __fastcall get_Status(void)
  {
    Speechlib_tlb::ISpeechVoiceStatusPtr Status;
    OLECHECK(this->get_Status(&Status));
    return Status;
  }

  Speechlib_tlb::ISpeechObjectTokenPtr __fastcall get_Voice(void)
  {
    Speechlib_tlb::ISpeechObjectTokenPtr Voice;
    OLECHECK(this->get_Voice(&Voice));
    return Voice;
  }

  Speechlib_tlb::ISpeechObjectTokenPtr __fastcall get_AudioOutput(void)
  {
    Speechlib_tlb::ISpeechObjectTokenPtr AudioOutput;
    OLECHECK(this->get_AudioOutput(&AudioOutput));
    return AudioOutput;
  }

  Speechlib_tlb::ISpeechBaseStreamPtr __fastcall get_AudioOutputStream(void)
  {
    Speechlib_tlb::ISpeechBaseStreamPtr AudioOutputStream;
    OLECHECK(this->get_AudioOutputStream(&AudioOutputStream));
    return AudioOutputStream;
  }

  long __fastcall get_Rate(void)
  {
    long Rate;
    OLECHECK(this->get_Rate((long*)&Rate));
    return Rate;
  }

  long __fastcall get_Volume(void)
  {
    long Volume;
    OLECHECK(this->get_Volume((long*)&Volume));
    return Volume;
  }

  VARIANT_BOOL __fastcall get_AllowAudioOutputFormatChangesOnNextSet(void)
  {
    VARIANT_BOOL Allow;
    OLECHECK(this->get_AllowAudioOutputFormatChangesOnNextSet((VARIANT_BOOL*)&Allow));
    return Allow;
  }

  Speechlib_tlb::SpeechVoiceEvents __fastcall get_EventInterests(void)
  {
    Speechlib_tlb::SpeechVoiceEvents EventInterestFlags;
    OLECHECK(this->get_EventInterests((Speechlib_tlb::SpeechVoiceEvents*)&EventInterestFlags));
    return EventInterestFlags;
  }

  Speechlib_tlb::SpeechVoicePriority __fastcall get_Priority(void)
  {
    Speechlib_tlb::SpeechVoicePriority Priority;
    OLECHECK(this->get_Priority((Speechlib_tlb::SpeechVoicePriority*)&Priority));
    return Priority;
  }

  Speechlib_tlb::SpeechVoiceEvents __fastcall get_AlertBoundary(void)
  {
    Speechlib_tlb::SpeechVoiceEvents Boundary;
    OLECHECK(this->get_AlertBoundary((Speechlib_tlb::SpeechVoiceEvents*)&Boundary));
    return Boundary;
  }

  long __fastcall get_SynchronousSpeakTimeout(void)
  {
    long msTimeout;
    OLECHECK(this->get_SynchronousSpeakTimeout((long*)&msTimeout));
    return msTimeout;
  }

  long __fastcall Speak(BSTR Text/*[in]*/, 
                        Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/)
  {
    long StreamNumber;
    OLECHECK(this->Speak(Text, Flags, (long*)&StreamNumber));
    return StreamNumber;
  }

  long __fastcall SpeakStream(Speechlib_tlb::ISpeechBaseStream* Stream/*[in]*/, 
                              Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/)
  {
    long StreamNumber;
    OLECHECK(this->SpeakStream(Stream, Flags, (long*)&StreamNumber));
    return StreamNumber;
  }

  long __fastcall Skip(BSTR Type/*[in]*/, long NumItems/*[in]*/)
  {
    long NumSkipped;
    OLECHECK(this->Skip(Type, NumItems, (long*)&NumSkipped));
    return NumSkipped;
  }

  Speechlib_tlb::ISpeechObjectTokens* __fastcall GetVoices(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                           BSTR OptionalAttributes/*[in,def,opt]*/)
  {
    Speechlib_tlb::ISpeechObjectTokens* ObjectTokens = 0;
    OLECHECK(this->GetVoices(RequiredAttributes, OptionalAttributes, (Speechlib_tlb::ISpeechObjectTokens**)&ObjectTokens));
    return ObjectTokens;
  }

  Speechlib_tlb::ISpeechObjectTokens* __fastcall GetAudioOutputs(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                                 BSTR OptionalAttributes/*[in,def,opt]*/)
  {
    Speechlib_tlb::ISpeechObjectTokens* ObjectTokens = 0;
    OLECHECK(this->GetAudioOutputs(RequiredAttributes, OptionalAttributes, (Speechlib_tlb::ISpeechObjectTokens**)&ObjectTokens));
    return ObjectTokens;
  }

  VARIANT_BOOL __fastcall WaitUntilDone(long msTimeout/*[in]*/)
  {
    VARIANT_BOOL Done;
    OLECHECK(this->WaitUntilDone(msTimeout, (VARIANT_BOOL*)&Done));
    return Done;
  }

  long __fastcall SpeakCompleteEvent(void)
  {
    long Handle;
    OLECHECK(this->SpeakCompleteEvent((long*)&Handle));
    return Handle;
  }

  VARIANT_BOOL __fastcall IsUISupported(BSTR TypeOfUI/*[in]*/, 
                                        VARIANT* ExtraData/*[in,def,opt]*/= TNoParam())
  {
    VARIANT_BOOL Supported;
    OLECHECK(this->IsUISupported(TypeOfUI, ExtraData, (VARIANT_BOOL*)&Supported));
    return Supported;
  }


  __property   Speechlib_tlb::ISpeechVoiceStatusPtr Status = {read = get_Status};
  __property   Speechlib_tlb::ISpeechObjectTokenPtr Voice = {read = get_Voice};
  __property   Speechlib_tlb::ISpeechObjectTokenPtr AudioOutput = {read = get_AudioOutput};
  __property   Speechlib_tlb::ISpeechBaseStreamPtr AudioOutputStream = {read = get_AudioOutputStream};
  __property   long            Rate = {read = get_Rate, write = set_Rate};
  __property   long            Volume = {read = get_Volume, write = set_Volume};
  __property   VARIANT_BOOL    AllowAudioOutputFormatChangesOnNextSet = {read = get_AllowAudioOutputFormatChangesOnNextSet, write = set_AllowAudioOutputFormatChangesOnNextSet};
  __property   Speechlib_tlb::SpeechVoiceEvents EventInterests = {read = get_EventInterests, write = set_EventInterests};
  __property   Speechlib_tlb::SpeechVoicePriority Priority = {read = get_Priority, write = set_Priority};
  __property   Speechlib_tlb::SpeechVoiceEvents AlertBoundary = {read = get_AlertBoundary, write = set_AlertBoundary};
  __property   long            SynchronousSpeakTimeout = {read = get_SynchronousSpeakTimeout, write = set_SynchronousSpeakTimeout};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechVoiceStatus
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {8BE47B07-57F6-11D2-9EEE-00C04F797396}
// *********************************************************************//
interface ISpeechVoiceStatus  : public IDispatch
{
public:
  // [1] CurrentStreamNumber
  virtual HRESULT STDMETHODCALLTYPE get_CurrentStreamNumber(long* StreamNumber/*[out,retval]*/) = 0;
  // [2] LastStreamNumberQueued
  virtual HRESULT STDMETHODCALLTYPE get_LastStreamNumberQueued(long* StreamNumber/*[out,retval]*/) = 0;
  // [3] LastHResult
  virtual HRESULT STDMETHODCALLTYPE get_LastHResult(long* HResult/*[out,retval]*/) = 0;
  // [4] RunningState
  virtual HRESULT STDMETHODCALLTYPE get_RunningState(Speechlib_tlb::SpeechRunState* State/*[out,retval]*/) = 0;
  // [5] InputWordPosition
  virtual HRESULT STDMETHODCALLTYPE get_InputWordPosition(long* Position/*[out,retval]*/) = 0;
  // [6] InputWordLength
  virtual HRESULT STDMETHODCALLTYPE get_InputWordLength(long* Length/*[out,retval]*/) = 0;
  // [7] InputSentencePosition
  virtual HRESULT STDMETHODCALLTYPE get_InputSentencePosition(long* Position/*[out,retval]*/) = 0;
  // [8] InputSentenceLength
  virtual HRESULT STDMETHODCALLTYPE get_InputSentenceLength(long* Length/*[out,retval]*/) = 0;
  // [9] LastBookmark
  virtual HRESULT STDMETHODCALLTYPE get_LastBookmark(BSTR* Bookmark/*[out,retval]*/) = 0;
  // [10] LastBookmarkId
  virtual HRESULT STDMETHODCALLTYPE get_LastBookmarkId(long* BookmarkId/*[out,retval]*/) = 0;
  // [11] PhonemeId
  virtual HRESULT STDMETHODCALLTYPE get_PhonemeId(short* PhoneId/*[out,retval]*/) = 0;
  // [12] VisemeId
  virtual HRESULT STDMETHODCALLTYPE get_VisemeId(short* VisemeId/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  long __fastcall get_CurrentStreamNumber(void)
  {
    long StreamNumber;
    OLECHECK(this->get_CurrentStreamNumber((long*)&StreamNumber));
    return StreamNumber;
  }

  long __fastcall get_LastStreamNumberQueued(void)
  {
    long StreamNumber;
    OLECHECK(this->get_LastStreamNumberQueued((long*)&StreamNumber));
    return StreamNumber;
  }

  long __fastcall get_LastHResult(void)
  {
    long HResult;
    OLECHECK(this->get_LastHResult((long*)&HResult));
    return HResult;
  }

  Speechlib_tlb::SpeechRunState __fastcall get_RunningState(void)
  {
    Speechlib_tlb::SpeechRunState State;
    OLECHECK(this->get_RunningState((Speechlib_tlb::SpeechRunState*)&State));
    return State;
  }

  long __fastcall get_InputWordPosition(void)
  {
    long Position;
    OLECHECK(this->get_InputWordPosition((long*)&Position));
    return Position;
  }

  long __fastcall get_InputWordLength(void)
  {
    long Length;
    OLECHECK(this->get_InputWordLength((long*)&Length));
    return Length;
  }

  long __fastcall get_InputSentencePosition(void)
  {
    long Position;
    OLECHECK(this->get_InputSentencePosition((long*)&Position));
    return Position;
  }

  long __fastcall get_InputSentenceLength(void)
  {
    long Length;
    OLECHECK(this->get_InputSentenceLength((long*)&Length));
    return Length;
  }

  BSTR __fastcall get_LastBookmark(void)
  {
    BSTR Bookmark = 0;
    OLECHECK(this->get_LastBookmark((BSTR*)&Bookmark));
    return Bookmark;
  }

  long __fastcall get_LastBookmarkId(void)
  {
    long BookmarkId;
    OLECHECK(this->get_LastBookmarkId((long*)&BookmarkId));
    return BookmarkId;
  }

  short __fastcall get_PhonemeId(void)
  {
    short PhoneId;
    OLECHECK(this->get_PhonemeId((short*)&PhoneId));
    return PhoneId;
  }

  short __fastcall get_VisemeId(void)
  {
    short VisemeId;
    OLECHECK(this->get_VisemeId((short*)&VisemeId));
    return VisemeId;
  }


  __property   long            CurrentStreamNumber = {read = get_CurrentStreamNumber};
  __property   long            LastStreamNumberQueued = {read = get_LastStreamNumberQueued};
  __property   long            LastHResult = {read = get_LastHResult};
  __property   Speechlib_tlb::SpeechRunState RunningState = {read = get_RunningState};
  __property   long            InputWordPosition = {read = get_InputWordPosition};
  __property   long            InputWordLength = {read = get_InputWordLength};
  __property   long            InputSentencePosition = {read = get_InputSentencePosition};
  __property   long            InputSentenceLength = {read = get_InputSentenceLength};
  __property   BSTR            LastBookmark = {read = get_LastBookmark};
  __property   long            LastBookmarkId = {read = get_LastBookmarkId};
  __property   short           PhonemeId = {read = get_PhonemeId};
  __property   short           VisemeId = {read = get_VisemeId};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: _ISpeechVoiceEvents
// Flags:     (4096) Dispatchable
// GUID:      {A372ACD1-3BEF-4BBD-8FFB-CB3E2B416AF8}
// *********************************************************************//
interface _ISpeechVoiceEvents : public TDispWrapper<IDispatch>
{
  void __fastcall StartStream(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/)
  {
    _TDispID _dispid(/* StartStream */ DISPID(1));
    TAutoArgs<2> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall EndStream(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/)
  {
    _TDispID _dispid(/* EndStream */ DISPID(2));
    TAutoArgs<2> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall VoiceChange(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                              Speechlib_tlb::ISpeechObjectToken* VoiceObjectToken/*[in]*/)
  {
    _TDispID _dispid(/* VoiceChange */ DISPID(3));
    TAutoArgs<3> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    _args[3] = (LPDISPATCH)(Speechlib_tlb::ISpeechObjectToken*)VoiceObjectToken /*[VT_USERDEFINED:1]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall Bookmark(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                           BSTR Bookmark/*[in]*/, long BookmarkId/*[in]*/)
  {
    _TDispID _dispid(/* Bookmark */ DISPID(4));
    TAutoArgs<4> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    _args[3] = Bookmark /*[VT_BSTR:0]*/;
    _args[4] = BookmarkId /*[VT_I4:0]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall Word(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                       long CharacterPosition/*[in]*/, long Length/*[in]*/)
  {
    _TDispID _dispid(/* Word */ DISPID(5));
    TAutoArgs<4> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    _args[3] = CharacterPosition /*[VT_I4:0]*/;
    _args[4] = Length /*[VT_I4:0]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall Sentence(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                           long CharacterPosition/*[in]*/, long Length/*[in]*/)
  {
    _TDispID _dispid(/* Sentence */ DISPID(7));
    TAutoArgs<4> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    _args[3] = CharacterPosition /*[VT_I4:0]*/;
    _args[4] = Length /*[VT_I4:0]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall Phoneme(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                          long Duration/*[in]*/, short NextPhoneId/*[in]*/, 
                          Speechlib_tlb::SpeechVisemeFeature Feature/*[in]*/, 
                          short CurrentPhoneId/*[in]*/)
  {
    _TDispID _dispid(/* Phoneme */ DISPID(6));
    TAutoArgs<6> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    _args[3] = Duration /*[VT_I4:0]*/;
    _args[4] = NextPhoneId /*[VT_I2:0]*/;
    _args[5] = (int)Feature /*[VT_USERDEFINED:0]*/;
    _args[6] = CurrentPhoneId /*[VT_I2:0]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall Viseme(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                         long Duration/*[in]*/, Speechlib_tlb::SpeechVisemeType NextVisemeId/*[in]*/
                         , Speechlib_tlb::SpeechVisemeFeature Feature/*[in]*/, 
                         Speechlib_tlb::SpeechVisemeType CurrentVisemeId/*[in]*/)
  {
    _TDispID _dispid(/* Viseme */ DISPID(8));
    TAutoArgs<6> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    _args[3] = Duration /*[VT_I4:0]*/;
    _args[4] = (int)NextVisemeId /*[VT_USERDEFINED:0]*/;
    _args[5] = (int)Feature /*[VT_USERDEFINED:0]*/;
    _args[6] = (int)CurrentVisemeId /*[VT_USERDEFINED:0]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall AudioLevel(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                             long AudioLevel/*[in]*/)
  {
    _TDispID _dispid(/* AudioLevel */ DISPID(9));
    TAutoArgs<3> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    _args[3] = AudioLevel /*[VT_I4:0]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall EnginePrivate(long StreamNumber/*[in]*/, long StreamPosition/*[in]*/, 
                                VARIANT EngineData/*[in]*/)
  {
    _TDispID _dispid(/* EnginePrivate */ DISPID(10));
    TAutoArgs<3> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_I4:0]*/;
    _args[3] = EngineData /*[VT_VARIANT:0]*/;
    OleProcedure(_dispid, _args);
  }


};
// *********************************************************************//
// Interface: ISpeechRecognizer
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {2D5F1C0C-BD75-4B08-9478-3B11FEA2586C}
// *********************************************************************//
interface ISpeechRecognizer  : public IDispatch
{
public:
  // [1] Recognizer
  virtual HRESULT STDMETHODCALLTYPE _set_Recognizer(Speechlib_tlb::ISpeechObjectToken* Recognizer/*[in]*/) = 0;
  // [1] Recognizer
  virtual HRESULT STDMETHODCALLTYPE get_Recognizer(Speechlib_tlb::ISpeechObjectToken** Recognizer/*[out,retval]*/) = 0;
  // [2] AllowAudioInputFormatChangesOnNextSet
  virtual HRESULT STDMETHODCALLTYPE set_AllowAudioInputFormatChangesOnNextSet(VARIANT_BOOL Allow/*[in]*/) = 0;
  // [2] AllowAudioInputFormatChangesOnNextSet
  virtual HRESULT STDMETHODCALLTYPE get_AllowAudioInputFormatChangesOnNextSet(VARIANT_BOOL* Allow/*[out,retval]*/) = 0;
  // [3] AudioInput
  virtual HRESULT STDMETHODCALLTYPE _set_AudioInput(Speechlib_tlb::ISpeechObjectToken* AudioInput/*[in,def,opt]*/) = 0;
  // [3] AudioInput
  virtual HRESULT STDMETHODCALLTYPE get_AudioInput(Speechlib_tlb::ISpeechObjectToken** AudioInput/*[out,retval]*/) = 0;
  // [4] AudioInputStream
  virtual HRESULT STDMETHODCALLTYPE _set_AudioInputStream(Speechlib_tlb::ISpeechBaseStream* AudioInputStream/*[in,def,opt]*/) = 0;
  // [4] AudioInputStream
  virtual HRESULT STDMETHODCALLTYPE get_AudioInputStream(Speechlib_tlb::ISpeechBaseStream** AudioInputStream/*[out,retval]*/) = 0;
  // [5] IsShared
  virtual HRESULT STDMETHODCALLTYPE get_IsShared(VARIANT_BOOL* Shared/*[out,retval]*/) = 0;
  // [6] State
  virtual HRESULT STDMETHODCALLTYPE set_State(Speechlib_tlb::SpeechRecognizerState State/*[in]*/) = 0;
  // [6] State
  virtual HRESULT STDMETHODCALLTYPE get_State(Speechlib_tlb::SpeechRecognizerState* State/*[out,retval]*/) = 0;
  // [7] Status
  virtual HRESULT STDMETHODCALLTYPE get_Status(Speechlib_tlb::ISpeechRecognizerStatus** Status/*[out,retval]*/) = 0;
  // [8] Profile
  virtual HRESULT STDMETHODCALLTYPE _set_Profile(Speechlib_tlb::ISpeechObjectToken* Profile/*[in,def,opt]*/) = 0;
  // [8] Profile
  virtual HRESULT STDMETHODCALLTYPE get_Profile(Speechlib_tlb::ISpeechObjectToken** Profile/*[out,retval]*/) = 0;
  // [9] EmulateRecognition
  virtual HRESULT STDMETHODCALLTYPE EmulateRecognition(VARIANT TextElements/*[in]*/, 
                                                       VARIANT* ElementDisplayAttributes/*[in,def,opt]*/, 
                                                       long LanguageId/*[in,def,opt]*/) = 0;
  // [10] CreateRecoContext
  virtual HRESULT STDMETHODCALLTYPE CreateRecoContext(Speechlib_tlb::ISpeechRecoContext** NewContext/*[out,retval]*/) = 0;
  // [11] GetFormat
  virtual HRESULT STDMETHODCALLTYPE GetFormat(Speechlib_tlb::SpeechFormatType Type/*[in]*/, 
                                              Speechlib_tlb::ISpeechAudioFormat** Format/*[out,retval]*/) = 0;
  // [12] SetPropertyNumber
  virtual HRESULT STDMETHODCALLTYPE SetPropertyNumber(BSTR Name/*[in]*/, long Value/*[in]*/, 
                                                      VARIANT_BOOL* Supported/*[out,retval]*/) = 0;
  // [13] GetPropertyNumber
  virtual HRESULT STDMETHODCALLTYPE GetPropertyNumber(BSTR Name/*[in]*/, long* Value/*[in,out]*/, 
                                                      VARIANT_BOOL* Supported/*[out,retval]*/) = 0;
  // [14] SetPropertyString
  virtual HRESULT STDMETHODCALLTYPE SetPropertyString(BSTR Name/*[in]*/, BSTR Value/*[in]*/, 
                                                      VARIANT_BOOL* Supported/*[out,retval]*/) = 0;
  // [15] GetPropertyString
  virtual HRESULT STDMETHODCALLTYPE GetPropertyString(BSTR Name/*[in]*/, BSTR* Value/*[in,out]*/, 
                                                      VARIANT_BOOL* Supported/*[out,retval]*/) = 0;
  // [16] IsUISupported
  virtual HRESULT STDMETHODCALLTYPE IsUISupported(BSTR TypeOfUI/*[in]*/, 
                                                  VARIANT* ExtraData/*[in,def,opt]*/, 
                                                  VARIANT_BOOL* Supported/*[out,retval]*/) = 0;
  // [17] DisplayUI
  virtual HRESULT STDMETHODCALLTYPE DisplayUI(long hWndParent/*[in]*/, BSTR Title/*[in]*/, 
                                              BSTR TypeOfUI/*[in]*/, 
                                              VARIANT* ExtraData/*[in,def,opt]*/= TNoParam()) = 0;
  // [18] GetRecognizers
  virtual HRESULT STDMETHODCALLTYPE GetRecognizers(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                   BSTR OptionalAttributes/*[in,def,opt]*/, 
                                                   Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/) = 0;
  // [19] GetAudioInputs
  virtual HRESULT STDMETHODCALLTYPE GetAudioInputs(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                   BSTR OptionalAttributes/*[in,def,opt]*/, 
                                                   Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/) = 0;
  // [20] GetProfiles
  virtual HRESULT STDMETHODCALLTYPE GetProfiles(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                BSTR OptionalAttributes/*[in,def,opt]*/, 
                                                Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  Speechlib_tlb::ISpeechObjectTokenPtr __fastcall get_Recognizer(void)
  {
    Speechlib_tlb::ISpeechObjectTokenPtr Recognizer;
    OLECHECK(this->get_Recognizer(&Recognizer));
    return Recognizer;
  }

  VARIANT_BOOL __fastcall get_AllowAudioInputFormatChangesOnNextSet(void)
  {
    VARIANT_BOOL Allow;
    OLECHECK(this->get_AllowAudioInputFormatChangesOnNextSet((VARIANT_BOOL*)&Allow));
    return Allow;
  }

  Speechlib_tlb::ISpeechObjectTokenPtr __fastcall get_AudioInput(void)
  {
    Speechlib_tlb::ISpeechObjectTokenPtr AudioInput;
    OLECHECK(this->get_AudioInput(&AudioInput));
    return AudioInput;
  }

  Speechlib_tlb::ISpeechBaseStreamPtr __fastcall get_AudioInputStream(void)
  {
    Speechlib_tlb::ISpeechBaseStreamPtr AudioInputStream;
    OLECHECK(this->get_AudioInputStream(&AudioInputStream));
    return AudioInputStream;
  }

  VARIANT_BOOL __fastcall get_IsShared(void)
  {
    VARIANT_BOOL Shared;
    OLECHECK(this->get_IsShared((VARIANT_BOOL*)&Shared));
    return Shared;
  }

  Speechlib_tlb::SpeechRecognizerState __fastcall get_State(void)
  {
    Speechlib_tlb::SpeechRecognizerState State;
    OLECHECK(this->get_State((Speechlib_tlb::SpeechRecognizerState*)&State));
    return State;
  }

  Speechlib_tlb::ISpeechRecognizerStatusPtr __fastcall get_Status(void)
  {
    Speechlib_tlb::ISpeechRecognizerStatusPtr Status;
    OLECHECK(this->get_Status(&Status));
    return Status;
  }

  Speechlib_tlb::ISpeechObjectTokenPtr __fastcall get_Profile(void)
  {
    Speechlib_tlb::ISpeechObjectTokenPtr Profile;
    OLECHECK(this->get_Profile(&Profile));
    return Profile;
  }

  Speechlib_tlb::ISpeechRecoContext* __fastcall CreateRecoContext(void)
  {
    Speechlib_tlb::ISpeechRecoContext* NewContext = 0;
    OLECHECK(this->CreateRecoContext((Speechlib_tlb::ISpeechRecoContext**)&NewContext));
    return NewContext;
  }

  Speechlib_tlb::ISpeechAudioFormat* __fastcall GetFormat(Speechlib_tlb::SpeechFormatType Type/*[in]*/)
  {
    Speechlib_tlb::ISpeechAudioFormat* Format = 0;
    OLECHECK(this->GetFormat(Type, (Speechlib_tlb::ISpeechAudioFormat**)&Format));
    return Format;
  }

  VARIANT_BOOL __fastcall SetPropertyNumber(BSTR Name/*[in]*/, long Value/*[in]*/)
  {
    VARIANT_BOOL Supported;
    OLECHECK(this->SetPropertyNumber(Name, Value, (VARIANT_BOOL*)&Supported));
    return Supported;
  }

  VARIANT_BOOL __fastcall GetPropertyNumber(BSTR Name/*[in]*/, long* Value/*[in,out]*/)
  {
    VARIANT_BOOL Supported;
    OLECHECK(this->GetPropertyNumber(Name, Value, (VARIANT_BOOL*)&Supported));
    return Supported;
  }

  VARIANT_BOOL __fastcall SetPropertyString(BSTR Name/*[in]*/, BSTR Value/*[in]*/)
  {
    VARIANT_BOOL Supported;
    OLECHECK(this->SetPropertyString(Name, Value, (VARIANT_BOOL*)&Supported));
    return Supported;
  }

  VARIANT_BOOL __fastcall GetPropertyString(BSTR Name/*[in]*/, BSTR* Value/*[in,out]*/)
  {
    VARIANT_BOOL Supported;
    OLECHECK(this->GetPropertyString(Name, Value, (VARIANT_BOOL*)&Supported));
    return Supported;
  }

  VARIANT_BOOL __fastcall IsUISupported(BSTR TypeOfUI/*[in]*/, 
                                        VARIANT* ExtraData/*[in,def,opt]*/= TNoParam())
  {
    VARIANT_BOOL Supported;
    OLECHECK(this->IsUISupported(TypeOfUI, ExtraData, (VARIANT_BOOL*)&Supported));
    return Supported;
  }

  Speechlib_tlb::ISpeechObjectTokens* __fastcall GetRecognizers(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                                BSTR OptionalAttributes/*[in,def,opt]*/)
  {
    Speechlib_tlb::ISpeechObjectTokens* ObjectTokens = 0;
    OLECHECK(this->GetRecognizers(RequiredAttributes, OptionalAttributes, (Speechlib_tlb::ISpeechObjectTokens**)&ObjectTokens));
    return ObjectTokens;
  }

  Speechlib_tlb::ISpeechObjectTokens* __fastcall GetAudioInputs(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                                BSTR OptionalAttributes/*[in,def,opt]*/)
  {
    Speechlib_tlb::ISpeechObjectTokens* ObjectTokens = 0;
    OLECHECK(this->GetAudioInputs(RequiredAttributes, OptionalAttributes, (Speechlib_tlb::ISpeechObjectTokens**)&ObjectTokens));
    return ObjectTokens;
  }

  Speechlib_tlb::ISpeechObjectTokens* __fastcall GetProfiles(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                             BSTR OptionalAttributes/*[in,def,opt]*/)
  {
    Speechlib_tlb::ISpeechObjectTokens* ObjectTokens = 0;
    OLECHECK(this->GetProfiles(RequiredAttributes, OptionalAttributes, (Speechlib_tlb::ISpeechObjectTokens**)&ObjectTokens));
    return ObjectTokens;
  }


  __property   Speechlib_tlb::ISpeechObjectToken* Recognizer = {write = _set_Recognizer};
  __property   VARIANT_BOOL    AllowAudioInputFormatChangesOnNextSet = {read = get_AllowAudioInputFormatChangesOnNextSet, write = set_AllowAudioInputFormatChangesOnNextSet};
  __property   Speechlib_tlb::ISpeechObjectToken* AudioInput = {write = _set_AudioInput};
  __property   Speechlib_tlb::ISpeechBaseStream* AudioInputStream = {write = _set_AudioInputStream};
  __property   VARIANT_BOOL    IsShared = {read = get_IsShared};
  __property   Speechlib_tlb::SpeechRecognizerState State = {read = get_State, write = set_State};
  __property   Speechlib_tlb::ISpeechRecognizerStatusPtr Status = {read = get_Status};
  __property   Speechlib_tlb::ISpeechObjectToken* Profile = {write = _set_Profile};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechRecognizerStatus
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {BFF9E781-53EC-484E-BB8A-0E1B5551E35C}
// *********************************************************************//
interface ISpeechRecognizerStatus  : public IDispatch
{
public:
  // [1] AudioStatus
  virtual HRESULT STDMETHODCALLTYPE get_AudioStatus(Speechlib_tlb::ISpeechAudioStatus** AudioStatus/*[out,retval]*/) = 0;
  // [2] CurrentStreamPosition
  virtual HRESULT STDMETHODCALLTYPE get_CurrentStreamPosition(VARIANT* pCurrentStreamPos/*[out,retval]*/) = 0;
  // [3] CurrentStreamNumber
  virtual HRESULT STDMETHODCALLTYPE get_CurrentStreamNumber(long* StreamNumber/*[out,retval]*/) = 0;
  // [4] NumberOfActiveRules
  virtual HRESULT STDMETHODCALLTYPE get_NumberOfActiveRules(long* NumberOfActiveRules/*[out,retval]*/) = 0;
  // [5] ClsidEngine
  virtual HRESULT STDMETHODCALLTYPE get_ClsidEngine(BSTR* ClsidEngine/*[out,retval]*/) = 0;
  // [6] SupportedLanguages
  virtual HRESULT STDMETHODCALLTYPE get_SupportedLanguages(VARIANT* SupportedLanguages/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  Speechlib_tlb::ISpeechAudioStatusPtr __fastcall get_AudioStatus(void)
  {
    Speechlib_tlb::ISpeechAudioStatusPtr AudioStatus;
    OLECHECK(this->get_AudioStatus(&AudioStatus));
    return AudioStatus;
  }

  VARIANT __fastcall get_CurrentStreamPosition(void)
  {
    VARIANT pCurrentStreamPos;
    OLECHECK(this->get_CurrentStreamPosition((VARIANT*)&pCurrentStreamPos));
    return pCurrentStreamPos;
  }

  long __fastcall get_CurrentStreamNumber(void)
  {
    long StreamNumber;
    OLECHECK(this->get_CurrentStreamNumber((long*)&StreamNumber));
    return StreamNumber;
  }

  long __fastcall get_NumberOfActiveRules(void)
  {
    long NumberOfActiveRules;
    OLECHECK(this->get_NumberOfActiveRules((long*)&NumberOfActiveRules));
    return NumberOfActiveRules;
  }

  BSTR __fastcall get_ClsidEngine(void)
  {
    BSTR ClsidEngine = 0;
    OLECHECK(this->get_ClsidEngine((BSTR*)&ClsidEngine));
    return ClsidEngine;
  }

  VARIANT __fastcall get_SupportedLanguages(void)
  {
    VARIANT SupportedLanguages;
    OLECHECK(this->get_SupportedLanguages((VARIANT*)&SupportedLanguages));
    return SupportedLanguages;
  }


  __property   Speechlib_tlb::ISpeechAudioStatusPtr AudioStatus = {read = get_AudioStatus};
  __property   long            CurrentStreamNumber = {read = get_CurrentStreamNumber};
  __property   long            NumberOfActiveRules = {read = get_NumberOfActiveRules};
  __property   BSTR            ClsidEngine = {read = get_ClsidEngine};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechRecoContext
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {580AA49D-7E1E-4809-B8E2-57DA806104B8}
// *********************************************************************//
interface ISpeechRecoContext  : public IDispatch
{
public:
  // [1] Recognizer
  virtual HRESULT STDMETHODCALLTYPE get_Recognizer(Speechlib_tlb::ISpeechRecognizer** Recognizer/*[out,retval]*/) = 0;
  // [2] AudioInInterferenceStatus
  virtual HRESULT STDMETHODCALLTYPE get_AudioInputInterferenceStatus(Speechlib_tlb::SpeechInterference* Interference/*[out,retval]*/) = 0;
  // [3] RequestedUIType
  virtual HRESULT STDMETHODCALLTYPE get_RequestedUIType(BSTR* UIType/*[out,retval]*/) = 0;
  // [4] Voice
  virtual HRESULT STDMETHODCALLTYPE _set_Voice(Speechlib_tlb::ISpeechVoice* Voice/*[in]*/) = 0;
  // [4] Voice
  virtual HRESULT STDMETHODCALLTYPE get_Voice(Speechlib_tlb::ISpeechVoice** Voice/*[out,retval]*/) = 0;
  // [5] AllowVoiceFormatMatchingOnNextSet
  virtual HRESULT STDMETHODCALLTYPE set_AllowVoiceFormatMatchingOnNextSet(VARIANT_BOOL pAllow/*[in]*/) = 0;
  // [5] AllowVoiceFormatMatchingOnNextSet
  virtual HRESULT STDMETHODCALLTYPE get_AllowVoiceFormatMatchingOnNextSet(VARIANT_BOOL* pAllow/*[out,retval]*/) = 0;
  // [6] VoicePurgeEvent
  virtual HRESULT STDMETHODCALLTYPE set_VoicePurgeEvent(Speechlib_tlb::SpeechRecoEvents EventInterest/*[in]*/) = 0;
  // [6] VoicePurgeEvent
  virtual HRESULT STDMETHODCALLTYPE get_VoicePurgeEvent(Speechlib_tlb::SpeechRecoEvents* EventInterest/*[out,retval]*/) = 0;
  // [7] EventInterests
  virtual HRESULT STDMETHODCALLTYPE set_EventInterests(Speechlib_tlb::SpeechRecoEvents EventInterest/*[in]*/) = 0;
  // [7] EventInterests
  virtual HRESULT STDMETHODCALLTYPE get_EventInterests(Speechlib_tlb::SpeechRecoEvents* EventInterest/*[out,retval]*/) = 0;
  // [8] CmdMaxAlternates
  virtual HRESULT STDMETHODCALLTYPE set_CmdMaxAlternates(long MaxAlternates/*[in]*/) = 0;
  // [8] CmdMaxAlternates
  virtual HRESULT STDMETHODCALLTYPE get_CmdMaxAlternates(long* MaxAlternates/*[out,retval]*/) = 0;
  // [9] State
  virtual HRESULT STDMETHODCALLTYPE set_State(Speechlib_tlb::SpeechRecoContextState State/*[in]*/) = 0;
  // [9] State
  virtual HRESULT STDMETHODCALLTYPE get_State(Speechlib_tlb::SpeechRecoContextState* State/*[out,retval]*/) = 0;
  // [10] RetainedAudio
  virtual HRESULT STDMETHODCALLTYPE set_RetainedAudio(Speechlib_tlb::SpeechRetainedAudioOptions Option/*[in]*/) = 0;
  // [10] RetainedAudio
  virtual HRESULT STDMETHODCALLTYPE get_RetainedAudio(Speechlib_tlb::SpeechRetainedAudioOptions* Option/*[out,retval]*/) = 0;
  // [11] RetainedAudioFormat
  virtual HRESULT STDMETHODCALLTYPE _set_RetainedAudioFormat(Speechlib_tlb::ISpeechAudioFormat* Format/*[in]*/) = 0;
  // [11] RetainedAudioFormat
  virtual HRESULT STDMETHODCALLTYPE get_RetainedAudioFormat(Speechlib_tlb::ISpeechAudioFormat** Format/*[out,retval]*/) = 0;
  // [12] Pause
  virtual HRESULT STDMETHODCALLTYPE Pause(void) = 0;
  // [13] Resume
  virtual HRESULT STDMETHODCALLTYPE Resume(void) = 0;
  // [14] CreateGrammar
  virtual HRESULT STDMETHODCALLTYPE CreateGrammar(VARIANT GrammarId/*[in,def,opt]*/, 
                                                  Speechlib_tlb::ISpeechRecoGrammar** Grammar/*[out,retval]*/) = 0;
  // [15] CreateResultFromMemory
  virtual HRESULT STDMETHODCALLTYPE CreateResultFromMemory(VARIANT* ResultBlock/*[in]*/, 
                                                           Speechlib_tlb::ISpeechRecoResult** Result/*[out,retval]*/) = 0;
  // [16] Bookmark
  virtual HRESULT STDMETHODCALLTYPE Bookmark(Speechlib_tlb::SpeechBookmarkOptions Options/*[in]*/, 
                                             VARIANT StreamPos/*[in]*/, VARIANT BookmarkId/*[in]*/) = 0;
  // [17] SetAdaptationData
  virtual HRESULT STDMETHODCALLTYPE SetAdaptationData(BSTR AdaptationString/*[in]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  Speechlib_tlb::ISpeechRecognizerPtr __fastcall get_Recognizer(void)
  {
    Speechlib_tlb::ISpeechRecognizerPtr Recognizer;
    OLECHECK(this->get_Recognizer(&Recognizer));
    return Recognizer;
  }

  Speechlib_tlb::SpeechInterference __fastcall get_AudioInputInterferenceStatus(void)
  {
    Speechlib_tlb::SpeechInterference Interference;
    OLECHECK(this->get_AudioInputInterferenceStatus((Speechlib_tlb::SpeechInterference*)&Interference));
    return Interference;
  }

  BSTR __fastcall get_RequestedUIType(void)
  {
    BSTR UIType = 0;
    OLECHECK(this->get_RequestedUIType((BSTR*)&UIType));
    return UIType;
  }

  Speechlib_tlb::ISpeechVoicePtr __fastcall get_Voice(void)
  {
    Speechlib_tlb::ISpeechVoicePtr Voice;
    OLECHECK(this->get_Voice(&Voice));
    return Voice;
  }

  VARIANT_BOOL __fastcall get_AllowVoiceFormatMatchingOnNextSet(void)
  {
    VARIANT_BOOL pAllow;
    OLECHECK(this->get_AllowVoiceFormatMatchingOnNextSet((VARIANT_BOOL*)&pAllow));
    return pAllow;
  }

  Speechlib_tlb::SpeechRecoEvents __fastcall get_VoicePurgeEvent(void)
  {
    Speechlib_tlb::SpeechRecoEvents EventInterest;
    OLECHECK(this->get_VoicePurgeEvent((Speechlib_tlb::SpeechRecoEvents*)&EventInterest));
    return EventInterest;
  }

  Speechlib_tlb::SpeechRecoEvents __fastcall get_EventInterests(void)
  {
    Speechlib_tlb::SpeechRecoEvents EventInterest;
    OLECHECK(this->get_EventInterests((Speechlib_tlb::SpeechRecoEvents*)&EventInterest));
    return EventInterest;
  }

  long __fastcall get_CmdMaxAlternates(void)
  {
    long MaxAlternates;
    OLECHECK(this->get_CmdMaxAlternates((long*)&MaxAlternates));
    return MaxAlternates;
  }

  Speechlib_tlb::SpeechRecoContextState __fastcall get_State(void)
  {
    Speechlib_tlb::SpeechRecoContextState State;
    OLECHECK(this->get_State((Speechlib_tlb::SpeechRecoContextState*)&State));
    return State;
  }

  Speechlib_tlb::SpeechRetainedAudioOptions __fastcall get_RetainedAudio(void)
  {
    Speechlib_tlb::SpeechRetainedAudioOptions Option;
    OLECHECK(this->get_RetainedAudio((Speechlib_tlb::SpeechRetainedAudioOptions*)&Option));
    return Option;
  }

  Speechlib_tlb::ISpeechAudioFormatPtr __fastcall get_RetainedAudioFormat(void)
  {
    Speechlib_tlb::ISpeechAudioFormatPtr Format;
    OLECHECK(this->get_RetainedAudioFormat(&Format));
    return Format;
  }

  Speechlib_tlb::ISpeechRecoGrammar* __fastcall CreateGrammar(VARIANT GrammarId/*[in,def,opt]*/= TNoParam())
  {
    Speechlib_tlb::ISpeechRecoGrammar* Grammar = 0;
    OLECHECK(this->CreateGrammar(GrammarId, (Speechlib_tlb::ISpeechRecoGrammar**)&Grammar));
    return Grammar;
  }

  Speechlib_tlb::ISpeechRecoResult* __fastcall CreateResultFromMemory(VARIANT* ResultBlock/*[in]*/)
  {
    Speechlib_tlb::ISpeechRecoResult* Result = 0;
    OLECHECK(this->CreateResultFromMemory(ResultBlock, (Speechlib_tlb::ISpeechRecoResult**)&Result));
    return Result;
  }


  __property   Speechlib_tlb::ISpeechRecognizerPtr Recognizer = {read = get_Recognizer};
  __property   Speechlib_tlb::SpeechInterference AudioInputInterferenceStatus = {read = get_AudioInputInterferenceStatus};
  __property   BSTR            RequestedUIType = {read = get_RequestedUIType};
  __property   Speechlib_tlb::ISpeechVoice* Voice = {write = _set_Voice};
  __property   VARIANT_BOOL    AllowVoiceFormatMatchingOnNextSet = {read = get_AllowVoiceFormatMatchingOnNextSet, write = set_AllowVoiceFormatMatchingOnNextSet};
  __property   Speechlib_tlb::SpeechRecoEvents VoicePurgeEvent = {read = get_VoicePurgeEvent, write = set_VoicePurgeEvent};
  __property   Speechlib_tlb::SpeechRecoEvents EventInterests = {read = get_EventInterests, write = set_EventInterests};
  __property   long            CmdMaxAlternates = {read = get_CmdMaxAlternates, write = set_CmdMaxAlternates};
  __property   Speechlib_tlb::SpeechRecoContextState State = {read = get_State, write = set_State};
  __property   Speechlib_tlb::SpeechRetainedAudioOptions RetainedAudio = {read = get_RetainedAudio, write = set_RetainedAudio};
  __property   Speechlib_tlb::ISpeechAudioFormat* RetainedAudioFormat = {write = _set_RetainedAudioFormat};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechRecoGrammar
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {B6D6F79F-2158-4E50-B5BC-9A9CCD852A09}
// *********************************************************************//
interface ISpeechRecoGrammar  : public IDispatch
{
public:
  // [1] Id
  virtual HRESULT STDMETHODCALLTYPE get_Id(VARIANT* Id/*[out,retval]*/) = 0;
  // [2] RecoContext
  virtual HRESULT STDMETHODCALLTYPE get_RecoContext(Speechlib_tlb::ISpeechRecoContext** RecoContext/*[out,retval]*/) = 0;
  // [3] State
  virtual HRESULT STDMETHODCALLTYPE set_State(Speechlib_tlb::SpeechGrammarState State/*[in]*/) = 0;
  // [3] State
  virtual HRESULT STDMETHODCALLTYPE get_State(Speechlib_tlb::SpeechGrammarState* State/*[out,retval]*/) = 0;
  // [4] Rules
  virtual HRESULT STDMETHODCALLTYPE get_Rules(Speechlib_tlb::ISpeechGrammarRules** Rules/*[out,retval]*/) = 0;
  // [5] Reset
  virtual HRESULT STDMETHODCALLTYPE Reset(long NewLanguage/*[in,def,opt]*/) = 0;
  // [7] CmdLoadFromFile
  virtual HRESULT STDMETHODCALLTYPE CmdLoadFromFile(BSTR FileName/*[in]*/, 
                                                    Speechlib_tlb::SpeechLoadOption LoadOption/*[in,def,opt]*/) = 0;
  // [8] CmdLoadFromObject
  virtual HRESULT STDMETHODCALLTYPE CmdLoadFromObject(BSTR ClassId/*[in]*/, BSTR GrammarName/*[in]*/, 
                                                      Speechlib_tlb::SpeechLoadOption LoadOption/*[in,def,opt]*/) = 0;
  // [9] CmdLoadFromResource
  virtual HRESULT STDMETHODCALLTYPE CmdLoadFromResource(long hModule/*[in]*/, 
                                                        VARIANT ResourceName/*[in]*/, 
                                                        VARIANT ResourceType/*[in]*/, 
                                                        long LanguageId/*[in]*/, 
                                                        Speechlib_tlb::SpeechLoadOption LoadOption/*[in,def,opt]*/) = 0;
  // [10] CmdLoadFromMemory
  virtual HRESULT STDMETHODCALLTYPE CmdLoadFromMemory(VARIANT GrammarData/*[in]*/, 
                                                      Speechlib_tlb::SpeechLoadOption LoadOption/*[in,def,opt]*/) = 0;
  // [11] CmdLoadFromProprietaryGrammar
  virtual HRESULT STDMETHODCALLTYPE CmdLoadFromProprietaryGrammar(BSTR ProprietaryGuid/*[in]*/, 
                                                                  BSTR ProprietaryString/*[in]*/, 
                                                                  VARIANT ProprietaryData/*[in]*/, 
                                                                  Speechlib_tlb::SpeechLoadOption LoadOption/*[in,def,opt]*/) = 0;
  // [12] CmdSetRuleState
  virtual HRESULT STDMETHODCALLTYPE CmdSetRuleState(BSTR Name/*[in]*/, 
                                                    Speechlib_tlb::SpeechRuleState State/*[in]*/) = 0;
  // [13] CmdSetRuleIdState
  virtual HRESULT STDMETHODCALLTYPE CmdSetRuleIdState(long RuleId/*[in]*/, 
                                                      Speechlib_tlb::SpeechRuleState State/*[in]*/) = 0;
  // [14] DictationLoad
  virtual HRESULT STDMETHODCALLTYPE DictationLoad(BSTR TopicName/*[in,def,opt]*/, 
                                                  Speechlib_tlb::SpeechLoadOption LoadOption/*[in,def,opt]*/) = 0;
  // [15] DictationUnload
  virtual HRESULT STDMETHODCALLTYPE DictationUnload(void) = 0;
  // [16] DictationSetState
  virtual HRESULT STDMETHODCALLTYPE DictationSetState(Speechlib_tlb::SpeechRuleState State/*[in]*/) = 0;
  // [17] SetWordSequenceData
  virtual HRESULT STDMETHODCALLTYPE SetWordSequenceData(BSTR Text/*[in]*/, long TextLength/*[in]*/, 
                                                        Speechlib_tlb::ISpeechTextSelectionInformation* Info/*[in]*/) = 0;
  // [18] SetTextSelection
  virtual HRESULT STDMETHODCALLTYPE SetTextSelection(Speechlib_tlb::ISpeechTextSelectionInformation* Info/*[in]*/) = 0;
  // [19] IsPronounceable
  virtual HRESULT STDMETHODCALLTYPE IsPronounceable(BSTR Word/*[in]*/, 
                                                    Speechlib_tlb::SpeechWordPronounceable* WordPronounceable/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  VARIANT __fastcall get_Id(void)
  {
    VARIANT Id;
    OLECHECK(this->get_Id((VARIANT*)&Id));
    return Id;
  }

  Speechlib_tlb::ISpeechRecoContextPtr __fastcall get_RecoContext(void)
  {
    Speechlib_tlb::ISpeechRecoContextPtr RecoContext;
    OLECHECK(this->get_RecoContext(&RecoContext));
    return RecoContext;
  }

  Speechlib_tlb::SpeechGrammarState __fastcall get_State(void)
  {
    Speechlib_tlb::SpeechGrammarState State;
    OLECHECK(this->get_State((Speechlib_tlb::SpeechGrammarState*)&State));
    return State;
  }

  Speechlib_tlb::ISpeechGrammarRulesPtr __fastcall get_Rules(void)
  {
    Speechlib_tlb::ISpeechGrammarRulesPtr Rules;
    OLECHECK(this->get_Rules(&Rules));
    return Rules;
  }

  Speechlib_tlb::SpeechWordPronounceable __fastcall IsPronounceable(BSTR Word/*[in]*/)
  {
    Speechlib_tlb::SpeechWordPronounceable WordPronounceable;
    OLECHECK(this->IsPronounceable(Word, (Speechlib_tlb::SpeechWordPronounceable*)&WordPronounceable));
    return WordPronounceable;
  }


  __property   Speechlib_tlb::ISpeechRecoContextPtr RecoContext = {read = get_RecoContext};
  __property   Speechlib_tlb::SpeechGrammarState State = {read = get_State, write = set_State};
  __property   Speechlib_tlb::ISpeechGrammarRulesPtr Rules = {read = get_Rules};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechGrammarRules
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {6FFA3B44-FC2D-40D1-8AFC-32911C7F1AD1}
// *********************************************************************//
interface ISpeechGrammarRules  : public IDispatch
{
public:
  // [1] Count
  virtual HRESULT STDMETHODCALLTYPE get_Count(long* Count/*[out,retval]*/) = 0;
  // [6] FindRule
  virtual HRESULT STDMETHODCALLTYPE FindRule(VARIANT RuleNameOrId/*[in]*/, 
                                             Speechlib_tlb::ISpeechGrammarRule** Rule/*[out,retval]*/) = 0;
  // [0] Item
  virtual HRESULT STDMETHODCALLTYPE Item(long Index/*[in]*/, 
                                         Speechlib_tlb::ISpeechGrammarRule** Rule/*[out,retval]*/) = 0;
  // [-4] Enumerates the alternates
  virtual HRESULT STDMETHODCALLTYPE get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/) = 0;
  // [2] Dynamic
  virtual HRESULT STDMETHODCALLTYPE get_Dynamic(VARIANT_BOOL* Dynamic/*[out,retval]*/) = 0;
  // [3] Add
  virtual HRESULT STDMETHODCALLTYPE Add(BSTR RuleName/*[in]*/, 
                                        Speechlib_tlb::SpeechRuleAttributes Attributes/*[in]*/, 
                                        long RuleId/*[in,def,opt]*/, 
                                        Speechlib_tlb::ISpeechGrammarRule** Rule/*[out,retval]*/) = 0;
  // [4] Commit
  virtual HRESULT STDMETHODCALLTYPE Commit(void) = 0;
  // [5] CommitAndSave
  virtual HRESULT STDMETHODCALLTYPE CommitAndSave(BSTR* ErrorText/*[out]*/, 
                                                  VARIANT* SaveStream/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  long __fastcall get_Count(void)
  {
    long Count;
    OLECHECK(this->get_Count((long*)&Count));
    return Count;
  }

  Speechlib_tlb::ISpeechGrammarRule* __fastcall FindRule(VARIANT RuleNameOrId/*[in]*/)
  {
    Speechlib_tlb::ISpeechGrammarRule* Rule = 0;
    OLECHECK(this->FindRule(RuleNameOrId, (Speechlib_tlb::ISpeechGrammarRule**)&Rule));
    return Rule;
  }

  Speechlib_tlb::ISpeechGrammarRule* __fastcall Item(long Index/*[in]*/)
  {
    Speechlib_tlb::ISpeechGrammarRule* Rule = 0;
    OLECHECK(this->Item(Index, (Speechlib_tlb::ISpeechGrammarRule**)&Rule));
    return Rule;
  }

  LPUNKNOWN __fastcall get__NewEnum(void)
  {
    LPUNKNOWN EnumVARIANT;
    OLECHECK(this->get__NewEnum((LPUNKNOWN*)&EnumVARIANT));
    return EnumVARIANT;
  }

  VARIANT_BOOL __fastcall get_Dynamic(void)
  {
    VARIANT_BOOL Dynamic;
    OLECHECK(this->get_Dynamic((VARIANT_BOOL*)&Dynamic));
    return Dynamic;
  }

  Speechlib_tlb::ISpeechGrammarRule* __fastcall Add(BSTR RuleName/*[in]*/, 
                                                    Speechlib_tlb::SpeechRuleAttributes Attributes/*[in]*/, 
                                                    long RuleId/*[in,def,opt]*/)
  {
    Speechlib_tlb::ISpeechGrammarRule* Rule = 0;
    OLECHECK(this->Add(RuleName, Attributes, RuleId, (Speechlib_tlb::ISpeechGrammarRule**)&Rule));
    return Rule;
  }

  VARIANT __fastcall CommitAndSave(BSTR* ErrorText/*[out]*/)
  {
    VARIANT SaveStream;
    OLECHECK(this->CommitAndSave(ErrorText, (VARIANT*)&SaveStream));
    return SaveStream;
  }


  __property   long            Count = {read = get_Count};
  __property   LPUNKNOWN       _NewEnum = {read = get__NewEnum};
  __property   VARIANT_BOOL    Dynamic = {read = get_Dynamic};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechGrammarRule
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {AFE719CF-5DD1-44F2-999C-7A399F1CFCCC}
// *********************************************************************//
interface ISpeechGrammarRule  : public IDispatch
{
public:
  // [1] RuleAttributes
  virtual HRESULT STDMETHODCALLTYPE get_Attributes(Speechlib_tlb::SpeechRuleAttributes* Attributes/*[out,retval]*/) = 0;
  // [2] InitialState
  virtual HRESULT STDMETHODCALLTYPE get_InitialState(Speechlib_tlb::ISpeechGrammarRuleState** State/*[out,retval]*/) = 0;
  // [3] Name
  virtual HRESULT STDMETHODCALLTYPE get_Name(BSTR* Name/*[out,retval]*/) = 0;
  // [4] Id
  virtual HRESULT STDMETHODCALLTYPE get_Id(long* Id/*[out,retval]*/) = 0;
  // [5] Clear
  virtual HRESULT STDMETHODCALLTYPE Clear(void) = 0;
  // [6] AddResource
  virtual HRESULT STDMETHODCALLTYPE AddResource(BSTR ResourceName/*[in]*/, 
                                                BSTR ResourceValue/*[in]*/) = 0;
  // [7] AddState
  virtual HRESULT STDMETHODCALLTYPE AddState(Speechlib_tlb::ISpeechGrammarRuleState** State/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  Speechlib_tlb::SpeechRuleAttributes __fastcall get_Attributes(void)
  {
    Speechlib_tlb::SpeechRuleAttributes Attributes;
    OLECHECK(this->get_Attributes((Speechlib_tlb::SpeechRuleAttributes*)&Attributes));
    return Attributes;
  }

  Speechlib_tlb::ISpeechGrammarRuleStatePtr __fastcall get_InitialState(void)
  {
    Speechlib_tlb::ISpeechGrammarRuleStatePtr State;
    OLECHECK(this->get_InitialState(&State));
    return State;
  }

  BSTR __fastcall get_Name(void)
  {
    BSTR Name = 0;
    OLECHECK(this->get_Name((BSTR*)&Name));
    return Name;
  }

  long __fastcall get_Id(void)
  {
    long Id;
    OLECHECK(this->get_Id((long*)&Id));
    return Id;
  }

  Speechlib_tlb::ISpeechGrammarRuleState* __fastcall AddState(void)
  {
    Speechlib_tlb::ISpeechGrammarRuleState* State = 0;
    OLECHECK(this->AddState((Speechlib_tlb::ISpeechGrammarRuleState**)&State));
    return State;
  }


  __property   Speechlib_tlb::SpeechRuleAttributes Attributes = {read = get_Attributes};
  __property   Speechlib_tlb::ISpeechGrammarRuleStatePtr InitialState = {read = get_InitialState};
  __property   BSTR            Name = {read = get_Name};
  __property   long            Id = {read = get_Id};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechGrammarRuleState
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {D4286F2C-EE67-45AE-B928-28D695362EDA}
// *********************************************************************//
interface ISpeechGrammarRuleState  : public IDispatch
{
public:
  // [1] Rule
  virtual HRESULT STDMETHODCALLTYPE get_Rule(Speechlib_tlb::ISpeechGrammarRule** Rule/*[out,retval]*/) = 0;
  // [2] Transitions
  virtual HRESULT STDMETHODCALLTYPE get_Transitions(Speechlib_tlb::ISpeechGrammarRuleStateTransitions** Transitions/*[out,retval]*/) = 0;
  // [3] AddWordTransition
  virtual HRESULT STDMETHODCALLTYPE AddWordTransition(Speechlib_tlb::ISpeechGrammarRuleState* DestState/*[in]*/, 
                                                      BSTR Words/*[in]*/, 
                                                      BSTR Separators/*[in,def,opt]*/, 
                                                      Speechlib_tlb::SpeechGrammarWordType Type/*[in,def,opt]*/, 
                                                      BSTR PropertyName/*[in,def,opt]*/, 
                                                      long PropertyId/*[in,def,opt]*/, 
                                                      VARIANT* PropertyValue/*[in,def,opt]*/, 
                                                      float Weight/*[in,def,opt]*/) = 0;
  // [4] AddRuleTransition
  virtual HRESULT STDMETHODCALLTYPE AddRuleTransition(Speechlib_tlb::ISpeechGrammarRuleState* DestinationState/*[in]*/, 
                                                      Speechlib_tlb::ISpeechGrammarRule* Rule/*[in]*/, 
                                                      BSTR PropertyName/*[in,def,opt]*/, 
                                                      long PropertyId/*[in,def,opt]*/, 
                                                      VARIANT* PropertyValue/*[in,def,opt]*/, 
                                                      float Weight/*[in,def,opt]*/) = 0;
  // [5] AddSpecialTransition
  virtual HRESULT STDMETHODCALLTYPE AddSpecialTransition(Speechlib_tlb::ISpeechGrammarRuleState* DestinationState/*[in]*/, 
                                                         Speechlib_tlb::SpeechSpecialTransitionType Type/*[in]*/, 
                                                         BSTR PropertyName/*[in,def,opt]*/, 
                                                         long PropertyId/*[in,def,opt]*/, 
                                                         VARIANT* PropertyValue/*[in,def,opt]*/, 
                                                         float Weight/*[in,def,opt]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  Speechlib_tlb::ISpeechGrammarRulePtr __fastcall get_Rule(void)
  {
    Speechlib_tlb::ISpeechGrammarRulePtr Rule;
    OLECHECK(this->get_Rule(&Rule));
    return Rule;
  }

  Speechlib_tlb::ISpeechGrammarRuleStateTransitionsPtr __fastcall get_Transitions(void)
  {
    Speechlib_tlb::ISpeechGrammarRuleStateTransitionsPtr Transitions;
    OLECHECK(this->get_Transitions(&Transitions));
    return Transitions;
  }


  __property   Speechlib_tlb::ISpeechGrammarRulePtr Rule = {read = get_Rule};
  __property   Speechlib_tlb::ISpeechGrammarRuleStateTransitionsPtr Transitions = {read = get_Transitions};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechGrammarRuleStateTransitions
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {EABCE657-75BC-44A2-AA7F-C56476742963}
// *********************************************************************//
interface ISpeechGrammarRuleStateTransitions  : public IDispatch
{
public:
  // [1] Count
  virtual HRESULT STDMETHODCALLTYPE get_Count(long* Count/*[out,retval]*/) = 0;
  // [0] Item
  virtual HRESULT STDMETHODCALLTYPE Item(long Index/*[in]*/, 
                                         Speechlib_tlb::ISpeechGrammarRuleStateTransition** Transition/*[out,retval]*/) = 0;
  // [-4] Enumerates the transitions
  virtual HRESULT STDMETHODCALLTYPE get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  long __fastcall get_Count(void)
  {
    long Count;
    OLECHECK(this->get_Count((long*)&Count));
    return Count;
  }

  Speechlib_tlb::ISpeechGrammarRuleStateTransition* __fastcall Item(long Index/*[in]*/)
  {
    Speechlib_tlb::ISpeechGrammarRuleStateTransition* Transition = 0;
    OLECHECK(this->Item(Index, (Speechlib_tlb::ISpeechGrammarRuleStateTransition**)&Transition));
    return Transition;
  }

  LPUNKNOWN __fastcall get__NewEnum(void)
  {
    LPUNKNOWN EnumVARIANT;
    OLECHECK(this->get__NewEnum((LPUNKNOWN*)&EnumVARIANT));
    return EnumVARIANT;
  }


  __property   long            Count = {read = get_Count};
  __property   LPUNKNOWN       _NewEnum = {read = get__NewEnum};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechGrammarRuleStateTransition
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {CAFD1DB1-41D1-4A06-9863-E2E81DA17A9A}
// *********************************************************************//
interface ISpeechGrammarRuleStateTransition  : public IDispatch
{
public:
  // [1] Type
  virtual HRESULT STDMETHODCALLTYPE get_Type(Speechlib_tlb::SpeechGrammarRuleStateTransitionType* Type/*[out,retval]*/) = 0;
  // [2] Text
  virtual HRESULT STDMETHODCALLTYPE get_Text(BSTR* Text/*[out,retval]*/) = 0;
  // [3] Rule
  virtual HRESULT STDMETHODCALLTYPE get_Rule(Speechlib_tlb::ISpeechGrammarRule** Rule/*[out,retval]*/) = 0;
  // [4] Weight
  virtual HRESULT STDMETHODCALLTYPE get_Weight(VARIANT* Weight/*[out,retval]*/) = 0;
  // [5] PropertyName
  virtual HRESULT STDMETHODCALLTYPE get_PropertyName(BSTR* PropertyName/*[out,retval]*/) = 0;
  // [6] PropertyId
  virtual HRESULT STDMETHODCALLTYPE get_PropertyId(long* PropertyId/*[out,retval]*/) = 0;
  // [7] PropertyValue
  virtual HRESULT STDMETHODCALLTYPE get_PropertyValue(VARIANT* PropertyValue/*[out,retval]*/) = 0;
  // [8] NextState
  virtual HRESULT STDMETHODCALLTYPE get_NextState(Speechlib_tlb::ISpeechGrammarRuleState** NextState/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  Speechlib_tlb::SpeechGrammarRuleStateTransitionType __fastcall get_Type(void)
  {
    Speechlib_tlb::SpeechGrammarRuleStateTransitionType Type;
    OLECHECK(this->get_Type((Speechlib_tlb::SpeechGrammarRuleStateTransitionType*)&Type));
    return Type;
  }

  BSTR __fastcall get_Text(void)
  {
    BSTR Text = 0;
    OLECHECK(this->get_Text((BSTR*)&Text));
    return Text;
  }

  Speechlib_tlb::ISpeechGrammarRulePtr __fastcall get_Rule(void)
  {
    Speechlib_tlb::ISpeechGrammarRulePtr Rule;
    OLECHECK(this->get_Rule(&Rule));
    return Rule;
  }

  VARIANT __fastcall get_Weight(void)
  {
    VARIANT Weight;
    OLECHECK(this->get_Weight((VARIANT*)&Weight));
    return Weight;
  }

  BSTR __fastcall get_PropertyName(void)
  {
    BSTR PropertyName = 0;
    OLECHECK(this->get_PropertyName((BSTR*)&PropertyName));
    return PropertyName;
  }

  long __fastcall get_PropertyId(void)
  {
    long PropertyId;
    OLECHECK(this->get_PropertyId((long*)&PropertyId));
    return PropertyId;
  }

  VARIANT __fastcall get_PropertyValue(void)
  {
    VARIANT PropertyValue;
    OLECHECK(this->get_PropertyValue((VARIANT*)&PropertyValue));
    return PropertyValue;
  }

  Speechlib_tlb::ISpeechGrammarRuleStatePtr __fastcall get_NextState(void)
  {
    Speechlib_tlb::ISpeechGrammarRuleStatePtr NextState;
    OLECHECK(this->get_NextState(&NextState));
    return NextState;
  }


  __property   Speechlib_tlb::SpeechGrammarRuleStateTransitionType Type = {read = get_Type};
  __property   BSTR            Text = {read = get_Text};
  __property   Speechlib_tlb::ISpeechGrammarRulePtr Rule = {read = get_Rule};
  __property   BSTR            PropertyName = {read = get_PropertyName};
  __property   long            PropertyId = {read = get_PropertyId};
  __property   Speechlib_tlb::ISpeechGrammarRuleStatePtr NextState = {read = get_NextState};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechTextSelectionInformation
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {3B9C7E7A-6EEE-4DED-9092-11657279ADBE}
// *********************************************************************//
interface ISpeechTextSelectionInformation  : public IDispatch
{
public:
  // [1] ActiveOffset
  virtual HRESULT STDMETHODCALLTYPE set_ActiveOffset(long ActiveOffset/*[in]*/) = 0;
  // [1] ActiveOffset
  virtual HRESULT STDMETHODCALLTYPE get_ActiveOffset(long* ActiveOffset/*[out,retval]*/) = 0;
  // [2] ActiveLength
  virtual HRESULT STDMETHODCALLTYPE set_ActiveLength(long ActiveLength/*[in]*/) = 0;
  // [2] ActiveLength
  virtual HRESULT STDMETHODCALLTYPE get_ActiveLength(long* ActiveLength/*[out,retval]*/) = 0;
  // [3] SelectionOffset
  virtual HRESULT STDMETHODCALLTYPE set_SelectionOffset(long SelectionOffset/*[in]*/) = 0;
  // [3] SelectionOffset
  virtual HRESULT STDMETHODCALLTYPE get_SelectionOffset(long* SelectionOffset/*[out,retval]*/) = 0;
  // [4] SelectionLength
  virtual HRESULT STDMETHODCALLTYPE set_SelectionLength(long SelectionLength/*[in]*/) = 0;
  // [4] SelectionLength
  virtual HRESULT STDMETHODCALLTYPE get_SelectionLength(long* SelectionLength/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  long __fastcall get_ActiveOffset(void)
  {
    long ActiveOffset;
    OLECHECK(this->get_ActiveOffset((long*)&ActiveOffset));
    return ActiveOffset;
  }

  long __fastcall get_ActiveLength(void)
  {
    long ActiveLength;
    OLECHECK(this->get_ActiveLength((long*)&ActiveLength));
    return ActiveLength;
  }

  long __fastcall get_SelectionOffset(void)
  {
    long SelectionOffset;
    OLECHECK(this->get_SelectionOffset((long*)&SelectionOffset));
    return SelectionOffset;
  }

  long __fastcall get_SelectionLength(void)
  {
    long SelectionLength;
    OLECHECK(this->get_SelectionLength((long*)&SelectionLength));
    return SelectionLength;
  }


  __property   long            ActiveOffset = {read = get_ActiveOffset, write = set_ActiveOffset};
  __property   long            ActiveLength = {read = get_ActiveLength, write = set_ActiveLength};
  __property   long            SelectionOffset = {read = get_SelectionOffset, write = set_SelectionOffset};
  __property   long            SelectionLength = {read = get_SelectionLength, write = set_SelectionLength};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechRecoResult
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {ED2879CF-CED9-4EE6-A534-DE0191D5468D}
// *********************************************************************//
interface ISpeechRecoResult  : public IDispatch
{
public:
  // [1] RecoContext
  virtual HRESULT STDMETHODCALLTYPE get_RecoContext(Speechlib_tlb::ISpeechRecoContext** RecoContext/*[out,retval]*/) = 0;
  // [2] Times
  virtual HRESULT STDMETHODCALLTYPE get_Times(Speechlib_tlb::ISpeechRecoResultTimes** Times/*[out,retval]*/) = 0;
  // [3] AudioFormat
  virtual HRESULT STDMETHODCALLTYPE _set_AudioFormat(Speechlib_tlb::ISpeechAudioFormat* Format/*[in]*/) = 0;
  // [3] AudioFormat
  virtual HRESULT STDMETHODCALLTYPE get_AudioFormat(Speechlib_tlb::ISpeechAudioFormat** Format/*[out,retval]*/) = 0;
  // [4] PhraseInfo
  virtual HRESULT STDMETHODCALLTYPE get_PhraseInfo(Speechlib_tlb::ISpeechPhraseInfo** PhraseInfo/*[out,retval]*/) = 0;
  // [5] Alternates
  virtual HRESULT STDMETHODCALLTYPE Alternates(long RequestCount/*[in]*/, 
                                               long StartElement/*[in,def,opt]*/, 
                                               long Elements/*[in,def,opt]*/, 
                                               Speechlib_tlb::ISpeechPhraseAlternates** Alternates/*[out,retval]*/) = 0;
  // [6] Audio
  virtual HRESULT STDMETHODCALLTYPE Audio(long StartElement/*[in,def,opt]*/, 
                                          long Elements/*[in,def,opt]*/, 
                                          Speechlib_tlb::ISpeechMemoryStream** Stream/*[out,retval]*/) = 0;
  // [7] SpeakAudio
  virtual HRESULT STDMETHODCALLTYPE SpeakAudio(long StartElement/*[in,def,opt]*/, 
                                               long Elements/*[in,def,opt]*/, 
                                               Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/, 
                                               long* StreamNumber/*[out,retval]*/) = 0;
  // [8] SaveToMemory
  virtual HRESULT STDMETHODCALLTYPE SaveToMemory(VARIANT* ResultBlock/*[out,retval]*/) = 0;
  // [9] DiscardResultInfo
  virtual HRESULT STDMETHODCALLTYPE DiscardResultInfo(Speechlib_tlb::SpeechDiscardType ValueTypes/*[in]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  Speechlib_tlb::ISpeechRecoContextPtr __fastcall get_RecoContext(void)
  {
    Speechlib_tlb::ISpeechRecoContextPtr RecoContext;
    OLECHECK(this->get_RecoContext(&RecoContext));
    return RecoContext;
  }

  Speechlib_tlb::ISpeechRecoResultTimesPtr __fastcall get_Times(void)
  {
    Speechlib_tlb::ISpeechRecoResultTimesPtr Times;
    OLECHECK(this->get_Times(&Times));
    return Times;
  }

  Speechlib_tlb::ISpeechAudioFormatPtr __fastcall get_AudioFormat(void)
  {
    Speechlib_tlb::ISpeechAudioFormatPtr Format;
    OLECHECK(this->get_AudioFormat(&Format));
    return Format;
  }

  Speechlib_tlb::ISpeechPhraseInfoPtr __fastcall get_PhraseInfo(void)
  {
    Speechlib_tlb::ISpeechPhraseInfoPtr PhraseInfo;
    OLECHECK(this->get_PhraseInfo(&PhraseInfo));
    return PhraseInfo;
  }

  Speechlib_tlb::ISpeechPhraseAlternates* __fastcall Alternates(long RequestCount/*[in]*/, 
                                                                long StartElement/*[in,def,opt]*/, 
                                                                long Elements/*[in,def,opt]*/)
  {
    Speechlib_tlb::ISpeechPhraseAlternates* Alternates = 0;
    OLECHECK(this->Alternates(RequestCount, StartElement, Elements, (Speechlib_tlb::ISpeechPhraseAlternates**)&Alternates));
    return Alternates;
  }

  Speechlib_tlb::ISpeechMemoryStream* __fastcall Audio(long StartElement/*[in,def,opt]*/, 
                                                       long Elements/*[in,def,opt]*/)
  {
    Speechlib_tlb::ISpeechMemoryStream* Stream = 0;
    OLECHECK(this->Audio(StartElement, Elements, (Speechlib_tlb::ISpeechMemoryStream**)&Stream));
    return Stream;
  }

  long __fastcall SpeakAudio(long StartElement/*[in,def,opt]*/, long Elements/*[in,def,opt]*/, 
                             Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/)
  {
    long StreamNumber;
    OLECHECK(this->SpeakAudio(StartElement, Elements, Flags, (long*)&StreamNumber));
    return StreamNumber;
  }

  VARIANT __fastcall SaveToMemory(void)
  {
    VARIANT ResultBlock;
    OLECHECK(this->SaveToMemory((VARIANT*)&ResultBlock));
    return ResultBlock;
  }


  __property   Speechlib_tlb::ISpeechRecoContextPtr RecoContext = {read = get_RecoContext};
  __property   Speechlib_tlb::ISpeechRecoResultTimesPtr Times = {read = get_Times};
  __property   Speechlib_tlb::ISpeechAudioFormat* AudioFormat = {write = _set_AudioFormat};
  __property   Speechlib_tlb::ISpeechPhraseInfoPtr PhraseInfo = {read = get_PhraseInfo};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechRecoResultTimes
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {62B3B8FB-F6E7-41BE-BDCB-056B1C29EFC0}
// *********************************************************************//
interface ISpeechRecoResultTimes  : public IDispatch
{
public:
  // [1] StreamTime
  virtual HRESULT STDMETHODCALLTYPE get_StreamTime(VARIANT* Time/*[out,retval]*/) = 0;
  // [2] Length
  virtual HRESULT STDMETHODCALLTYPE get_Length(VARIANT* Length/*[out,retval]*/) = 0;
  // [3] TickCount
  virtual HRESULT STDMETHODCALLTYPE get_TickCount(long* TickCount/*[out,retval]*/) = 0;
  // [4] Start
  virtual HRESULT STDMETHODCALLTYPE get_OffsetFromStart(VARIANT* OffsetFromStart/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  VARIANT __fastcall get_StreamTime(void)
  {
    VARIANT Time;
    OLECHECK(this->get_StreamTime((VARIANT*)&Time));
    return Time;
  }

  VARIANT __fastcall get_Length(void)
  {
    VARIANT Length;
    OLECHECK(this->get_Length((VARIANT*)&Length));
    return Length;
  }

  long __fastcall get_TickCount(void)
  {
    long TickCount;
    OLECHECK(this->get_TickCount((long*)&TickCount));
    return TickCount;
  }

  VARIANT __fastcall get_OffsetFromStart(void)
  {
    VARIANT OffsetFromStart;
    OLECHECK(this->get_OffsetFromStart((VARIANT*)&OffsetFromStart));
    return OffsetFromStart;
  }


  __property   long            TickCount = {read = get_TickCount};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechPhraseInfo
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {961559CF-4E67-4662-8BF0-D93F1FCD61B3}
// *********************************************************************//
interface ISpeechPhraseInfo  : public IDispatch
{
public:
  // [1] LanguageId
  virtual HRESULT STDMETHODCALLTYPE get_LanguageId(long* LanguageId/*[out,retval]*/) = 0;
  // [2] GrammarId
  virtual HRESULT STDMETHODCALLTYPE get_GrammarId(VARIANT* GrammarId/*[out,retval]*/) = 0;
  // [3] StartTime
  virtual HRESULT STDMETHODCALLTYPE get_StartTime(VARIANT* StartTime/*[out,retval]*/) = 0;
  // [4] AudioStreamPosition
  virtual HRESULT STDMETHODCALLTYPE get_AudioStreamPosition(VARIANT* AudioStreamPosition/*[out,retval]*/) = 0;
  // [5] AudioSizeBytes
  virtual HRESULT STDMETHODCALLTYPE get_AudioSizeBytes(long* pAudioSizeBytes/*[out,retval]*/) = 0;
  // [6] RetainedSizeBytes
  virtual HRESULT STDMETHODCALLTYPE get_RetainedSizeBytes(long* RetainedSizeBytes/*[out,retval]*/) = 0;
  // [7] AudioSizeTime
  virtual HRESULT STDMETHODCALLTYPE get_AudioSizeTime(long* AudioSizeTime/*[out,retval]*/) = 0;
  // [8] Rule
  virtual HRESULT STDMETHODCALLTYPE get_Rule(Speechlib_tlb::ISpeechPhraseRule** Rule/*[out,retval]*/) = 0;
  // [9] Properties
  virtual HRESULT STDMETHODCALLTYPE get_Properties(Speechlib_tlb::ISpeechPhraseProperties** Properties/*[out,retval]*/) = 0;
  // [10] Elements
  virtual HRESULT STDMETHODCALLTYPE get_Elements(Speechlib_tlb::ISpeechPhraseElements** Elements/*[out,retval]*/) = 0;
  // [11] Replacements
  virtual HRESULT STDMETHODCALLTYPE get_Replacements(Speechlib_tlb::ISpeechPhraseReplacements** Replacements/*[out,retval]*/) = 0;
  // [12] EngineId
  virtual HRESULT STDMETHODCALLTYPE get_EngineId(BSTR* EngineIdGuid/*[out,retval]*/) = 0;
  // [13] EnginePrivateData
  virtual HRESULT STDMETHODCALLTYPE get_EnginePrivateData(VARIANT* PrivateData/*[out,retval]*/) = 0;
  // [14] SaveToMemory
  virtual HRESULT STDMETHODCALLTYPE SaveToMemory(VARIANT* PhraseBlock/*[out,retval]*/) = 0;
  // [15] GetText
  virtual HRESULT STDMETHODCALLTYPE GetText(long StartElement/*[in,def,opt]*/, 
                                            long Elements/*[in,def,opt]*/, 
                                            VARIANT_BOOL UseReplacements/*[in,def,opt]*/, 
                                            BSTR* Text/*[out,retval]*/) = 0;
  // [16] DisplayAttributes
  virtual HRESULT STDMETHODCALLTYPE GetDisplayAttributes(long StartElement/*[in,def,opt]*/, 
                                                         long Elements/*[in,def,opt]*/, 
                                                         VARIANT_BOOL UseReplacements/*[in,def,opt]*/, 
                                                         Speechlib_tlb::SpeechDisplayAttributes* DisplayAttributes/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  long __fastcall get_LanguageId(void)
  {
    long LanguageId;
    OLECHECK(this->get_LanguageId((long*)&LanguageId));
    return LanguageId;
  }

  VARIANT __fastcall get_GrammarId(void)
  {
    VARIANT GrammarId;
    OLECHECK(this->get_GrammarId((VARIANT*)&GrammarId));
    return GrammarId;
  }

  VARIANT __fastcall get_StartTime(void)
  {
    VARIANT StartTime;
    OLECHECK(this->get_StartTime((VARIANT*)&StartTime));
    return StartTime;
  }

  VARIANT __fastcall get_AudioStreamPosition(void)
  {
    VARIANT AudioStreamPosition;
    OLECHECK(this->get_AudioStreamPosition((VARIANT*)&AudioStreamPosition));
    return AudioStreamPosition;
  }

  long __fastcall get_AudioSizeBytes(void)
  {
    long pAudioSizeBytes;
    OLECHECK(this->get_AudioSizeBytes((long*)&pAudioSizeBytes));
    return pAudioSizeBytes;
  }

  long __fastcall get_RetainedSizeBytes(void)
  {
    long RetainedSizeBytes;
    OLECHECK(this->get_RetainedSizeBytes((long*)&RetainedSizeBytes));
    return RetainedSizeBytes;
  }

  long __fastcall get_AudioSizeTime(void)
  {
    long AudioSizeTime;
    OLECHECK(this->get_AudioSizeTime((long*)&AudioSizeTime));
    return AudioSizeTime;
  }

  Speechlib_tlb::ISpeechPhraseRulePtr __fastcall get_Rule(void)
  {
    Speechlib_tlb::ISpeechPhraseRulePtr Rule;
    OLECHECK(this->get_Rule(&Rule));
    return Rule;
  }

  Speechlib_tlb::ISpeechPhrasePropertiesPtr __fastcall get_Properties(void)
  {
    Speechlib_tlb::ISpeechPhrasePropertiesPtr Properties;
    OLECHECK(this->get_Properties(&Properties));
    return Properties;
  }

  Speechlib_tlb::ISpeechPhraseElementsPtr __fastcall get_Elements(void)
  {
    Speechlib_tlb::ISpeechPhraseElementsPtr Elements;
    OLECHECK(this->get_Elements(&Elements));
    return Elements;
  }

  Speechlib_tlb::ISpeechPhraseReplacementsPtr __fastcall get_Replacements(void)
  {
    Speechlib_tlb::ISpeechPhraseReplacementsPtr Replacements;
    OLECHECK(this->get_Replacements(&Replacements));
    return Replacements;
  }

  BSTR __fastcall get_EngineId(void)
  {
    BSTR EngineIdGuid = 0;
    OLECHECK(this->get_EngineId((BSTR*)&EngineIdGuid));
    return EngineIdGuid;
  }

  VARIANT __fastcall get_EnginePrivateData(void)
  {
    VARIANT PrivateData;
    OLECHECK(this->get_EnginePrivateData((VARIANT*)&PrivateData));
    return PrivateData;
  }

  VARIANT __fastcall SaveToMemory(void)
  {
    VARIANT PhraseBlock;
    OLECHECK(this->SaveToMemory((VARIANT*)&PhraseBlock));
    return PhraseBlock;
  }

  BSTR __fastcall GetText(long StartElement/*[in,def,opt]*/, long Elements/*[in,def,opt]*/, 
                          VARIANT_BOOL UseReplacements/*[in,def,opt]*/)
  {
    BSTR Text = 0;
    OLECHECK(this->GetText(StartElement, Elements, UseReplacements, (BSTR*)&Text));
    return Text;
  }

  Speechlib_tlb::SpeechDisplayAttributes __fastcall GetDisplayAttributes(long StartElement/*[in,def,opt]*/, 
                                                                         long Elements/*[in,def,opt]*/, 
                                                                         VARIANT_BOOL UseReplacements/*[in,def,opt]*/)
  {
    Speechlib_tlb::SpeechDisplayAttributes DisplayAttributes;
    OLECHECK(this->GetDisplayAttributes(StartElement, Elements, UseReplacements, (Speechlib_tlb::SpeechDisplayAttributes*)&DisplayAttributes));
    return DisplayAttributes;
  }


  __property   long            LanguageId = {read = get_LanguageId};
  __property   long            AudioSizeBytes = {read = get_AudioSizeBytes};
  __property   long            RetainedSizeBytes = {read = get_RetainedSizeBytes};
  __property   long            AudioSizeTime = {read = get_AudioSizeTime};
  __property   Speechlib_tlb::ISpeechPhraseRulePtr Rule = {read = get_Rule};
  __property   Speechlib_tlb::ISpeechPhrasePropertiesPtr Properties = {read = get_Properties};
  __property   Speechlib_tlb::ISpeechPhraseElementsPtr Elements = {read = get_Elements};
  __property   Speechlib_tlb::ISpeechPhraseReplacementsPtr Replacements = {read = get_Replacements};
  __property   BSTR            EngineId = {read = get_EngineId};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechPhraseRule
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {A7BFE112-A4A0-48D9-B602-C313843F6964}
// *********************************************************************//
interface ISpeechPhraseRule  : public IDispatch
{
public:
  // [1] Name
  virtual HRESULT STDMETHODCALLTYPE get_Name(BSTR* Name/*[out,retval]*/) = 0;
  // [2] Id
  virtual HRESULT STDMETHODCALLTYPE get_Id(long* Id/*[out,retval]*/) = 0;
  // [3] FirstElement
  virtual HRESULT STDMETHODCALLTYPE get_FirstElement(long* FirstElement/*[out,retval]*/) = 0;
  // [4] NumElements
  virtual HRESULT STDMETHODCALLTYPE get_NumberOfElements(long* NumberOfElements/*[out,retval]*/) = 0;
  // [5] Parent
  virtual HRESULT STDMETHODCALLTYPE get_Parent(Speechlib_tlb::ISpeechPhraseRule** Parent/*[out,retval]*/) = 0;
  // [6] Children
  virtual HRESULT STDMETHODCALLTYPE get_Children(Speechlib_tlb::ISpeechPhraseRules** Children/*[out,retval]*/) = 0;
  // [7] Confidence
  virtual HRESULT STDMETHODCALLTYPE get_Confidence(Speechlib_tlb::SpeechEngineConfidence* ActualConfidence/*[out,retval]*/) = 0;
  // [8] EngineConfidence
  virtual HRESULT STDMETHODCALLTYPE get_EngineConfidence(float* EngineConfidence/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  BSTR __fastcall get_Name(void)
  {
    BSTR Name = 0;
    OLECHECK(this->get_Name((BSTR*)&Name));
    return Name;
  }

  long __fastcall get_Id(void)
  {
    long Id;
    OLECHECK(this->get_Id((long*)&Id));
    return Id;
  }

  long __fastcall get_FirstElement(void)
  {
    long FirstElement;
    OLECHECK(this->get_FirstElement((long*)&FirstElement));
    return FirstElement;
  }

  long __fastcall get_NumberOfElements(void)
  {
    long NumberOfElements;
    OLECHECK(this->get_NumberOfElements((long*)&NumberOfElements));
    return NumberOfElements;
  }

  Speechlib_tlb::ISpeechPhraseRulePtr __fastcall get_Parent(void)
  {
    Speechlib_tlb::ISpeechPhraseRulePtr Parent;
    OLECHECK(this->get_Parent(&Parent));
    return Parent;
  }

  Speechlib_tlb::ISpeechPhraseRulesPtr __fastcall get_Children(void)
  {
    Speechlib_tlb::ISpeechPhraseRulesPtr Children;
    OLECHECK(this->get_Children(&Children));
    return Children;
  }

  Speechlib_tlb::SpeechEngineConfidence __fastcall get_Confidence(void)
  {
    Speechlib_tlb::SpeechEngineConfidence ActualConfidence;
    OLECHECK(this->get_Confidence((Speechlib_tlb::SpeechEngineConfidence*)&ActualConfidence));
    return ActualConfidence;
  }

  float __fastcall get_EngineConfidence(void)
  {
    float EngineConfidence;
    OLECHECK(this->get_EngineConfidence((float*)&EngineConfidence));
    return EngineConfidence;
  }


  __property   BSTR            Name = {read = get_Name};
  __property   long            Id = {read = get_Id};
  __property   long            FirstElement = {read = get_FirstElement};
  __property   long            NumberOfElements = {read = get_NumberOfElements};
  __property   Speechlib_tlb::ISpeechPhraseRulePtr Parent = {read = get_Parent};
  __property   Speechlib_tlb::ISpeechPhraseRulesPtr Children = {read = get_Children};
  __property   Speechlib_tlb::SpeechEngineConfidence Confidence = {read = get_Confidence};
  __property   float           EngineConfidence = {read = get_EngineConfidence};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechPhraseRules
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {9047D593-01DD-4B72-81A3-E4A0CA69F407}
// *********************************************************************//
interface ISpeechPhraseRules  : public IDispatch
{
public:
  // [1] Count
  virtual HRESULT STDMETHODCALLTYPE get_Count(long* Count/*[out,retval]*/) = 0;
  // [0] Item
  virtual HRESULT STDMETHODCALLTYPE Item(long Index/*[in]*/, 
                                         Speechlib_tlb::ISpeechPhraseRule** Rule/*[out,retval]*/) = 0;
  // [-4] Enumerates the Rules
  virtual HRESULT STDMETHODCALLTYPE get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  long __fastcall get_Count(void)
  {
    long Count;
    OLECHECK(this->get_Count((long*)&Count));
    return Count;
  }

  Speechlib_tlb::ISpeechPhraseRule* __fastcall Item(long Index/*[in]*/)
  {
    Speechlib_tlb::ISpeechPhraseRule* Rule = 0;
    OLECHECK(this->Item(Index, (Speechlib_tlb::ISpeechPhraseRule**)&Rule));
    return Rule;
  }

  LPUNKNOWN __fastcall get__NewEnum(void)
  {
    LPUNKNOWN EnumVARIANT;
    OLECHECK(this->get__NewEnum((LPUNKNOWN*)&EnumVARIANT));
    return EnumVARIANT;
  }


  __property   long            Count = {read = get_Count};
  __property   LPUNKNOWN       _NewEnum = {read = get__NewEnum};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechPhraseProperties
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {08166B47-102E-4B23-A599-BDB98DBFD1F4}
// *********************************************************************//
interface ISpeechPhraseProperties  : public IDispatch
{
public:
  // [1] Count
  virtual HRESULT STDMETHODCALLTYPE get_Count(long* Count/*[out,retval]*/) = 0;
  // [0] Item
  virtual HRESULT STDMETHODCALLTYPE Item(long Index/*[in]*/, 
                                         Speechlib_tlb::ISpeechPhraseProperty** Property/*[out,retval]*/) = 0;
  // [-4] Enumerates the alternates
  virtual HRESULT STDMETHODCALLTYPE get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  long __fastcall get_Count(void)
  {
    long Count;
    OLECHECK(this->get_Count((long*)&Count));
    return Count;
  }

  Speechlib_tlb::ISpeechPhraseProperty* __fastcall Item(long Index/*[in]*/)
  {
    Speechlib_tlb::ISpeechPhraseProperty* Property = 0;
    OLECHECK(this->Item(Index, (Speechlib_tlb::ISpeechPhraseProperty**)&Property));
    return Property;
  }

  LPUNKNOWN __fastcall get__NewEnum(void)
  {
    LPUNKNOWN EnumVARIANT;
    OLECHECK(this->get__NewEnum((LPUNKNOWN*)&EnumVARIANT));
    return EnumVARIANT;
  }


  __property   long            Count = {read = get_Count};
  __property   LPUNKNOWN       _NewEnum = {read = get__NewEnum};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechPhraseProperty
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {CE563D48-961E-4732-A2E1-378A42B430BE}
// *********************************************************************//
interface ISpeechPhraseProperty  : public IDispatch
{
public:
  // [1] Name
  virtual HRESULT STDMETHODCALLTYPE get_Name(BSTR* Name/*[out,retval]*/) = 0;
  // [2] Id
  virtual HRESULT STDMETHODCALLTYPE get_Id(long* Id/*[out,retval]*/) = 0;
  // [3] Value
  virtual HRESULT STDMETHODCALLTYPE get_Value(VARIANT* Value/*[out,retval]*/) = 0;
  // [4] FirstElement
  virtual HRESULT STDMETHODCALLTYPE get_FirstElement(long* FirstElement/*[out,retval]*/) = 0;
  // [5] NumberOfElements
  virtual HRESULT STDMETHODCALLTYPE get_NumberOfElements(long* NumberOfElements/*[out,retval]*/) = 0;
  // [6] EngineConfidence
  virtual HRESULT STDMETHODCALLTYPE get_EngineConfidence(float* Confidence/*[out,retval]*/) = 0;
  // [7] Confidence
  virtual HRESULT STDMETHODCALLTYPE get_Confidence(Speechlib_tlb::SpeechEngineConfidence* Confidence/*[out,retval]*/) = 0;
  // [8] Parent
  virtual HRESULT STDMETHODCALLTYPE get_Parent(Speechlib_tlb::ISpeechPhraseProperty** ParentProperty/*[out,retval]*/) = 0;
  // [9] Children
  virtual HRESULT STDMETHODCALLTYPE get_Children(Speechlib_tlb::ISpeechPhraseProperties** Children/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  BSTR __fastcall get_Name(void)
  {
    BSTR Name = 0;
    OLECHECK(this->get_Name((BSTR*)&Name));
    return Name;
  }

  long __fastcall get_Id(void)
  {
    long Id;
    OLECHECK(this->get_Id((long*)&Id));
    return Id;
  }

  VARIANT __fastcall get_Value(void)
  {
    VARIANT Value;
    OLECHECK(this->get_Value((VARIANT*)&Value));
    return Value;
  }

  long __fastcall get_FirstElement(void)
  {
    long FirstElement;
    OLECHECK(this->get_FirstElement((long*)&FirstElement));
    return FirstElement;
  }

  long __fastcall get_NumberOfElements(void)
  {
    long NumberOfElements;
    OLECHECK(this->get_NumberOfElements((long*)&NumberOfElements));
    return NumberOfElements;
  }

  float __fastcall get_EngineConfidence(void)
  {
    float Confidence;
    OLECHECK(this->get_EngineConfidence((float*)&Confidence));
    return Confidence;
  }

  Speechlib_tlb::SpeechEngineConfidence __fastcall get_Confidence(void)
  {
    Speechlib_tlb::SpeechEngineConfidence Confidence;
    OLECHECK(this->get_Confidence((Speechlib_tlb::SpeechEngineConfidence*)&Confidence));
    return Confidence;
  }

  Speechlib_tlb::ISpeechPhrasePropertyPtr __fastcall get_Parent(void)
  {
    Speechlib_tlb::ISpeechPhrasePropertyPtr ParentProperty;
    OLECHECK(this->get_Parent(&ParentProperty));
    return ParentProperty;
  }

  Speechlib_tlb::ISpeechPhrasePropertiesPtr __fastcall get_Children(void)
  {
    Speechlib_tlb::ISpeechPhrasePropertiesPtr Children;
    OLECHECK(this->get_Children(&Children));
    return Children;
  }


  __property   BSTR            Name = {read = get_Name};
  __property   long            Id = {read = get_Id};
  __property   long            FirstElement = {read = get_FirstElement};
  __property   long            NumberOfElements = {read = get_NumberOfElements};
  __property   float           EngineConfidence = {read = get_EngineConfidence};
  __property   Speechlib_tlb::SpeechEngineConfidence Confidence = {read = get_Confidence};
  __property   Speechlib_tlb::ISpeechPhrasePropertyPtr Parent = {read = get_Parent};
  __property   Speechlib_tlb::ISpeechPhrasePropertiesPtr Children = {read = get_Children};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechPhraseElements
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {0626B328-3478-467D-A0B3-D0853B93DDA3}
// *********************************************************************//
interface ISpeechPhraseElements  : public IDispatch
{
public:
  // [1] Count
  virtual HRESULT STDMETHODCALLTYPE get_Count(long* Count/*[out,retval]*/) = 0;
  // [0] Item
  virtual HRESULT STDMETHODCALLTYPE Item(long Index/*[in]*/, 
                                         Speechlib_tlb::ISpeechPhraseElement** Element/*[out,retval]*/) = 0;
  // [-4] Enumerates the tokens
  virtual HRESULT STDMETHODCALLTYPE get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  long __fastcall get_Count(void)
  {
    long Count;
    OLECHECK(this->get_Count((long*)&Count));
    return Count;
  }

  Speechlib_tlb::ISpeechPhraseElement* __fastcall Item(long Index/*[in]*/)
  {
    Speechlib_tlb::ISpeechPhraseElement* Element = 0;
    OLECHECK(this->Item(Index, (Speechlib_tlb::ISpeechPhraseElement**)&Element));
    return Element;
  }

  LPUNKNOWN __fastcall get__NewEnum(void)
  {
    LPUNKNOWN EnumVARIANT;
    OLECHECK(this->get__NewEnum((LPUNKNOWN*)&EnumVARIANT));
    return EnumVARIANT;
  }


  __property   long            Count = {read = get_Count};
  __property   LPUNKNOWN       _NewEnum = {read = get__NewEnum};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechPhraseElement
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {E6176F96-E373-4801-B223-3B62C068C0B4}
// *********************************************************************//
interface ISpeechPhraseElement  : public IDispatch
{
public:
  // [1] AudioTimeOffset
  virtual HRESULT STDMETHODCALLTYPE get_AudioTimeOffset(long* AudioTimeOffset/*[out,retval]*/) = 0;
  // [2] AudioSizeTime
  virtual HRESULT STDMETHODCALLTYPE get_AudioSizeTime(long* AudioSizeTime/*[out,retval]*/) = 0;
  // [3] AudioStreamOffset
  virtual HRESULT STDMETHODCALLTYPE get_AudioStreamOffset(long* AudioStreamOffset/*[out,retval]*/) = 0;
  // [4] AudioSizeBytes
  virtual HRESULT STDMETHODCALLTYPE get_AudioSizeBytes(long* AudioSizeBytes/*[out,retval]*/) = 0;
  // [5] RetainedStreamOffset
  virtual HRESULT STDMETHODCALLTYPE get_RetainedStreamOffset(long* RetainedStreamOffset/*[out,retval]*/) = 0;
  // [6] RetainedSizeBytes
  virtual HRESULT STDMETHODCALLTYPE get_RetainedSizeBytes(long* RetainedSizeBytes/*[out,retval]*/) = 0;
  // [7] DisplayText
  virtual HRESULT STDMETHODCALLTYPE get_DisplayText(BSTR* DisplayText/*[out,retval]*/) = 0;
  // [8] LexicalForm
  virtual HRESULT STDMETHODCALLTYPE get_LexicalForm(BSTR* LexicalForm/*[out,retval]*/) = 0;
  // [9] Pronunciation
  virtual HRESULT STDMETHODCALLTYPE get_Pronunciation(VARIANT* Pronunciation/*[out,retval]*/) = 0;
  // [10] DisplayAttributes
  virtual HRESULT STDMETHODCALLTYPE get_DisplayAttributes(Speechlib_tlb::SpeechDisplayAttributes* DisplayAttributes/*[out,retval]*/) = 0;
  // [11] RequiredConfidence
  virtual HRESULT STDMETHODCALLTYPE get_RequiredConfidence(Speechlib_tlb::SpeechEngineConfidence* RequiredConfidence/*[out,retval]*/) = 0;
  // [12] ActualConfidence
  virtual HRESULT STDMETHODCALLTYPE get_ActualConfidence(Speechlib_tlb::SpeechEngineConfidence* ActualConfidence/*[out,retval]*/) = 0;
  // [13] EngineConfidence
  virtual HRESULT STDMETHODCALLTYPE get_EngineConfidence(float* EngineConfidence/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  long __fastcall get_AudioTimeOffset(void)
  {
    long AudioTimeOffset;
    OLECHECK(this->get_AudioTimeOffset((long*)&AudioTimeOffset));
    return AudioTimeOffset;
  }

  long __fastcall get_AudioSizeTime(void)
  {
    long AudioSizeTime;
    OLECHECK(this->get_AudioSizeTime((long*)&AudioSizeTime));
    return AudioSizeTime;
  }

  long __fastcall get_AudioStreamOffset(void)
  {
    long AudioStreamOffset;
    OLECHECK(this->get_AudioStreamOffset((long*)&AudioStreamOffset));
    return AudioStreamOffset;
  }

  long __fastcall get_AudioSizeBytes(void)
  {
    long AudioSizeBytes;
    OLECHECK(this->get_AudioSizeBytes((long*)&AudioSizeBytes));
    return AudioSizeBytes;
  }

  long __fastcall get_RetainedStreamOffset(void)
  {
    long RetainedStreamOffset;
    OLECHECK(this->get_RetainedStreamOffset((long*)&RetainedStreamOffset));
    return RetainedStreamOffset;
  }

  long __fastcall get_RetainedSizeBytes(void)
  {
    long RetainedSizeBytes;
    OLECHECK(this->get_RetainedSizeBytes((long*)&RetainedSizeBytes));
    return RetainedSizeBytes;
  }

  BSTR __fastcall get_DisplayText(void)
  {
    BSTR DisplayText = 0;
    OLECHECK(this->get_DisplayText((BSTR*)&DisplayText));
    return DisplayText;
  }

  BSTR __fastcall get_LexicalForm(void)
  {
    BSTR LexicalForm = 0;
    OLECHECK(this->get_LexicalForm((BSTR*)&LexicalForm));
    return LexicalForm;
  }

  VARIANT __fastcall get_Pronunciation(void)
  {
    VARIANT Pronunciation;
    OLECHECK(this->get_Pronunciation((VARIANT*)&Pronunciation));
    return Pronunciation;
  }

  Speechlib_tlb::SpeechDisplayAttributes __fastcall get_DisplayAttributes(void)
  {
    Speechlib_tlb::SpeechDisplayAttributes DisplayAttributes;
    OLECHECK(this->get_DisplayAttributes((Speechlib_tlb::SpeechDisplayAttributes*)&DisplayAttributes));
    return DisplayAttributes;
  }

  Speechlib_tlb::SpeechEngineConfidence __fastcall get_RequiredConfidence(void)
  {
    Speechlib_tlb::SpeechEngineConfidence RequiredConfidence;
    OLECHECK(this->get_RequiredConfidence((Speechlib_tlb::SpeechEngineConfidence*)&RequiredConfidence));
    return RequiredConfidence;
  }

  Speechlib_tlb::SpeechEngineConfidence __fastcall get_ActualConfidence(void)
  {
    Speechlib_tlb::SpeechEngineConfidence ActualConfidence;
    OLECHECK(this->get_ActualConfidence((Speechlib_tlb::SpeechEngineConfidence*)&ActualConfidence));
    return ActualConfidence;
  }

  float __fastcall get_EngineConfidence(void)
  {
    float EngineConfidence;
    OLECHECK(this->get_EngineConfidence((float*)&EngineConfidence));
    return EngineConfidence;
  }


  __property   long            AudioTimeOffset = {read = get_AudioTimeOffset};
  __property   long            AudioSizeTime = {read = get_AudioSizeTime};
  __property   long            AudioStreamOffset = {read = get_AudioStreamOffset};
  __property   long            AudioSizeBytes = {read = get_AudioSizeBytes};
  __property   long            RetainedStreamOffset = {read = get_RetainedStreamOffset};
  __property   long            RetainedSizeBytes = {read = get_RetainedSizeBytes};
  __property   BSTR            DisplayText = {read = get_DisplayText};
  __property   BSTR            LexicalForm = {read = get_LexicalForm};
  __property   Speechlib_tlb::SpeechDisplayAttributes DisplayAttributes = {read = get_DisplayAttributes};
  __property   Speechlib_tlb::SpeechEngineConfidence RequiredConfidence = {read = get_RequiredConfidence};
  __property   Speechlib_tlb::SpeechEngineConfidence ActualConfidence = {read = get_ActualConfidence};
  __property   float           EngineConfidence = {read = get_EngineConfidence};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechPhraseReplacements
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {38BC662F-2257-4525-959E-2069D2596C05}
// *********************************************************************//
interface ISpeechPhraseReplacements  : public IDispatch
{
public:
  // [1] Count
  virtual HRESULT STDMETHODCALLTYPE get_Count(long* Count/*[out,retval]*/) = 0;
  // [0] Item
  virtual HRESULT STDMETHODCALLTYPE Item(long Index/*[in]*/, 
                                         Speechlib_tlb::ISpeechPhraseReplacement** Reps/*[out,retval]*/) = 0;
  // [-4] Enumerates the tokens
  virtual HRESULT STDMETHODCALLTYPE get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  long __fastcall get_Count(void)
  {
    long Count;
    OLECHECK(this->get_Count((long*)&Count));
    return Count;
  }

  Speechlib_tlb::ISpeechPhraseReplacement* __fastcall Item(long Index/*[in]*/)
  {
    Speechlib_tlb::ISpeechPhraseReplacement* Reps = 0;
    OLECHECK(this->Item(Index, (Speechlib_tlb::ISpeechPhraseReplacement**)&Reps));
    return Reps;
  }

  LPUNKNOWN __fastcall get__NewEnum(void)
  {
    LPUNKNOWN EnumVARIANT;
    OLECHECK(this->get__NewEnum((LPUNKNOWN*)&EnumVARIANT));
    return EnumVARIANT;
  }


  __property   long            Count = {read = get_Count};
  __property   LPUNKNOWN       _NewEnum = {read = get__NewEnum};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechPhraseReplacement
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {2890A410-53A7-4FB5-94EC-06D4998E3D02}
// *********************************************************************//
interface ISpeechPhraseReplacement  : public IDispatch
{
public:
  // [1] DisplayAttributes
  virtual HRESULT STDMETHODCALLTYPE get_DisplayAttributes(Speechlib_tlb::SpeechDisplayAttributes* DisplayAttributes/*[out,retval]*/) = 0;
  // [2] Text
  virtual HRESULT STDMETHODCALLTYPE get_Text(BSTR* Text/*[out,retval]*/) = 0;
  // [3] FirstElement
  virtual HRESULT STDMETHODCALLTYPE get_FirstElement(long* FirstElement/*[out,retval]*/) = 0;
  // [4] NumElements
  virtual HRESULT STDMETHODCALLTYPE get_NumberOfElements(long* NumberOfElements/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  Speechlib_tlb::SpeechDisplayAttributes __fastcall get_DisplayAttributes(void)
  {
    Speechlib_tlb::SpeechDisplayAttributes DisplayAttributes;
    OLECHECK(this->get_DisplayAttributes((Speechlib_tlb::SpeechDisplayAttributes*)&DisplayAttributes));
    return DisplayAttributes;
  }

  BSTR __fastcall get_Text(void)
  {
    BSTR Text = 0;
    OLECHECK(this->get_Text((BSTR*)&Text));
    return Text;
  }

  long __fastcall get_FirstElement(void)
  {
    long FirstElement;
    OLECHECK(this->get_FirstElement((long*)&FirstElement));
    return FirstElement;
  }

  long __fastcall get_NumberOfElements(void)
  {
    long NumberOfElements;
    OLECHECK(this->get_NumberOfElements((long*)&NumberOfElements));
    return NumberOfElements;
  }


  __property   Speechlib_tlb::SpeechDisplayAttributes DisplayAttributes = {read = get_DisplayAttributes};
  __property   BSTR            Text = {read = get_Text};
  __property   long            FirstElement = {read = get_FirstElement};
  __property   long            NumberOfElements = {read = get_NumberOfElements};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechPhraseAlternates
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {B238B6D5-F276-4C3D-A6C1-2974801C3CC2}
// *********************************************************************//
interface ISpeechPhraseAlternates  : public IDispatch
{
public:
  // [1] Count
  virtual HRESULT STDMETHODCALLTYPE get_Count(long* Count/*[out,retval]*/) = 0;
  // [0] Item
  virtual HRESULT STDMETHODCALLTYPE Item(long Index/*[in]*/, 
                                         Speechlib_tlb::ISpeechPhraseAlternate** PhraseAlternate/*[out,retval]*/) = 0;
  // [-4] Enumerates the alternates
  virtual HRESULT STDMETHODCALLTYPE get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  long __fastcall get_Count(void)
  {
    long Count;
    OLECHECK(this->get_Count((long*)&Count));
    return Count;
  }

  Speechlib_tlb::ISpeechPhraseAlternate* __fastcall Item(long Index/*[in]*/)
  {
    Speechlib_tlb::ISpeechPhraseAlternate* PhraseAlternate = 0;
    OLECHECK(this->Item(Index, (Speechlib_tlb::ISpeechPhraseAlternate**)&PhraseAlternate));
    return PhraseAlternate;
  }

  LPUNKNOWN __fastcall get__NewEnum(void)
  {
    LPUNKNOWN EnumVARIANT;
    OLECHECK(this->get__NewEnum((LPUNKNOWN*)&EnumVARIANT));
    return EnumVARIANT;
  }


  __property   long            Count = {read = get_Count};
  __property   LPUNKNOWN       _NewEnum = {read = get__NewEnum};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechPhraseAlternate
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {27864A2A-2B9F-4CB8-92D3-0D2722FD1E73}
// *********************************************************************//
interface ISpeechPhraseAlternate  : public IDispatch
{
public:
  // [1] RecoResult
  virtual HRESULT STDMETHODCALLTYPE get_RecoResult(Speechlib_tlb::ISpeechRecoResult** RecoResult/*[out,retval]*/) = 0;
  // [2] StartElementInResult
  virtual HRESULT STDMETHODCALLTYPE get_StartElementInResult(long* StartElement/*[out,retval]*/) = 0;
  // [3] NumberOfElementsInResult
  virtual HRESULT STDMETHODCALLTYPE get_NumberOfElementsInResult(long* NumberOfElements/*[out,retval]*/) = 0;
  // [4] Phrase
  virtual HRESULT STDMETHODCALLTYPE get_PhraseInfo(Speechlib_tlb::ISpeechPhraseInfo** PhraseInfo/*[out,retval]*/) = 0;
  // [5] Commit
  virtual HRESULT STDMETHODCALLTYPE Commit(void) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  Speechlib_tlb::ISpeechRecoResultPtr __fastcall get_RecoResult(void)
  {
    Speechlib_tlb::ISpeechRecoResultPtr RecoResult;
    OLECHECK(this->get_RecoResult(&RecoResult));
    return RecoResult;
  }

  long __fastcall get_StartElementInResult(void)
  {
    long StartElement;
    OLECHECK(this->get_StartElementInResult((long*)&StartElement));
    return StartElement;
  }

  long __fastcall get_NumberOfElementsInResult(void)
  {
    long NumberOfElements;
    OLECHECK(this->get_NumberOfElementsInResult((long*)&NumberOfElements));
    return NumberOfElements;
  }

  Speechlib_tlb::ISpeechPhraseInfoPtr __fastcall get_PhraseInfo(void)
  {
    Speechlib_tlb::ISpeechPhraseInfoPtr PhraseInfo;
    OLECHECK(this->get_PhraseInfo(&PhraseInfo));
    return PhraseInfo;
  }


  __property   Speechlib_tlb::ISpeechRecoResultPtr RecoResult = {read = get_RecoResult};
  __property   long            StartElementInResult = {read = get_StartElementInResult};
  __property   long            NumberOfElementsInResult = {read = get_NumberOfElementsInResult};
  __property   Speechlib_tlb::ISpeechPhraseInfoPtr PhraseInfo = {read = get_PhraseInfo};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: _ISpeechRecoContextEvents
// Flags:     (4096) Dispatchable
// GUID:      {7B8FCB42-0E9D-4F00-A048-7B04D6179D3D}
// *********************************************************************//
interface _ISpeechRecoContextEvents : public TDispWrapper<IDispatch>
{
  void __fastcall StartStream(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/)
  {
    _TDispID _dispid(/* StartStream */ DISPID(1));
    TAutoArgs<2> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall EndStream(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                            VARIANT_BOOL StreamReleased/*[in]*/)
  {
    _TDispID _dispid(/* EndStream */ DISPID(2));
    TAutoArgs<3> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    _args[3] = StreamReleased /*[VT_BOOL:0]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall Bookmark(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                           VARIANT BookmarkId/*[in]*/, 
                           Speechlib_tlb::SpeechBookmarkOptions Options/*[in]*/)
  {
    _TDispID _dispid(/* Bookmark */ DISPID(3));
    TAutoArgs<4> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    _args[3] = BookmarkId /*[VT_VARIANT:0]*/;
    _args[4] = (int)Options /*[VT_USERDEFINED:0]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall SoundStart(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/)
  {
    _TDispID _dispid(/* SoundStart */ DISPID(4));
    TAutoArgs<2> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall SoundEnd(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/)
  {
    _TDispID _dispid(/* SoundEnd */ DISPID(5));
    TAutoArgs<2> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall PhraseStart(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/)
  {
    _TDispID _dispid(/* PhraseStart */ DISPID(6));
    TAutoArgs<2> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall Recognition(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                              Speechlib_tlb::SpeechRecognitionType RecognitionType/*[in]*/, 
                              Speechlib_tlb::ISpeechRecoResult* Result/*[in]*/)
  {
    _TDispID _dispid(/* Recognition */ DISPID(7));
    TAutoArgs<4> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    _args[3] = (int)RecognitionType /*[VT_USERDEFINED:0]*/;
    _args[4] = (LPDISPATCH)(Speechlib_tlb::ISpeechRecoResult*)Result /*[VT_USERDEFINED:1]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall Hypothesis(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                             Speechlib_tlb::ISpeechRecoResult* Result/*[in]*/)
  {
    _TDispID _dispid(/* Hypothesis */ DISPID(8));
    TAutoArgs<3> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    _args[3] = (LPDISPATCH)(Speechlib_tlb::ISpeechRecoResult*)Result /*[VT_USERDEFINED:1]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall PropertyNumberChange(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                       BSTR PropertyName/*[in]*/, long NewNumberValue/*[in]*/)
  {
    _TDispID _dispid(/* PropertyNumberChange */ DISPID(9));
    TAutoArgs<4> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    _args[3] = PropertyName /*[VT_BSTR:0]*/;
    _args[4] = NewNumberValue /*[VT_I4:0]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall PropertyStringChange(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                       BSTR PropertyName/*[in]*/, BSTR NewStringValue/*[in]*/)
  {
    _TDispID _dispid(/* PropertyStringChange */ DISPID(10));
    TAutoArgs<4> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    _args[3] = PropertyName /*[VT_BSTR:0]*/;
    _args[4] = NewStringValue /*[VT_BSTR:0]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall FalseRecognition(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                   Speechlib_tlb::ISpeechRecoResult* Result/*[in]*/)
  {
    _TDispID _dispid(/* FalseRecognition */ DISPID(11));
    TAutoArgs<3> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    _args[3] = (LPDISPATCH)(Speechlib_tlb::ISpeechRecoResult*)Result /*[VT_USERDEFINED:1]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall Interference(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                               Speechlib_tlb::SpeechInterference Interference/*[in]*/)
  {
    _TDispID _dispid(/* Interference */ DISPID(12));
    TAutoArgs<3> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    _args[3] = (int)Interference /*[VT_USERDEFINED:0]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall RequestUI(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                            BSTR UIType/*[in]*/)
  {
    _TDispID _dispid(/* RequestUI */ DISPID(13));
    TAutoArgs<3> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    _args[3] = UIType /*[VT_BSTR:0]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall RecognizerStateChange(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                        Speechlib_tlb::SpeechRecognizerState NewState/*[in]*/)
  {
    _TDispID _dispid(/* RecognizerStateChange */ DISPID(14));
    TAutoArgs<3> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    _args[3] = (int)NewState /*[VT_USERDEFINED:0]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall Adaptation(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/)
  {
    _TDispID _dispid(/* Adaptation */ DISPID(15));
    TAutoArgs<2> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall RecognitionForOtherContext(long StreamNumber/*[in]*/, 
                                             VARIANT StreamPosition/*[in]*/)
  {
    _TDispID _dispid(/* RecognitionForOtherContext */ DISPID(16));
    TAutoArgs<2> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall AudioLevel(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                             long AudioLevel/*[in]*/)
  {
    _TDispID _dispid(/* AudioLevel */ DISPID(17));
    TAutoArgs<3> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    _args[3] = AudioLevel /*[VT_I4:0]*/;
    OleProcedure(_dispid, _args);
  }

  void __fastcall EnginePrivate(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                VARIANT EngineData/*[in]*/)
  {
    _TDispID _dispid(/* EnginePrivate */ DISPID(18));
    TAutoArgs<3> _args;
    _args[1] = StreamNumber /*[VT_I4:0]*/;
    _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
    _args[3] = EngineData /*[VT_VARIANT:0]*/;
    OleProcedure(_dispid, _args);
  }


};
// *********************************************************************//
// Interface: ISpeechRecoResult2
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {8E0A246D-D3C8-45DE-8657-04290C458C3C}
// *********************************************************************//
interface ISpeechRecoResult2  : public Speechlib_tlb::ISpeechRecoResult
{
public:
  // [12] DiscardResultInfo
  virtual HRESULT STDMETHODCALLTYPE SetTextFeedback(BSTR Feedback/*[in]*/, 
                                                    VARIANT_BOOL WasSuccessful/*[in]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)



#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechLexicon
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {3DA7627A-C7AE-4B23-8708-638C50362C25}
// *********************************************************************//
interface ISpeechLexicon  : public IDispatch
{
public:
  // [1] GenerationId
  virtual HRESULT STDMETHODCALLTYPE get_GenerationId(long* GenerationId/*[out,retval]*/) = 0;
  // [2] GetWords
  virtual HRESULT STDMETHODCALLTYPE GetWords(Speechlib_tlb::SpeechLexiconType Flags/*[in,def,opt]*/, 
                                             long* GenerationId/*[out,def,opt]*/, 
                                             Speechlib_tlb::ISpeechLexiconWords** Words/*[out,retval]*/) = 0;
  // [3] AddPronunciation
  virtual HRESULT STDMETHODCALLTYPE AddPronunciation(BSTR bstrWord/*[in]*/, long LangId/*[in]*/, 
                                                     Speechlib_tlb::SpeechPartOfSpeech PartOfSpeech/*[in,def,opt]*/, 
                                                     BSTR bstrPronunciation/*[in,def,opt]*/) = 0;
  // [4] AddPronunciationByPhoneIds
  virtual HRESULT STDMETHODCALLTYPE AddPronunciationByPhoneIds(BSTR bstrWord/*[in]*/, 
                                                               long LangId/*[in]*/, 
                                                               Speechlib_tlb::SpeechPartOfSpeech PartOfSpeech/*[in,def,opt]*/, 
                                                               VARIANT* PhoneIds/*[in,def,opt]*/= TNoParam()) = 0;
  // [5] RemovePronunciation
  virtual HRESULT STDMETHODCALLTYPE RemovePronunciation(BSTR bstrWord/*[in]*/, long LangId/*[in]*/, 
                                                        Speechlib_tlb::SpeechPartOfSpeech PartOfSpeech/*[in,def,opt]*/, 
                                                        BSTR bstrPronunciation/*[in,def,opt]*/) = 0;
  // [6] RemovePronunciationByPhoneIds
  virtual HRESULT STDMETHODCALLTYPE RemovePronunciationByPhoneIds(BSTR bstrWord/*[in]*/, 
                                                                  long LangId/*[in]*/, 
                                                                  Speechlib_tlb::SpeechPartOfSpeech PartOfSpeech/*[in,def,opt]*/, 
                                                                  VARIANT* PhoneIds/*[in,def,opt]*/= TNoParam()) = 0;
  // [7] GetPronunciations
  virtual HRESULT STDMETHODCALLTYPE GetPronunciations(BSTR bstrWord/*[in]*/, 
                                                      long LangId/*[in,def,opt]*/, 
                                                      Speechlib_tlb::SpeechLexiconType TypeFlags/*[in,def,opt]*/, 
                                                      Speechlib_tlb::ISpeechLexiconPronunciations** ppPronunciations/*[out,retval]*/) = 0;
  // [8] GetGenerationChange
  virtual HRESULT STDMETHODCALLTYPE GetGenerationChange(long* GenerationId/*[in,out]*/, 
                                                        Speechlib_tlb::ISpeechLexiconWords** ppWords/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  long __fastcall get_GenerationId(void)
  {
    long GenerationId;
    OLECHECK(this->get_GenerationId((long*)&GenerationId));
    return GenerationId;
  }

  Speechlib_tlb::ISpeechLexiconWords* __fastcall GetWords(Speechlib_tlb::SpeechLexiconType Flags/*[in,def,opt]*/, 
                                                          long* GenerationId/*[out,def,opt]*/)
  {
    Speechlib_tlb::ISpeechLexiconWords* Words = 0;
    OLECHECK(this->GetWords(Flags, GenerationId, (Speechlib_tlb::ISpeechLexiconWords**)&Words));
    return Words;
  }

  Speechlib_tlb::ISpeechLexiconPronunciations* __fastcall GetPronunciations(BSTR bstrWord/*[in]*/, 
                                                                            long LangId/*[in,def,opt]*/, 
                                                                            Speechlib_tlb::SpeechLexiconType TypeFlags/*[in,def,opt]*/)
  {
    Speechlib_tlb::ISpeechLexiconPronunciations* ppPronunciations = 0;
    OLECHECK(this->GetPronunciations(bstrWord, LangId, TypeFlags, (Speechlib_tlb::ISpeechLexiconPronunciations**)&ppPronunciations));
    return ppPronunciations;
  }

  Speechlib_tlb::ISpeechLexiconWords* __fastcall GetGenerationChange(long* GenerationId/*[in,out]*/)
  {
    Speechlib_tlb::ISpeechLexiconWords* ppWords = 0;
    OLECHECK(this->GetGenerationChange(GenerationId, (Speechlib_tlb::ISpeechLexiconWords**)&ppWords));
    return ppWords;
  }


  __property   long            GenerationId = {read = get_GenerationId};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechLexiconWords
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {8D199862-415E-47D5-AC4F-FAA608B424E6}
// *********************************************************************//
interface ISpeechLexiconWords  : public IDispatch
{
public:
  // [1] Count
  virtual HRESULT STDMETHODCALLTYPE get_Count(long* Count/*[out,retval]*/) = 0;
  // [0] Item
  virtual HRESULT STDMETHODCALLTYPE Item(long Index/*[in]*/, 
                                         Speechlib_tlb::ISpeechLexiconWord** Word/*[out,retval]*/) = 0;
  // [-4] Enumerates the tokens
  virtual HRESULT STDMETHODCALLTYPE get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  long __fastcall get_Count(void)
  {
    long Count;
    OLECHECK(this->get_Count((long*)&Count));
    return Count;
  }

  Speechlib_tlb::ISpeechLexiconWord* __fastcall Item(long Index/*[in]*/)
  {
    Speechlib_tlb::ISpeechLexiconWord* Word = 0;
    OLECHECK(this->Item(Index, (Speechlib_tlb::ISpeechLexiconWord**)&Word));
    return Word;
  }

  LPUNKNOWN __fastcall get__NewEnum(void)
  {
    LPUNKNOWN EnumVARIANT;
    OLECHECK(this->get__NewEnum((LPUNKNOWN*)&EnumVARIANT));
    return EnumVARIANT;
  }


  __property   long            Count = {read = get_Count};
  __property   LPUNKNOWN       _NewEnum = {read = get__NewEnum};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechLexiconWord
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {4E5B933C-C9BE-48ED-8842-1EE51BB1D4FF}
// *********************************************************************//
interface ISpeechLexiconWord  : public IDispatch
{
public:
  virtual HRESULT STDMETHODCALLTYPE get_LangId(long* LangId/*[out,retval]*/) = 0; // [1]
  virtual HRESULT STDMETHODCALLTYPE get_Type(Speechlib_tlb::SpeechWordType* WordType/*[out,retval]*/) = 0; // [2]
  virtual HRESULT STDMETHODCALLTYPE get_Word(BSTR* Word/*[out,retval]*/) = 0; // [3]
  virtual HRESULT STDMETHODCALLTYPE get_Pronunciations(Speechlib_tlb::ISpeechLexiconPronunciations** Pronunciations/*[out,retval]*/) = 0; // [4]

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  long __fastcall get_LangId(void)
  {
    long LangId;
    OLECHECK(this->get_LangId((long*)&LangId));
    return LangId;
  }

  Speechlib_tlb::SpeechWordType __fastcall get_Type(void)
  {
    Speechlib_tlb::SpeechWordType WordType;
    OLECHECK(this->get_Type((Speechlib_tlb::SpeechWordType*)&WordType));
    return WordType;
  }

  BSTR __fastcall get_Word(void)
  {
    BSTR Word = 0;
    OLECHECK(this->get_Word((BSTR*)&Word));
    return Word;
  }

  Speechlib_tlb::ISpeechLexiconPronunciationsPtr __fastcall get_Pronunciations(void)
  {
    Speechlib_tlb::ISpeechLexiconPronunciationsPtr Pronunciations;
    OLECHECK(this->get_Pronunciations(&Pronunciations));
    return Pronunciations;
  }


  __property   long            LangId = {read = get_LangId};
  __property   Speechlib_tlb::SpeechWordType Type = {read = get_Type};
  __property   BSTR            Word = {read = get_Word};
  __property   Speechlib_tlb::ISpeechLexiconPronunciationsPtr Pronunciations = {read = get_Pronunciations};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechLexiconPronunciations
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {72829128-5682-4704-A0D4-3E2BB6F2EAD3}
// *********************************************************************//
interface ISpeechLexiconPronunciations  : public IDispatch
{
public:
  // [1] Count
  virtual HRESULT STDMETHODCALLTYPE get_Count(long* Count/*[out,retval]*/) = 0;
  // [0] Item
  virtual HRESULT STDMETHODCALLTYPE Item(long Index/*[in]*/, 
                                         Speechlib_tlb::ISpeechLexiconPronunciation** Pronunciation/*[out,retval]*/) = 0;
  // [-4] Enumerates the tokens
  virtual HRESULT STDMETHODCALLTYPE get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  long __fastcall get_Count(void)
  {
    long Count;
    OLECHECK(this->get_Count((long*)&Count));
    return Count;
  }

  Speechlib_tlb::ISpeechLexiconPronunciation* __fastcall Item(long Index/*[in]*/)
  {
    Speechlib_tlb::ISpeechLexiconPronunciation* Pronunciation = 0;
    OLECHECK(this->Item(Index, (Speechlib_tlb::ISpeechLexiconPronunciation**)&Pronunciation));
    return Pronunciation;
  }

  LPUNKNOWN __fastcall get__NewEnum(void)
  {
    LPUNKNOWN EnumVARIANT;
    OLECHECK(this->get__NewEnum((LPUNKNOWN*)&EnumVARIANT));
    return EnumVARIANT;
  }


  __property   long            Count = {read = get_Count};
  __property   LPUNKNOWN       _NewEnum = {read = get__NewEnum};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechLexiconPronunciation
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {95252C5D-9E43-4F4A-9899-48EE73352F9F}
// *********************************************************************//
interface ISpeechLexiconPronunciation  : public IDispatch
{
public:
  // [1] Type
  virtual HRESULT STDMETHODCALLTYPE get_Type(Speechlib_tlb::SpeechLexiconType* LexiconType/*[out,retval]*/) = 0;
  // [2] LangId
  virtual HRESULT STDMETHODCALLTYPE get_LangId(long* LangId/*[out,retval]*/) = 0;
  // [3] PartOfSpeech
  virtual HRESULT STDMETHODCALLTYPE get_PartOfSpeech(Speechlib_tlb::SpeechPartOfSpeech* PartOfSpeech/*[out,retval]*/) = 0;
  // [4] PhoneIds
  virtual HRESULT STDMETHODCALLTYPE get_PhoneIds(VARIANT* PhoneIds/*[out,retval]*/) = 0;
  // [5] Symbolic
  virtual HRESULT STDMETHODCALLTYPE get_Symbolic(BSTR* Symbolic/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  Speechlib_tlb::SpeechLexiconType __fastcall get_Type(void)
  {
    Speechlib_tlb::SpeechLexiconType LexiconType;
    OLECHECK(this->get_Type((Speechlib_tlb::SpeechLexiconType*)&LexiconType));
    return LexiconType;
  }

  long __fastcall get_LangId(void)
  {
    long LangId;
    OLECHECK(this->get_LangId((long*)&LangId));
    return LangId;
  }

  Speechlib_tlb::SpeechPartOfSpeech __fastcall get_PartOfSpeech(void)
  {
    Speechlib_tlb::SpeechPartOfSpeech PartOfSpeech;
    OLECHECK(this->get_PartOfSpeech((Speechlib_tlb::SpeechPartOfSpeech*)&PartOfSpeech));
    return PartOfSpeech;
  }

  VARIANT __fastcall get_PhoneIds(void)
  {
    VARIANT PhoneIds;
    OLECHECK(this->get_PhoneIds((VARIANT*)&PhoneIds));
    return PhoneIds;
  }

  BSTR __fastcall get_Symbolic(void)
  {
    BSTR Symbolic = 0;
    OLECHECK(this->get_Symbolic((BSTR*)&Symbolic));
    return Symbolic;
  }


  __property   Speechlib_tlb::SpeechLexiconType Type = {read = get_Type};
  __property   long            LangId = {read = get_LangId};
  __property   Speechlib_tlb::SpeechPartOfSpeech PartOfSpeech = {read = get_PartOfSpeech};
  __property   BSTR            Symbolic = {read = get_Symbolic};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechXMLRecoResult
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {AAEC54AF-8F85-4924-944D-B79D39D72E19}
// *********************************************************************//
interface ISpeechXMLRecoResult  : public Speechlib_tlb::ISpeechRecoResult
{
public:
  // [10] GetXMLResult
  virtual HRESULT STDMETHODCALLTYPE GetXMLResult(Speechlib_tlb::SPXMLRESULTOPTIONS Options/*[in]*/, 
                                                 BSTR* pResult/*[out,retval]*/) = 0;
  // [11] GetXMLErrorInfo
  virtual HRESULT STDMETHODCALLTYPE GetXMLErrorInfo(long* LineNumber/*[out]*/, 
                                                    BSTR* ScriptLine/*[out]*/, BSTR* Source/*[out]*/, 
                                                    BSTR* Description/*[out]*/, 
                                                    long* ResultCode/*[out]*/, 
                                                    VARIANT_BOOL* IsError/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  BSTR __fastcall GetXMLResult(Speechlib_tlb::SPXMLRESULTOPTIONS Options/*[in]*/)
  {
    BSTR pResult = 0;
    OLECHECK(this->GetXMLResult(Options, (BSTR*)&pResult));
    return pResult;
  }

  VARIANT_BOOL __fastcall GetXMLErrorInfo(long* LineNumber/*[out]*/, BSTR* ScriptLine/*[out]*/, 
                                          BSTR* Source/*[out]*/, BSTR* Description/*[out]*/, 
                                          long* ResultCode/*[out]*/)
  {
    VARIANT_BOOL IsError;
    OLECHECK(this->GetXMLErrorInfo(LineNumber, ScriptLine, Source, Description, ResultCode, (VARIANT_BOOL*)&IsError));
    return IsError;
  }



#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechRecoResultDispatch
// Flags:     (4432) Hidden Dual OleAutomation Dispatchable
// GUID:      {6D60EB64-ACED-40A6-BBF3-4E557F71DEE2}
// *********************************************************************//
interface ISpeechRecoResultDispatch  : public IDispatch
{
public:
  // [1] RecoContext
  virtual HRESULT STDMETHODCALLTYPE get_RecoContext(Speechlib_tlb::ISpeechRecoContext** RecoContext/*[out,retval]*/) = 0;
  // [2] Times
  virtual HRESULT STDMETHODCALLTYPE get_Times(Speechlib_tlb::ISpeechRecoResultTimes** Times/*[out,retval]*/) = 0;
  // [3] AudioFormat
  virtual HRESULT STDMETHODCALLTYPE _set_AudioFormat(Speechlib_tlb::ISpeechAudioFormat* Format/*[in]*/) = 0;
  // [3] AudioFormat
  virtual HRESULT STDMETHODCALLTYPE get_AudioFormat(Speechlib_tlb::ISpeechAudioFormat** Format/*[out,retval]*/) = 0;
  // [4] PhraseInfo
  virtual HRESULT STDMETHODCALLTYPE get_PhraseInfo(Speechlib_tlb::ISpeechPhraseInfo** PhraseInfo/*[out,retval]*/) = 0;
  // [5] Alternates
  virtual HRESULT STDMETHODCALLTYPE Alternates(long RequestCount/*[in]*/, 
                                               long StartElement/*[in,def,opt]*/, 
                                               long Elements/*[in,def,opt]*/, 
                                               Speechlib_tlb::ISpeechPhraseAlternates** Alternates/*[out,retval]*/) = 0;
  // [6] Audio
  virtual HRESULT STDMETHODCALLTYPE Audio(long StartElement/*[in,def,opt]*/, 
                                          long Elements/*[in,def,opt]*/, 
                                          Speechlib_tlb::ISpeechMemoryStream** Stream/*[out,retval]*/) = 0;
  // [7] SpeakAudio
  virtual HRESULT STDMETHODCALLTYPE SpeakAudio(long StartElement/*[in,def,opt]*/, 
                                               long Elements/*[in,def,opt]*/, 
                                               Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/, 
                                               long* StreamNumber/*[out,retval]*/) = 0;
  // [8] SaveToMemory
  virtual HRESULT STDMETHODCALLTYPE SaveToMemory(VARIANT* ResultBlock/*[out,retval]*/) = 0;
  // [9] DiscardResultInfo
  virtual HRESULT STDMETHODCALLTYPE DiscardResultInfo(Speechlib_tlb::SpeechDiscardType ValueTypes/*[in]*/) = 0;
  // [10] GetXMLResult
  virtual HRESULT STDMETHODCALLTYPE GetXMLResult(Speechlib_tlb::SPXMLRESULTOPTIONS Options/*[in]*/, 
                                                 BSTR* pResult/*[out,retval]*/) = 0;
  // [11] GetXMLErrorInfo
  virtual HRESULT STDMETHODCALLTYPE GetXMLErrorInfo(long* LineNumber/*[out]*/, 
                                                    BSTR* ScriptLine/*[out]*/, BSTR* Source/*[out]*/, 
                                                    BSTR* Description/*[out]*/, 
                                                    HRESULT* ResultCode/*[out]*/, 
                                                    VARIANT_BOOL* IsError/*[out,retval]*/) = 0;
  // [12] SetTextFeedback
  virtual HRESULT STDMETHODCALLTYPE SetTextFeedback(BSTR Feedback/*[in]*/, 
                                                    VARIANT_BOOL WasSuccessful/*[in]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  Speechlib_tlb::ISpeechRecoContextPtr __fastcall get_RecoContext(void)
  {
    Speechlib_tlb::ISpeechRecoContextPtr RecoContext;
    OLECHECK(this->get_RecoContext(&RecoContext));
    return RecoContext;
  }

  Speechlib_tlb::ISpeechRecoResultTimesPtr __fastcall get_Times(void)
  {
    Speechlib_tlb::ISpeechRecoResultTimesPtr Times;
    OLECHECK(this->get_Times(&Times));
    return Times;
  }

  Speechlib_tlb::ISpeechAudioFormatPtr __fastcall get_AudioFormat(void)
  {
    Speechlib_tlb::ISpeechAudioFormatPtr Format;
    OLECHECK(this->get_AudioFormat(&Format));
    return Format;
  }

  Speechlib_tlb::ISpeechPhraseInfoPtr __fastcall get_PhraseInfo(void)
  {
    Speechlib_tlb::ISpeechPhraseInfoPtr PhraseInfo;
    OLECHECK(this->get_PhraseInfo(&PhraseInfo));
    return PhraseInfo;
  }

  Speechlib_tlb::ISpeechPhraseAlternates* __fastcall Alternates(long RequestCount/*[in]*/, 
                                                                long StartElement/*[in,def,opt]*/, 
                                                                long Elements/*[in,def,opt]*/)
  {
    Speechlib_tlb::ISpeechPhraseAlternates* Alternates = 0;
    OLECHECK(this->Alternates(RequestCount, StartElement, Elements, (Speechlib_tlb::ISpeechPhraseAlternates**)&Alternates));
    return Alternates;
  }

  Speechlib_tlb::ISpeechMemoryStream* __fastcall Audio(long StartElement/*[in,def,opt]*/, 
                                                       long Elements/*[in,def,opt]*/)
  {
    Speechlib_tlb::ISpeechMemoryStream* Stream = 0;
    OLECHECK(this->Audio(StartElement, Elements, (Speechlib_tlb::ISpeechMemoryStream**)&Stream));
    return Stream;
  }

  long __fastcall SpeakAudio(long StartElement/*[in,def,opt]*/, long Elements/*[in,def,opt]*/, 
                             Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/)
  {
    long StreamNumber;
    OLECHECK(this->SpeakAudio(StartElement, Elements, Flags, (long*)&StreamNumber));
    return StreamNumber;
  }

  VARIANT __fastcall SaveToMemory(void)
  {
    VARIANT ResultBlock;
    OLECHECK(this->SaveToMemory((VARIANT*)&ResultBlock));
    return ResultBlock;
  }

  BSTR __fastcall GetXMLResult(Speechlib_tlb::SPXMLRESULTOPTIONS Options/*[in]*/)
  {
    BSTR pResult = 0;
    OLECHECK(this->GetXMLResult(Options, (BSTR*)&pResult));
    return pResult;
  }

  VARIANT_BOOL __fastcall GetXMLErrorInfo(long* LineNumber/*[out]*/, BSTR* ScriptLine/*[out]*/, 
                                          BSTR* Source/*[out]*/, BSTR* Description/*[out]*/, 
                                          HRESULT* ResultCode/*[out]*/)
  {
    VARIANT_BOOL IsError;
    OLECHECK(this->GetXMLErrorInfo(LineNumber, ScriptLine, Source, Description, ResultCode, (VARIANT_BOOL*)&IsError));
    return IsError;
  }


  __property   Speechlib_tlb::ISpeechRecoContextPtr RecoContext = {read = get_RecoContext};
  __property   Speechlib_tlb::ISpeechRecoResultTimesPtr Times = {read = get_Times};
  __property   Speechlib_tlb::ISpeechAudioFormat* AudioFormat = {write = _set_AudioFormat};
  __property   Speechlib_tlb::ISpeechPhraseInfoPtr PhraseInfo = {read = get_PhraseInfo};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechPhraseInfoBuilder
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {3B151836-DF3A-4E0A-846C-D2ADC9334333}
// *********************************************************************//
interface ISpeechPhraseInfoBuilder  : public IDispatch
{
public:
  // [1] RestorePhraseFromMemory
  virtual HRESULT STDMETHODCALLTYPE RestorePhraseFromMemory(VARIANT* PhraseInMemory/*[in]*/, 
                                                            Speechlib_tlb::ISpeechPhraseInfo** PhraseInfo/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  Speechlib_tlb::ISpeechPhraseInfo* __fastcall RestorePhraseFromMemory(VARIANT* PhraseInMemory/*[in]*/)
  {
    Speechlib_tlb::ISpeechPhraseInfo* PhraseInfo = 0;
    OLECHECK(this->RestorePhraseFromMemory(PhraseInMemory, (Speechlib_tlb::ISpeechPhraseInfo**)&PhraseInfo));
    return PhraseInfo;
  }



#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpeechPhoneConverter
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {C3E4F353-433F-43D6-89A1-6A62A7054C3D}
// *********************************************************************//
interface ISpeechPhoneConverter  : public IDispatch
{
public:
  // [1] LanguageId
  virtual HRESULT STDMETHODCALLTYPE get_LanguageId(long* LanguageId/*[out,retval]*/) = 0;
  // [1] LanguageId
  virtual HRESULT STDMETHODCALLTYPE set_LanguageId(long LanguageId/*[in]*/) = 0;
  // [2] PhoneToId
  virtual HRESULT STDMETHODCALLTYPE PhoneToId(BSTR Phonemes/*[in]*/, 
                                              VARIANT* IdArray/*[out,retval]*/) = 0;
  // [3] IdToPhone
  virtual HRESULT STDMETHODCALLTYPE IdToPhone(VARIANT IdArray/*[in]*/, 
                                              BSTR* Phonemes/*[out,retval]*/) = 0;

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)

  long __fastcall get_LanguageId(void)
  {
    long LanguageId;
    OLECHECK(this->get_LanguageId((long*)&LanguageId));
    return LanguageId;
  }

  VARIANT __fastcall PhoneToId(BSTR Phonemes/*[in]*/)
  {
    VARIANT IdArray;
    OLECHECK(this->PhoneToId(Phonemes, (VARIANT*)&IdArray));
    return IdArray;
  }

  BSTR __fastcall IdToPhone(VARIANT IdArray/*[in]*/)
  {
    BSTR Phonemes = 0;
    OLECHECK(this->IdToPhone(IdArray, (BSTR*)&Phonemes));
    return Phonemes;
  }


  __property   long            LanguageId = {read = get_LanguageId, write = set_LanguageId};

#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: ISpNotifySink
// Flags:     (512) Restricted
// GUID:      {259684DC-37C3-11D2-9603-00C04F8EE628}
// *********************************************************************//
interface ISpNotifySink  : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE Notify(void) = 0; // [-1]
};

// *********************************************************************//
// Interface: ISpNotifyTranslator
// Flags:     (512) Restricted
// GUID:      {ACA16614-5D3D-11D2-960E-00C04F8EE628}
// *********************************************************************//
interface ISpNotifyTranslator  : public Speechlib_tlb::ISpNotifySink
{
public:
  virtual HRESULT STDMETHODCALLTYPE InitWindowMessage(Speechlib_tlb::wireHWND hWnd/*[in]*/, 
                                                      unsigned Msg/*[in]*/, 
                                                      Speechlib_tlb::UINT_PTR wParam/*[in]*/, 
                                                      Speechlib_tlb::LONG_PTR lParam/*[in]*/) = 0; // [1610743808]
  virtual HRESULT STDMETHODCALLTYPE InitCallback(void** pfnCallback/*[in]*/, 
                                                 Speechlib_tlb::UINT_PTR wParam/*[in]*/, 
                                                 Speechlib_tlb::LONG_PTR lParam/*[in]*/) = 0; // [1610743809]
  virtual HRESULT STDMETHODCALLTYPE InitSpNotifyCallback(void** pSpCallback/*[in]*/, 
                                                         Speechlib_tlb::UINT_PTR wParam/*[in]*/, 
                                                         Speechlib_tlb::LONG_PTR lParam/*[in]*/) = 0; // [1610743810]
  virtual HRESULT STDMETHODCALLTYPE InitWin32Event(void* hEvent/*[in]*/, 
                                                   long fCloseHandleOnRelease/*[in]*/) = 0; // [1610743811]
  virtual HRESULT STDMETHODCALLTYPE Wait(unsigned_long dwMilliseconds/*[in]*/) = 0; // [1610743812]
  virtual void* STDMETHODCALLTYPE GetEventHandle(void) = 0; // [1610743813]
};

// *********************************************************************//
// Interface: ISpDataKey
// Flags:     (512) Restricted
// GUID:      {14056581-E16C-11D2-BB90-00C04F8EE6C0}
// *********************************************************************//
interface ISpDataKey  : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE SetData(LPWSTR pszValueName/*[in]*/, 
                                            unsigned_long cbData/*[in]*/, 
                                            unsigned_char* pData/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetData(LPWSTR pszValueName/*[in]*/, 
                                            unsigned_long* pcbData/*[in]*/, 
                                            unsigned_char* pData/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE SetStringValue(LPWSTR pszValueName/*[in]*/, 
                                                   LPWSTR pszValue/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetStringValue(LPWSTR pszValueName/*[in]*/, 
                                                   LPWSTR* ppszValue/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE SetDWORD(LPWSTR pszValueName/*[in]*/, 
                                             unsigned_long dwValue/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetDWORD(LPWSTR pszValueName/*[in]*/, 
                                             unsigned_long* pdwValue/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE OpenKey(LPWSTR pszSubKeyName/*[in]*/, 
                                            Speechlib_tlb::ISpDataKey** ppSubKey/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE CreateKey(LPWSTR pszSubKey/*[in]*/, 
                                              Speechlib_tlb::ISpDataKey** ppSubKey/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE DeleteKey(LPWSTR pszSubKey/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE DeleteValue(LPWSTR pszValueName/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE EnumKeys(unsigned_long Index/*[in]*/, 
                                             LPWSTR* ppszSubKeyName/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE EnumValues(unsigned_long Index/*[in]*/, 
                                               LPWSTR* ppszValueName/*[out]*/) = 0; // [-1]
};

// *********************************************************************//
// Interface: ISpObjectTokenCategory
// Flags:     (512) Restricted
// GUID:      {2D3D3845-39AF-4850-BBF9-40B49780011D}
// *********************************************************************//
interface ISpObjectTokenCategory  : public Speechlib_tlb::ISpDataKey
{
public:
  virtual HRESULT STDMETHODCALLTYPE SetId(LPWSTR pszCategoryId/*[in]*/, 
                                          long fCreateIfNotExist/*[in]*/) = 0; // [1610743808]
  virtual HRESULT STDMETHODCALLTYPE GetId(LPWSTR* ppszCoMemCategoryId/*[out]*/) = 0; // [1610743809]
  virtual HRESULT STDMETHODCALLTYPE GetDataKey(Speechlib_tlb::SPDATAKEYLOCATION spdkl/*[in]*/, 
                                               Speechlib_tlb::ISpDataKey** ppDataKey/*[out]*/) = 0; // [1610743810]
  virtual HRESULT STDMETHODCALLTYPE EnumTokens(LPWSTR pzsReqAttribs/*[in]*/, 
                                               LPWSTR pszOptAttribs/*[in]*/, 
                                               Speechlib_tlb::IEnumSpObjectTokens** ppEnum/*[out]*/) = 0; // [1610743811]
  virtual HRESULT STDMETHODCALLTYPE SetDefaultTokenId(LPWSTR pszTokenId/*[in]*/) = 0; // [1610743812]
  virtual HRESULT STDMETHODCALLTYPE GetDefaultTokenId(LPWSTR* ppszCoMemTokenId/*[out]*/) = 0; // [1610743813]
};

// *********************************************************************//
// Interface: IEnumSpObjectTokens
// Flags:     (512) Restricted
// GUID:      {06B64F9E-7FDA-11D2-B4F2-00C04F797396}
// *********************************************************************//
interface IEnumSpObjectTokens  : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE Next(unsigned_long celt/*[in]*/, 
                                         Speechlib_tlb::ISpObjectToken** pelt/*[out]*/, 
                                         unsigned_long* pceltFetched/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE Skip(unsigned_long celt/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE Reset(void) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE Clone(Speechlib_tlb::IEnumSpObjectTokens** ppEnum/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE Item(unsigned_long Index/*[in]*/, 
                                         Speechlib_tlb::ISpObjectToken** ppToken/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetCount(unsigned_long* pCount/*[out]*/) = 0; // [-1]
};

// *********************************************************************//
// Interface: ISpObjectToken
// Flags:     (512) Restricted
// GUID:      {14056589-E16C-11D2-BB90-00C04F8EE6C0}
// *********************************************************************//
interface ISpObjectToken  : public Speechlib_tlb::ISpDataKey
{
public:
  virtual HRESULT STDMETHODCALLTYPE SetId(LPWSTR pszCategoryId, LPWSTR pszTokenId/*[in]*/, 
                                          long fCreateIfNotExist/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetId(LPWSTR* ppszCoMemTokenId/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetCategory(Speechlib_tlb::ISpObjectTokenCategory** ppTokenCategory/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE CreateInstance(LPUNKNOWN pUnkOuter/*[in]*/, 
                                                   unsigned_long dwClsContext/*[in]*/, 
                                                   System::TGUID* riid/*[in]*/, 
                                                   void** ppvObject/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetStorageFileName(System::TGUID* clsidCaller/*[in]*/, 
                                                       LPWSTR pszValueName/*[in]*/, 
                                                       LPWSTR pszFileNameSpecifier/*[in]*/, 
                                                       unsigned_long nFolder/*[in]*/, 
                                                       LPWSTR* ppszFilePath/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE RemoveStorageFileName(System::TGUID* clsidCaller/*[in]*/, 
                                                          LPWSTR pszKeyName/*[in]*/, 
                                                          long fDeleteFile/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE Remove(System::TGUID* pclsidCaller) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE IsUISupported(LPWSTR pszTypeOfUI/*[in]*/, 
                                                  void* pvExtraData/*[in]*/, 
                                                  unsigned_long cbExtraData/*[in]*/, 
                                                  LPUNKNOWN punkObject/*[in]*/, 
                                                  long* pfSupported/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE DisplayUI(Speechlib_tlb::wireHWND hWndParent/*[in]*/, 
                                              LPWSTR pszTitle/*[in]*/, LPWSTR pszTypeOfUI/*[in]*/, 
                                              void* pvExtraData/*[in]*/, 
                                              unsigned_long cbExtraData/*[in]*/, 
                                              LPUNKNOWN punkObject/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE MatchesAttributes(LPWSTR pszAttributes/*[in]*/, 
                                                      long* pfMatches/*[out]*/) = 0; // [-1]
};

// *********************************************************************//
// Interface: IServiceProvider
// Flags:     (0)
// GUID:      {6D5140C1-7436-11CE-8034-00AA006009FA}
// *********************************************************************//
interface IServiceProvider  : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE RemoteQueryService(System::TGUID* guidService/*[in]*/, 
                                                       System::TGUID* riid/*[in]*/, 
                                                       LPUNKNOWN* ppvObject/*[out]*/) = 0; // [-1]
};

// *********************************************************************//
// Interface: ISpResourceManager
// Flags:     (512) Restricted
// GUID:      {93384E18-5014-43D5-ADBB-A78E055926BD}
// *********************************************************************//
interface ISpResourceManager  : public Speechlib_tlb::IServiceProvider
{
public:
  virtual HRESULT STDMETHODCALLTYPE SetObject(System::TGUID* guidServiceId/*[in]*/, 
                                              LPUNKNOWN punkObject/*[in]*/) = 0; // [1610743808]
  virtual HRESULT STDMETHODCALLTYPE GetObject(System::TGUID* guidServiceId/*[in]*/, 
                                              System::TGUID* ObjectCLSID/*[in]*/, 
                                              System::TGUID* ObjectIID/*[in]*/, 
                                              long fReleaseWhenLastExternalRefReleased/*[in]*/, 
                                              void** ppObject/*[out]*/) = 0; // [1610743809]
};

// *********************************************************************//
// Interface: ISequentialStream
// Flags:     (0)
// GUID:      {0C733A30-2A1C-11CE-ADE5-00AA0044773D}
// *********************************************************************//
interface ISequentialStream  : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE RemoteRead(unsigned_char* pv/*[out]*/, unsigned_long cb/*[in]*/, 
                                               unsigned_long* pcbRead/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE RemoteWrite(unsigned_char* pv/*[in]*/, unsigned_long cb/*[in]*/, 
                                                unsigned_long* pcbWritten/*[out]*/) = 0; // [-1]
};

// *********************************************************************//
// Interface: IStream
// Flags:     (0)
// GUID:      {0000000C-0000-0000-C000-000000000046}
// *********************************************************************//
interface IStream  : public Speechlib_tlb::ISequentialStream
{
public:
  virtual HRESULT STDMETHODCALLTYPE RemoteSeek(Speechlib_tlb::_LARGE_INTEGER dlibMove/*[in]*/, 
                                               unsigned_long dwOrigin/*[in]*/, 
                                               Speechlib_tlb::_ULARGE_INTEGER* plibNewPosition/*[out]*/) = 0; // [1610743808]
  virtual HRESULT STDMETHODCALLTYPE SetSize(Speechlib_tlb::_ULARGE_INTEGER libNewSize/*[in]*/) = 0; // [1610743809]
  virtual HRESULT STDMETHODCALLTYPE RemoteCopyTo(Speechlib_tlb::IStream* pstm/*[in]*/, 
                                                 Speechlib_tlb::_ULARGE_INTEGER cb/*[in]*/, 
                                                 Speechlib_tlb::_ULARGE_INTEGER* pcbRead/*[out]*/, 
                                                 Speechlib_tlb::_ULARGE_INTEGER* pcbWritten/*[out]*/) = 0; // [1610743810]
  virtual HRESULT STDMETHODCALLTYPE Commit(unsigned_long grfCommitFlags/*[in]*/) = 0; // [1610743811]
  virtual HRESULT STDMETHODCALLTYPE Revert(void) = 0; // [1610743812]
  virtual HRESULT STDMETHODCALLTYPE LockRegion(Speechlib_tlb::_ULARGE_INTEGER libOffset/*[in]*/, 
                                               Speechlib_tlb::_ULARGE_INTEGER cb/*[in]*/, 
                                               unsigned_long dwLockType/*[in]*/) = 0; // [1610743813]
  virtual HRESULT STDMETHODCALLTYPE UnlockRegion(Speechlib_tlb::_ULARGE_INTEGER libOffset/*[in]*/, 
                                                 Speechlib_tlb::_ULARGE_INTEGER cb/*[in]*/, 
                                                 unsigned_long dwLockType/*[in]*/) = 0; // [1610743814]
  virtual HRESULT STDMETHODCALLTYPE Stat(Speechlib_tlb::tagSTATSTG* pstatstg/*[out]*/, 
                                         unsigned_long grfStatFlag/*[in]*/) = 0; // [1610743815]
  virtual HRESULT STDMETHODCALLTYPE Clone(Speechlib_tlb::IStream** ppstm/*[out]*/) = 0; // [1610743816]
};

// *********************************************************************//
// Interface: ISpStreamFormat
// Flags:     (512) Restricted
// GUID:      {BED530BE-2606-4F4D-A1C0-54C5CDA5566F}
// *********************************************************************//
interface ISpStreamFormat  : public Speechlib_tlb::IStream
{
public:
  virtual HRESULT STDMETHODCALLTYPE GetFormat(System::TGUID* pguidFormatId/*[in]*/, 
                                              Speechlib_tlb::WAVEFORMATEX** ppCoMemWaveFormatEx/*[out]*/) = 0; // [1610809344]
};

// *********************************************************************//
// Interface: ISpStreamFormatConverter
// Flags:     (512) Restricted
// GUID:      {678A932C-EA71-4446-9B41-78FDA6280A29}
// *********************************************************************//
interface ISpStreamFormatConverter  : public Speechlib_tlb::ISpStreamFormat
{
public:
  virtual HRESULT STDMETHODCALLTYPE SetBaseStream(Speechlib_tlb::ISpStreamFormat* pStream/*[in]*/, 
                                                  long fSetFormatToBaseStreamFormat/*[in]*/, 
                                                  long fWriteToBaseStream/*[in]*/) = 0; // [1610874880]
  virtual HRESULT STDMETHODCALLTYPE GetBaseStream(Speechlib_tlb::ISpStreamFormat** ppStream/*[out]*/) = 0; // [1610874881]
  virtual HRESULT STDMETHODCALLTYPE SetFormat(System::TGUID* rguidFormatIdOfConvertedStream/*[in]*/, 
                                              Speechlib_tlb::WAVEFORMATEX* pWaveFormatExOfConvertedStream/*[in]*/) = 0; // [1610874882]
  virtual HRESULT STDMETHODCALLTYPE ResetSeekPosition(void) = 0; // [1610874883]
  virtual HRESULT STDMETHODCALLTYPE ScaleConvertedToBaseOffset(unsigned_int64 ullOffsetConvertedStream/*[in]*/, 
                                                               unsigned_int64* pullOffsetBaseStream/*[out]*/) = 0; // [1610874884]
  virtual HRESULT STDMETHODCALLTYPE ScaleBaseToConvertedOffset(unsigned_int64 ullOffsetBaseStream/*[in]*/, 
                                                               unsigned_int64* pullOffsetConvertedStream/*[out]*/) = 0; // [1610874885]
};

// *********************************************************************//
// Interface: ISpNotifySource
// Flags:     (512) Restricted
// GUID:      {5EFF4AEF-8487-11D2-961C-00C04F8EE628}
// *********************************************************************//
interface ISpNotifySource  : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE SetNotifySink(Speechlib_tlb::ISpNotifySink* pNotifySink/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE SetNotifyWindowMessage(Speechlib_tlb::wireHWND hWnd/*[in]*/, 
                                                           unsigned Msg/*[in]*/, 
                                                           Speechlib_tlb::UINT_PTR wParam/*[in]*/, 
                                                           Speechlib_tlb::LONG_PTR lParam/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE SetNotifyCallbackFunction(void** pfnCallback/*[in]*/, 
                                                              Speechlib_tlb::UINT_PTR wParam/*[in]*/, 
                                                              Speechlib_tlb::LONG_PTR lParam/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE SetNotifyCallbackInterface(void** pSpCallback/*[in]*/, 
                                                               Speechlib_tlb::UINT_PTR wParam/*[in]*/, 
                                                               Speechlib_tlb::LONG_PTR lParam/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE SetNotifyWin32Event(void) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE WaitForNotifyEvent(unsigned_long dwMilliseconds/*[in]*/) = 0; // [-1]
  virtual void* STDMETHODCALLTYPE GetNotifyEventHandle(void) = 0; // [-1]
};

// *********************************************************************//
// Interface: ISpEventSource
// Flags:     (512) Restricted
// GUID:      {BE7A9CCE-5F9E-11D2-960F-00C04F8EE628}
// *********************************************************************//
interface ISpEventSource  : public Speechlib_tlb::ISpNotifySource
{
public:
  virtual HRESULT STDMETHODCALLTYPE SetInterest(unsigned_int64 ullEventInterest/*[in]*/, 
                                                unsigned_int64 ullQueuedInterest/*[in]*/) = 0; // [1610743808]
  virtual HRESULT STDMETHODCALLTYPE GetEvents(unsigned_long ulCount/*[in]*/, 
                                              Speechlib_tlb::SPEVENT* pEventArray/*[out]*/, 
                                              unsigned_long* pulFetched/*[out]*/) = 0; // [1610743809]
  virtual HRESULT STDMETHODCALLTYPE GetInfo(Speechlib_tlb::SPEVENTSOURCEINFO* pInfo/*[out]*/) = 0; // [1610743810]
};

// *********************************************************************//
// Interface: ISpEventSink
// Flags:     (512) Restricted
// GUID:      {BE7A9CC9-5F9E-11D2-960F-00C04F8EE628}
// *********************************************************************//
interface ISpEventSink  : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE AddEvents(Speechlib_tlb::SPEVENT* pEventArray/*[in]*/, 
                                              unsigned_long ulCount/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetEventInterest(unsigned_int64* pullEventInterest/*[out]*/) = 0; // [-1]
};

// *********************************************************************//
// Interface: ISpObjectWithToken
// Flags:     (512) Restricted
// GUID:      {5B559F40-E952-11D2-BB91-00C04F8EE6C0}
// *********************************************************************//
interface ISpObjectWithToken  : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE SetObjectToken(Speechlib_tlb::ISpObjectToken* pToken/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetObjectToken(Speechlib_tlb::ISpObjectToken** ppToken/*[out]*/) = 0; // [-1]
};

// *********************************************************************//
// Interface: ISpAudio
// Flags:     (512) Restricted
// GUID:      {C05C768F-FAE8-4EC2-8E07-338321C12452}
// *********************************************************************//
interface ISpAudio  : public Speechlib_tlb::ISpStreamFormat
{
public:
  virtual HRESULT STDMETHODCALLTYPE SetState(Speechlib_tlb::SPAUDIOSTATE NewState/*[in]*/, 
                                             unsigned_int64 ullReserved/*[in]*/) = 0; // [1610874880]
  virtual HRESULT STDMETHODCALLTYPE SetFormat(System::TGUID* rguidFmtId/*[in]*/, 
                                              Speechlib_tlb::WAVEFORMATEX* pWaveFormatEx/*[in]*/) = 0; // [1610874881]
  virtual HRESULT STDMETHODCALLTYPE GetStatus(Speechlib_tlb::SPAUDIOSTATUS* pStatus/*[out]*/) = 0; // [1610874882]
  virtual HRESULT STDMETHODCALLTYPE SetBufferInfo(Speechlib_tlb::SPAUDIOBUFFERINFO* pBuffInfo/*[in]*/) = 0; // [1610874883]
  virtual HRESULT STDMETHODCALLTYPE GetBufferInfo(Speechlib_tlb::SPAUDIOBUFFERINFO* pBuffInfo/*[out]*/) = 0; // [1610874884]
  virtual HRESULT STDMETHODCALLTYPE GetDefaultFormat(System::TGUID* pFormatId/*[out]*/, 
                                                     Speechlib_tlb::WAVEFORMATEX** ppCoMemWaveFormatEx/*[out]*/) = 0; // [1610874885]
  virtual void* STDMETHODCALLTYPE EventHandle(void) = 0; // [1610874886]
  virtual HRESULT STDMETHODCALLTYPE GetVolumeLevel(unsigned_long* pLevel/*[out]*/) = 0; // [1610874887]
  virtual HRESULT STDMETHODCALLTYPE SetVolumeLevel(unsigned_long Level/*[in]*/) = 0; // [1610874888]
  virtual HRESULT STDMETHODCALLTYPE GetBufferNotifySize(unsigned_long* pcbSize/*[out]*/) = 0; // [1610874889]
  virtual HRESULT STDMETHODCALLTYPE SetBufferNotifySize(unsigned_long cbSize/*[in]*/) = 0; // [1610874890]
};

// *********************************************************************//
// Interface: ISpMMSysAudio
// Flags:     (512) Restricted
// GUID:      {15806F6E-1D70-4B48-98E6-3B1A007509AB}
// *********************************************************************//
interface ISpMMSysAudio  : public Speechlib_tlb::ISpAudio
{
public:
  virtual HRESULT STDMETHODCALLTYPE GetDeviceId(unsigned* puDeviceId/*[out]*/) = 0; // [1610940416]
  virtual HRESULT STDMETHODCALLTYPE SetDeviceId(unsigned uDeviceId/*[in]*/) = 0; // [1610940417]
  virtual HRESULT STDMETHODCALLTYPE GetMMHandle(void** pHandle/*[out]*/) = 0; // [1610940418]
  virtual HRESULT STDMETHODCALLTYPE GetLineId(unsigned* puLineId/*[out]*/) = 0; // [1610940419]
  virtual HRESULT STDMETHODCALLTYPE SetLineId(unsigned uLineId/*[in]*/) = 0; // [1610940420]
};

// *********************************************************************//
// Interface: ISpStream
// Flags:     (512) Restricted
// GUID:      {12E3CCA9-7518-44C5-A5E7-BA5A79CB929E}
// *********************************************************************//
interface ISpStream  : public Speechlib_tlb::ISpStreamFormat
{
public:
  virtual HRESULT STDMETHODCALLTYPE SetBaseStream(Speechlib_tlb::IStream* pStream/*[in]*/, 
                                                  System::TGUID* rguidFormat/*[in]*/, 
                                                  Speechlib_tlb::WAVEFORMATEX* pWaveFormatEx/*[in]*/) = 0; // [1610874880]
  virtual HRESULT STDMETHODCALLTYPE GetBaseStream(Speechlib_tlb::IStream** ppStream/*[out]*/) = 0; // [1610874881]
  virtual HRESULT STDMETHODCALLTYPE BindToFile(LPWSTR pszFileName/*[in]*/, 
                                               Speechlib_tlb::SPFILEMODE eMode/*[in]*/, 
                                               System::TGUID* pFormatId/*[in]*/, 
                                               Speechlib_tlb::WAVEFORMATEX* pWaveFormatEx, 
                                               unsigned_int64 ullEventInterest/*[in]*/) = 0; // [1610874882]
  virtual HRESULT STDMETHODCALLTYPE Close(void) = 0; // [1610874883]
};

// *********************************************************************//
// Interface: ISpVoice
// Flags:     (512) Restricted
// GUID:      {6C44DF74-72B9-4992-A1EC-EF996E0422D4}
// *********************************************************************//
interface ISpVoice  : public Speechlib_tlb::ISpEventSource
{
public:
  virtual HRESULT STDMETHODCALLTYPE SetOutput(LPUNKNOWN pUnkOutput/*[in]*/, 
                                              long fAllowFormatChanges/*[in]*/) = 0; // [1610809344]
  virtual HRESULT STDMETHODCALLTYPE GetOutputObjectToken(Speechlib_tlb::ISpObjectToken** ppObjectToken/*[out]*/) = 0; // [1610809345]
  virtual HRESULT STDMETHODCALLTYPE GetOutputStream(Speechlib_tlb::ISpStreamFormat** ppStream/*[out]*/) = 0; // [1610809346]
  virtual HRESULT STDMETHODCALLTYPE Pause(void) = 0; // [1610809347]
  virtual HRESULT STDMETHODCALLTYPE Resume(void) = 0; // [1610809348]
  virtual HRESULT STDMETHODCALLTYPE SetVoice(Speechlib_tlb::ISpObjectToken* pToken/*[in]*/) = 0; // [1610809349]
  virtual HRESULT STDMETHODCALLTYPE GetVoice(Speechlib_tlb::ISpObjectToken** ppToken/*[out]*/) = 0; // [1610809350]
  virtual HRESULT STDMETHODCALLTYPE Speak(LPWSTR pwcs/*[in]*/, unsigned_long dwFlags/*[in]*/, 
                                          unsigned_long* pulStreamNumber/*[out]*/) = 0; // [1610809351]
  virtual HRESULT STDMETHODCALLTYPE SpeakStream(Speechlib_tlb::IStream* pStream/*[in]*/, 
                                                unsigned_long dwFlags/*[in]*/, 
                                                unsigned_long* pulStreamNumber/*[out]*/) = 0; // [1610809352]
  virtual HRESULT STDMETHODCALLTYPE GetStatus(Speechlib_tlb::SPVOICESTATUS* pStatus/*[out]*/, 
                                              LPWSTR* ppszLastBookmark/*[out]*/) = 0; // [1610809353]
  virtual HRESULT STDMETHODCALLTYPE Skip(LPWSTR pItemType/*[in]*/, long lNumItems/*[in]*/, 
                                         unsigned_long* pulNumSkipped/*[out]*/) = 0; // [1610809354]
  virtual HRESULT STDMETHODCALLTYPE SetPriority(Speechlib_tlb::SPVPRIORITY ePriority/*[in]*/) = 0; // [1610809355]
  virtual HRESULT STDMETHODCALLTYPE GetPriority(Speechlib_tlb::SPVPRIORITY* pePriority/*[out]*/) = 0; // [1610809356]
  virtual HRESULT STDMETHODCALLTYPE SetAlertBoundary(Speechlib_tlb::SPEVENTENUM eBoundary/*[in]*/) = 0; // [1610809357]
  virtual HRESULT STDMETHODCALLTYPE GetAlertBoundary(Speechlib_tlb::SPEVENTENUM* peBoundary/*[out]*/) = 0; // [1610809358]
  virtual HRESULT STDMETHODCALLTYPE SetRate(long RateAdjust/*[in]*/) = 0; // [1610809359]
  virtual HRESULT STDMETHODCALLTYPE GetRate(long* pRateAdjust/*[out]*/) = 0; // [1610809360]
  virtual HRESULT STDMETHODCALLTYPE SetVolume(unsigned_short usVolume/*[in]*/) = 0; // [1610809361]
  virtual HRESULT STDMETHODCALLTYPE GetVolume(unsigned_short* pusVolume/*[out]*/) = 0; // [1610809362]
  virtual HRESULT STDMETHODCALLTYPE WaitUntilDone(unsigned_long msTimeout/*[in]*/) = 0; // [1610809363]
  virtual HRESULT STDMETHODCALLTYPE SetSyncSpeakTimeout(unsigned_long msTimeout/*[in]*/) = 0; // [1610809364]
  virtual HRESULT STDMETHODCALLTYPE GetSyncSpeakTimeout(unsigned_long* pmsTimeout/*[out]*/) = 0; // [1610809365]
  virtual void* STDMETHODCALLTYPE SpeakCompleteEvent(void) = 0; // [1610809366]
  virtual HRESULT STDMETHODCALLTYPE IsUISupported(LPWSTR pszTypeOfUI/*[in]*/, 
                                                  void* pvExtraData/*[in]*/, 
                                                  unsigned_long cbExtraData/*[in]*/, 
                                                  long* pfSupported/*[out]*/) = 0; // [1610809367]
  virtual HRESULT STDMETHODCALLTYPE DisplayUI(Speechlib_tlb::wireHWND hWndParent/*[in]*/, 
                                              LPWSTR pszTitle/*[in]*/, LPWSTR pszTypeOfUI/*[in]*/, 
                                              void* pvExtraData/*[in]*/, 
                                              unsigned_long cbExtraData/*[in]*/) = 0; // [1610809368]
};

// *********************************************************************//
// Interface: ISpPhoneticAlphabetSelection
// Flags:     (512) Restricted
// GUID:      {B2745EFD-42CE-48CA-81F1-A96E02538A90}
// *********************************************************************//
interface ISpPhoneticAlphabetSelection  : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE IsAlphabetUPS(long* pfIsUPS/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE SetAlphabetToUPS(long fForceUPS/*[in]*/) = 0; // [-1]
};

// *********************************************************************//
// Interface: ISpRecoContext
// Flags:     (512) Restricted
// GUID:      {F740A62F-7C15-489E-8234-940A33D9272D}
// *********************************************************************//
interface ISpRecoContext  : public Speechlib_tlb::ISpEventSource
{
public:
  virtual HRESULT STDMETHODCALLTYPE GetRecognizer(Speechlib_tlb::ISpRecognizer** ppRecognizer/*[out]*/) = 0; // [1610809344]
  virtual HRESULT STDMETHODCALLTYPE CreateGrammar(unsigned_int64 ullGrammarID/*[in]*/, 
                                                  Speechlib_tlb::ISpRecoGrammar** ppGrammar/*[out]*/) = 0; // [1610809345]
  virtual HRESULT STDMETHODCALLTYPE GetStatus(Speechlib_tlb::SPRECOCONTEXTSTATUS* pStatus/*[out]*/) = 0; // [1610809346]
  virtual HRESULT STDMETHODCALLTYPE GetMaxAlternates(unsigned_long* pcAlternates/*[in]*/) = 0; // [1610809347]
  virtual HRESULT STDMETHODCALLTYPE SetMaxAlternates(unsigned_long cAlternates/*[in]*/) = 0; // [1610809348]
  virtual HRESULT STDMETHODCALLTYPE SetAudioOptions(Speechlib_tlb::SPAUDIOOPTIONS Options/*[in]*/, 
                                                    System::TGUID* pAudioFormatId/*[in]*/, 
                                                    Speechlib_tlb::WAVEFORMATEX* pWaveFormatEx/*[in]*/) = 0; // [1610809349]
  virtual HRESULT STDMETHODCALLTYPE GetAudioOptions(Speechlib_tlb::SPAUDIOOPTIONS* pOptions/*[in]*/, 
                                                    System::TGUID* pAudioFormatId/*[out]*/, 
                                                    Speechlib_tlb::WAVEFORMATEX** ppCoMemWFEX/*[out]*/) = 0; // [1610809350]
  virtual HRESULT STDMETHODCALLTYPE DeserializeResult(Speechlib_tlb::SPSERIALIZEDRESULT* pSerializedResult/*[in]*/, 
                                                      Speechlib_tlb::ISpRecoResult** ppResult/*[out]*/) = 0; // [1610809351]
  virtual HRESULT STDMETHODCALLTYPE Bookmark(Speechlib_tlb::SPBOOKMARKOPTIONS Options/*[in]*/, 
                                             unsigned_int64 ullStreamPosition/*[in]*/, 
                                             Speechlib_tlb::LONG_PTR lparamEvent/*[in]*/) = 0; // [1610809352]
  virtual HRESULT STDMETHODCALLTYPE SetAdaptationData(LPWSTR pAdaptationData/*[in]*/, 
                                                      unsigned_long cch/*[in]*/) = 0; // [1610809353]
  virtual HRESULT STDMETHODCALLTYPE Pause(unsigned_long dwReserved/*[in]*/) = 0; // [1610809354]
  virtual HRESULT STDMETHODCALLTYPE Resume(unsigned_long dwReserved/*[in]*/) = 0; // [1610809355]
  virtual HRESULT STDMETHODCALLTYPE SetVoice(Speechlib_tlb::ISpVoice* pVoice/*[in]*/, 
                                             long fAllowFormatChanges/*[in]*/) = 0; // [1610809356]
  virtual HRESULT STDMETHODCALLTYPE GetVoice(Speechlib_tlb::ISpVoice** ppVoice/*[out]*/) = 0; // [1610809357]
  virtual HRESULT STDMETHODCALLTYPE SetVoicePurgeEvent(unsigned_int64 ullEventInterest/*[in]*/) = 0; // [1610809358]
  virtual HRESULT STDMETHODCALLTYPE GetVoicePurgeEvent(unsigned_int64* pullEventInterest/*[out]*/) = 0; // [1610809359]
  virtual HRESULT STDMETHODCALLTYPE SetContextState(Speechlib_tlb::SPCONTEXTSTATE eContextState/*[in]*/) = 0; // [1610809360]
  virtual HRESULT STDMETHODCALLTYPE GetContextState(Speechlib_tlb::SPCONTEXTSTATE* peContextState/*[out]*/) = 0; // [1610809361]
};

// *********************************************************************//
// Interface: ISpRecoContext2
// Flags:     (512) Restricted
// GUID:      {BEAD311C-52FF-437F-9464-6B21054CA73D}
// *********************************************************************//
interface ISpRecoContext2  : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE SetGrammarOptions(unsigned_long eGrammarOptions/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetGrammarOptions(unsigned_long* peGrammarOptions/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE SetAdaptationData2(LPWSTR pAdaptationData/*[in]*/, 
                                                       unsigned_long cch/*[in]*/, 
                                                       LPWSTR pTopicName/*[in]*/, 
                                                       unsigned_long eAdaptationSettings/*[in]*/, 
                                                       Speechlib_tlb::SPADAPTATIONRELEVANCE eRelevance/*[in]*/) = 0; // [-1]
};

// *********************************************************************//
// Interface: ISpProperties
// Flags:     (512) Restricted
// GUID:      {5B4FB971-B115-4DE1-AD97-E482E3BF6EE4}
// *********************************************************************//
interface ISpProperties  : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE SetPropertyNum(LPWSTR pName/*[in]*/, long lValue/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetPropertyNum(LPWSTR pName/*[in]*/, long* plValue/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE SetPropertyString(LPWSTR pName/*[in]*/, LPWSTR pValue/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetPropertyString(LPWSTR pName/*[in]*/, 
                                                      LPWSTR* ppCoMemValue/*[out]*/) = 0; // [-1]
};

// *********************************************************************//
// Interface: ISpRecognizer
// Flags:     (512) Restricted
// GUID:      {C2B5F241-DAA0-4507-9E16-5A1EAA2B7A5C}
// *********************************************************************//
interface ISpRecognizer  : public Speechlib_tlb::ISpProperties
{
public:
  virtual HRESULT STDMETHODCALLTYPE SetRecognizer(Speechlib_tlb::ISpObjectToken* pRecognizer/*[in]*/) = 0; // [1610743808]
  virtual HRESULT STDMETHODCALLTYPE GetRecognizer(Speechlib_tlb::ISpObjectToken** ppRecognizer/*[out]*/) = 0; // [1610743809]
  virtual HRESULT STDMETHODCALLTYPE SetInput(LPUNKNOWN pUnkInput/*[in]*/, 
                                             long fAllowFormatChanges/*[in]*/) = 0; // [1610743810]
  virtual HRESULT STDMETHODCALLTYPE GetInputObjectToken(Speechlib_tlb::ISpObjectToken** ppToken/*[out]*/) = 0; // [1610743811]
  virtual HRESULT STDMETHODCALLTYPE GetInputStream(Speechlib_tlb::ISpStreamFormat** ppStream/*[out]*/) = 0; // [1610743812]
  virtual HRESULT STDMETHODCALLTYPE CreateRecoContext(Speechlib_tlb::ISpRecoContext** ppNewCtxt/*[out]*/) = 0; // [1610743813]
  virtual HRESULT STDMETHODCALLTYPE GetRecoProfile(Speechlib_tlb::ISpObjectToken** ppToken/*[out]*/) = 0; // [1610743814]
  virtual HRESULT STDMETHODCALLTYPE SetRecoProfile(Speechlib_tlb::ISpObjectToken* pToken/*[in]*/) = 0; // [1610743815]
  virtual HRESULT STDMETHODCALLTYPE IsSharedInstance(void) = 0; // [1610743816]
  virtual HRESULT STDMETHODCALLTYPE GetRecoState(Speechlib_tlb::SPRECOSTATE* pState/*[out]*/) = 0; // [1610743817]
  virtual HRESULT STDMETHODCALLTYPE SetRecoState(Speechlib_tlb::SPRECOSTATE NewState/*[in]*/) = 0; // [1610743818]
  virtual HRESULT STDMETHODCALLTYPE GetStatus(Speechlib_tlb::SPRECOGNIZERSTATUS* pStatus/*[out]*/) = 0; // [1610743819]
  virtual HRESULT STDMETHODCALLTYPE GetFormat(Speechlib_tlb::SPSTREAMFORMATTYPE WaveFormatType/*[in]*/, 
                                              System::TGUID* pFormatId/*[out]*/, 
                                              Speechlib_tlb::WAVEFORMATEX** ppCoMemWFEX/*[out]*/) = 0; // [1610743820]
  virtual HRESULT STDMETHODCALLTYPE IsUISupported(LPWSTR pszTypeOfUI/*[in]*/, 
                                                  void* pvExtraData/*[in]*/, 
                                                  unsigned_long cbExtraData/*[in]*/, 
                                                  long* pfSupported/*[out]*/) = 0; // [1610743821]
  virtual HRESULT STDMETHODCALLTYPE DisplayUI(Speechlib_tlb::wireHWND hWndParent/*[in]*/, 
                                              LPWSTR pszTitle/*[in]*/, LPWSTR pszTypeOfUI/*[in]*/, 
                                              void* pvExtraData/*[in]*/, 
                                              unsigned_long cbExtraData/*[in]*/) = 0; // [1610743822]
  virtual HRESULT STDMETHODCALLTYPE EmulateRecognition(Speechlib_tlb::ISpPhrase* pPhrase/*[in]*/) = 0; // [1610743823]
};

// *********************************************************************//
// Interface: ISpPhrase
// Flags:     (512) Restricted
// GUID:      {1A5C0354-B621-4B5A-8791-D306ED379E53}
// *********************************************************************//
interface ISpPhrase  : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE GetPhrase(Speechlib_tlb::SPPHRASE** ppCoMemPhrase/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetSerializedPhrase(Speechlib_tlb::SPSERIALIZEDPHRASE** ppCoMemPhrase/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetText(unsigned_long ulStart/*[in]*/, 
                                            unsigned_long ulCount/*[in]*/, 
                                            long fUseTextReplacements/*[in]*/, 
                                            LPWSTR* ppszCoMemText/*[out]*/, 
                                            unsigned_char* pbDisplayAttributes/*[out,opt]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE Discard(unsigned_long dwValueTypes/*[in]*/) = 0; // [-1]
};

// *********************************************************************//
// Interface: ISpGrammarBuilder
// Flags:     (512) Restricted
// GUID:      {8137828F-591A-4A42-BE58-49EA7EBAAC68}
// *********************************************************************//
interface ISpGrammarBuilder  : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE ResetGrammar(unsigned_short NewLanguage/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetRule(LPWSTR pszRuleName/*[in]*/, 
                                            unsigned_long dwRuleId/*[in]*/, 
                                            unsigned_long dwAttributes/*[in]*/, 
                                            long fCreateIfNotExist/*[in]*/, 
                                            void** phInitialState/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE ClearRule(void* hState/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE CreateNewState(void* hState/*[in]*/, void** phState/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE AddWordTransition(void* hFromState/*[in]*/, 
                                                      void* hToState/*[in]*/, LPWSTR psz/*[in]*/, 
                                                      LPWSTR pszSeparators/*[in]*/, 
                                                      Speechlib_tlb::SPGRAMMARWORDTYPE eWordType/*[in]*/, 
                                                      float Weight/*[in]*/, 
                                                      Speechlib_tlb::SPPROPERTYINFO* pPropInfo/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE AddRuleTransition(void* hFromState/*[in]*/, 
                                                      void* hToState/*[in]*/, void* hRule/*[in]*/, 
                                                      float Weight/*[in]*/, 
                                                      Speechlib_tlb::SPPROPERTYINFO* pPropInfo/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE AddResource(void* hRuleState/*[in]*/, 
                                                LPWSTR pszResourceName/*[in]*/, 
                                                LPWSTR pszResourceValue/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE Commit(unsigned_long dwReserved/*[in]*/) = 0; // [-1]
};

// *********************************************************************//
// Interface: ISpRecoGrammar
// Flags:     (512) Restricted
// GUID:      {2177DB29-7F45-47D0-8554-067E91C80502}
// *********************************************************************//
interface ISpRecoGrammar  : public Speechlib_tlb::ISpGrammarBuilder
{
public:
  virtual HRESULT STDMETHODCALLTYPE GetGrammarId(unsigned_int64* pullGrammarId/*[out]*/) = 0; // [1610743808]
  virtual HRESULT STDMETHODCALLTYPE GetRecoContext(Speechlib_tlb::ISpRecoContext** ppRecoCtxt/*[out]*/) = 0; // [1610743809]
  virtual HRESULT STDMETHODCALLTYPE LoadCmdFromFile(LPWSTR pszFileName/*[in]*/, 
                                                    Speechlib_tlb::SPLOADOPTIONS Options/*[in]*/) = 0; // [1610743810]
  virtual HRESULT STDMETHODCALLTYPE LoadCmdFromObject(System::TGUID* rcid/*[in]*/, 
                                                      LPWSTR pszGrammarName/*[in]*/, 
                                                      Speechlib_tlb::SPLOADOPTIONS Options/*[in]*/) = 0; // [1610743811]
  virtual HRESULT STDMETHODCALLTYPE LoadCmdFromResource(void* hModule/*[in]*/, 
                                                        LPWSTR pszResourceName/*[in]*/, 
                                                        LPWSTR pszResourceType/*[in]*/, 
                                                        unsigned_short wLanguage/*[in]*/, 
                                                        Speechlib_tlb::SPLOADOPTIONS Options/*[in]*/) = 0; // [1610743812]
  virtual HRESULT STDMETHODCALLTYPE LoadCmdFromMemory(Speechlib_tlb::SPBINARYGRAMMAR* pGrammar/*[in]*/, 
                                                      Speechlib_tlb::SPLOADOPTIONS Options/*[in]*/) = 0; // [1610743813]
  virtual HRESULT STDMETHODCALLTYPE LoadCmdFromProprietaryGrammar(System::TGUID* rguidParam/*[in]*/, 
                                                                  LPWSTR pszStringParam/*[in]*/, 
                                                                  void* pvDataPrarm/*[in]*/, 
                                                                  unsigned_long cbDataSize/*[in]*/, 
                                                                  Speechlib_tlb::SPLOADOPTIONS Options/*[in]*/) = 0; // [1610743814]
  virtual HRESULT STDMETHODCALLTYPE SetRuleState(LPWSTR pszName/*[in]*/, void* pReserved/*[in]*/, 
                                                 Speechlib_tlb::SPRULESTATE NewState/*[in]*/) = 0; // [1610743815]
  virtual HRESULT STDMETHODCALLTYPE SetRuleIdState(unsigned_long ulRuleId/*[in]*/, 
                                                   Speechlib_tlb::SPRULESTATE NewState/*[in]*/) = 0; // [1610743816]
  virtual HRESULT STDMETHODCALLTYPE LoadDictation(LPWSTR pszTopicName/*[in]*/, 
                                                  Speechlib_tlb::SPLOADOPTIONS Options/*[in]*/) = 0; // [1610743817]
  virtual HRESULT STDMETHODCALLTYPE UnloadDictation(void) = 0; // [1610743818]
  virtual HRESULT STDMETHODCALLTYPE SetDictationState(Speechlib_tlb::SPRULESTATE NewState/*[in]*/) = 0; // [1610743819]
  virtual HRESULT STDMETHODCALLTYPE SetWordSequenceData(unsigned_short* pText/*[in]*/, 
                                                        unsigned_long cchText/*[in]*/, 
                                                        Speechlib_tlb::SPTEXTSELECTIONINFO* pInfo/*[in]*/) = 0; // [1610743820]
  virtual HRESULT STDMETHODCALLTYPE SetTextSelection(Speechlib_tlb::SPTEXTSELECTIONINFO* pInfo/*[in]*/) = 0; // [1610743821]
  virtual HRESULT STDMETHODCALLTYPE IsPronounceable(LPWSTR pszWord/*[in]*/, 
                                                    Speechlib_tlb::SPWORDPRONOUNCEABLE* pWordPronounceable/*[out]*/) = 0; // [1610743822]
  virtual HRESULT STDMETHODCALLTYPE SetGrammarState(Speechlib_tlb::SPGRAMMARSTATE eGrammarState/*[in]*/) = 0; // [1610743823]
  virtual HRESULT STDMETHODCALLTYPE SaveCmd(Speechlib_tlb::IStream* pStream/*[in]*/, 
                                            LPWSTR* ppszCoMemErrorText/*[out,opt]*/) = 0; // [1610743824]
  virtual HRESULT STDMETHODCALLTYPE GetGrammarState(Speechlib_tlb::SPGRAMMARSTATE* peGrammarState/*[out]*/) = 0; // [1610743825]
};

// *********************************************************************//
// Interface: ISpRecoResult
// Flags:     (512) Restricted
// GUID:      {20B053BE-E235-43CD-9A2A-8D17A48B7842}
// *********************************************************************//
interface ISpRecoResult  : public Speechlib_tlb::ISpPhrase
{
public:
  virtual HRESULT STDMETHODCALLTYPE GetResultTimes(Speechlib_tlb::SPRECORESULTTIMES* pTimes/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetAlternates(unsigned_long ulStartElement/*[in]*/, 
                                                  unsigned_long cElements/*[in]*/, 
                                                  unsigned_long ulRequestCount/*[in]*/, 
                                                  Speechlib_tlb::ISpPhraseAlt** ppPhrases/*[out]*/, 
                                                  unsigned_long* pcPhrasesReturned/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetAudio(unsigned_long ulStartElement/*[in]*/, 
                                             unsigned_long cElements/*[in]*/, 
                                             Speechlib_tlb::ISpStreamFormat** ppStream/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE SpeakAudio(unsigned_long ulStartElement/*[in]*/, 
                                               unsigned_long cElements/*[in]*/, 
                                               unsigned_long dwFlags/*[in]*/, 
                                               unsigned_long* pulStreamNumber/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE Serialize(Speechlib_tlb::SPSERIALIZEDRESULT** ppCoMemSerializedResult/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE ScaleAudio(System::TGUID* pAudioFormatId/*[in]*/, 
                                               Speechlib_tlb::WAVEFORMATEX* pWaveFormatEx/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetRecoContext(Speechlib_tlb::ISpRecoContext** ppRecoContext/*[out]*/) = 0; // [-1]
};

// *********************************************************************//
// Interface: ISpPhraseAlt
// Flags:     (512) Restricted
// GUID:      {8FCEBC98-4E49-4067-9C6C-D86A0E092E3D}
// *********************************************************************//
interface ISpPhraseAlt  : public Speechlib_tlb::ISpPhrase
{
public:
  virtual HRESULT STDMETHODCALLTYPE GetAltInfo(Speechlib_tlb::ISpPhrase** ppParent/*[out]*/, 
                                               unsigned_long* pulStartElementInParent/*[out]*/, 
                                               unsigned_long* pcElementsInParent/*[out]*/, 
                                               unsigned_long* pcElementsInAlt/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE Commit(void) = 0; // [-1]
};

// *********************************************************************//
// Interface: ISpRecognizer2
// Flags:     (512) Restricted
// GUID:      {8FC6D974-C81E-4098-93C5-0147F61ED4D3}
// *********************************************************************//
interface ISpRecognizer2  : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE EmulateRecognitionEx(Speechlib_tlb::ISpPhrase* pPhrase/*[in]*/, 
                                                         unsigned_long dwCompareFlags/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE SetTrainingState(long fDoingTraining/*[in]*/, 
                                                     long fAdaptFromTrainingData/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE ResetAcousticModelAdaptation(void) = 0; // [-1]
};

// *********************************************************************//
// Interface: ISpRecognizer3
// Flags:     (512) Restricted
// GUID:      {DF1B943C-5838-4AA2-8706-D7CD5B333499}
// *********************************************************************//
interface ISpRecognizer3  : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE GetCategory(Speechlib_tlb::SPCATEGORYTYPE categoryType/*[in]*/, 
                                                Speechlib_tlb::ISpRecoCategory** ppCategory/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE SetActiveCategory(Speechlib_tlb::ISpRecoCategory* pCategory/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetActiveCategory(Speechlib_tlb::ISpRecoCategory** ppCategory/*[out]*/) = 0; // [-1]
};

// *********************************************************************//
// Interface: ISpSerializeState
// Flags:     (512) Restricted
// GUID:      {21B501A0-0EC7-46C9-92C3-A2BC784C54B9}
// *********************************************************************//
interface ISpSerializeState  : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE GetSerializedState(unsigned_char** ppbData/*[out]*/, 
                                                       unsigned_long* pulSize/*[out]*/, 
                                                       unsigned_long dwReserved/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE SetSerializedState(unsigned_char* pbData/*[in]*/, 
                                                       unsigned_long ulSize/*[in]*/, 
                                                       unsigned_long dwReserved/*[in]*/) = 0; // [-1]
};

// *********************************************************************//
// Interface: ISpRecoCategory
// Flags:     (512) Restricted
// GUID:      {DA0CD0F9-14A2-4F09-8C2A-85CC48979345}
// *********************************************************************//
interface ISpRecoCategory  : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE GetType(Speechlib_tlb::SPCATEGORYTYPE* peCategoryType/*[out]*/) = 0; // [-1]
};

// *********************************************************************//
// Interface: ISpLexicon
// Flags:     (512) Restricted
// GUID:      {DA41A7C2-5383-4DB2-916B-6C1719E3DB58}
// *********************************************************************//
interface ISpLexicon  : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE GetPronunciations(LPWSTR pszWord/*[in]*/, 
                                                      unsigned_short LangId/*[in]*/, 
                                                      unsigned_long dwFlags/*[in]*/, 
                                                      Speechlib_tlb::SPWORDPRONUNCIATIONLIST* pWordPronunciationList/*[in,out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE AddPronunciation(LPWSTR pszWord/*[in]*/, 
                                                     unsigned_short LangId/*[in]*/, 
                                                     Speechlib_tlb::SPPARTOFSPEECH ePartOfSpeech/*[in]*/, 
                                                     LPWSTR pszPronunciation/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE RemovePronunciation(LPWSTR pszWord/*[in]*/, 
                                                        unsigned_short LangId/*[in]*/, 
                                                        Speechlib_tlb::SPPARTOFSPEECH ePartOfSpeech/*[in]*/, 
                                                        LPWSTR pszPronunciation/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetGeneration(unsigned_long* pdwGeneration/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetGenerationChange(unsigned_long dwFlags/*[in]*/, 
                                                        unsigned_long* pdwGeneration/*[in,out]*/, 
                                                        Speechlib_tlb::SPWORDLIST* pWordList/*[in,out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetWords(unsigned_long dwFlags/*[in]*/, 
                                             unsigned_long* pdwGeneration/*[in,out]*/, 
                                             unsigned_long* pdwCookie/*[in,out]*/, 
                                             Speechlib_tlb::SPWORDLIST* pWordList/*[in,out]*/) = 0; // [-1]
};

// *********************************************************************//
// Interface: ISpShortcut
// Flags:     (512) Restricted
// GUID:      {3DF681E2-EA56-11D9-8BDE-F66BAD1E3F3A}
// *********************************************************************//
interface ISpShortcut  : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE AddShortcut(LPWSTR pszDisplay/*[in]*/, 
                                                unsigned_short LangId/*[in]*/, 
                                                LPWSTR pszSpoken/*[in]*/, 
                                                Speechlib_tlb::SPSHORTCUTTYPE shType/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE RemoveShortcut(LPWSTR pszDisplay/*[in]*/, 
                                                   unsigned_short LangId/*[in]*/, 
                                                   LPWSTR pszSpoken/*[in]*/, 
                                                   Speechlib_tlb::SPSHORTCUTTYPE shType/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetShortcuts(unsigned_short LangId/*[in]*/, 
                                                 Speechlib_tlb::SPSHORTCUTPAIRLIST* pShortcutpairList/*[in,out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetGeneration(unsigned_long* pdwGeneration/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetWordsFromGenerationChange(unsigned_long* pdwGeneration/*[in,out]*/, 
                                                                 Speechlib_tlb::SPWORDLIST* pWordList/*[in,out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetWords(unsigned_long* pdwGeneration/*[in,out]*/, 
                                             unsigned_long* pdwCookie/*[in,out]*/, 
                                             Speechlib_tlb::SPWORDLIST* pWordList/*[in,out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetShortcutsForGeneration(unsigned_long* pdwGeneration/*[in,out]*/, 
                                                              unsigned_long* pdwCookie/*[in,out]*/, 
                                                              Speechlib_tlb::SPSHORTCUTPAIRLIST* pShortcutpairList/*[in,out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetGenerationChange(unsigned_long* pdwGeneration/*[in,out]*/, 
                                                        Speechlib_tlb::SPSHORTCUTPAIRLIST* pShortcutpairList/*[in,out]*/) = 0; // [-1]
};

// *********************************************************************//
// Interface: ISpPhoneConverter
// Flags:     (512) Restricted
// GUID:      {8445C581-0CAC-4A38-ABFE-9B2CE2826455}
// *********************************************************************//
interface ISpPhoneConverter  : public Speechlib_tlb::ISpObjectWithToken
{
public:
  virtual HRESULT STDMETHODCALLTYPE PhoneToId(LPWSTR pszPhone/*[in]*/, unsigned_short* pId/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE IdToPhone(LPWSTR pId/*[in]*/, unsigned_short* pszPhone/*[out]*/) = 0; // [-1]
};

// *********************************************************************//
// Interface: ISpPhoneticAlphabetConverter
// Flags:     (512) Restricted
// GUID:      {133ADCD4-19B4-4020-9FDC-842E78253B17}
// *********************************************************************//
interface ISpPhoneticAlphabetConverter  : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE GetLangId(unsigned_short* pLangID/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE SetLangId(unsigned_short LangId/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE SAPI2UPS(unsigned_short* pszSAPIId/*[in]*/, 
                                             unsigned_short* pszUPSId/*[out]*/, 
                                             unsigned_long cMaxLength/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE UPS2SAPI(unsigned_short* pszUPSId/*[in]*/, 
                                             unsigned_short* pszSAPIId/*[out]*/, 
                                             unsigned_long cMaxLength/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetMaxConvertLength(unsigned_long cSrcLength/*[in]*/, 
                                                        long bSAPI2UPS/*[in]*/, 
                                                        unsigned_long* pcMaxDestLength/*[out]*/) = 0; // [-1]
};

// *********************************************************************//
// Interface: ISpXMLRecoResult
// Flags:     (512) Restricted
// GUID:      {AE39362B-45A8-4074-9B9E-CCF49AA2D0B6}
// *********************************************************************//
interface ISpXMLRecoResult  : public Speechlib_tlb::ISpRecoResult
{
public:
  virtual HRESULT STDMETHODCALLTYPE GetXMLResult(LPWSTR* ppszCoMemXMLResult/*[out]*/, 
                                                 Speechlib_tlb::SPXMLRESULTOPTIONS Options/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetXMLErrorInfo(Speechlib_tlb::SPSEMANTICERRORINFO* pSemanticErrorInfo/*[out]*/) = 0; // [-1]
};

// *********************************************************************//
// Interface: ISpRecoGrammar2
// Flags:     (512) Restricted
// GUID:      {4B37BC9E-9ED6-44A3-93D3-18F022B79EC3}
// *********************************************************************//
interface ISpRecoGrammar2  : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE GetRules(Speechlib_tlb::SPRULE** ppCoMemRules/*[out]*/, 
                                             unsigned* puNumRules/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE LoadCmdFromFile2(LPWSTR pszFileName/*[in]*/, 
                                                     Speechlib_tlb::SPLOADOPTIONS Options/*[in]*/, 
                                                     LPWSTR pszSharingUri/*[in]*/, 
                                                     LPWSTR pszBaseUri/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE LoadCmdFromMemory2(Speechlib_tlb::SPBINARYGRAMMAR* pGrammar/*[in]*/, 
                                                       Speechlib_tlb::SPLOADOPTIONS Options/*[in]*/, 
                                                       LPWSTR pszSharingUri/*[in]*/, 
                                                       LPWSTR pszBaseUri/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE SetRulePriority(LPWSTR pszRuleName/*[in]*/, 
                                                    unsigned_long ulRuleId/*[in]*/, 
                                                    int nRulePriority/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE SetRuleWeight(LPWSTR pszRuleName/*[in]*/, 
                                                  unsigned_long ulRuleId/*[in]*/, 
                                                  float flWeight/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE SetDictationWeight(float flWeight/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE SetGrammarLoader(Speechlib_tlb::ISpeechResourceLoader* pLoader/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE SetSMLSecurityManager(Speechlib_tlb::IInternetSecurityManager* pSMLSecurityManager/*[in]*/) = 0; // [-1]
};

// *********************************************************************//
// Interface: ISpeechResourceLoader
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {B9AC5783-FCD0-4B21-B119-B4F8DA8FD2C3}
// *********************************************************************//
interface ISpeechResourceLoader  : public IDispatch
{
public:
  virtual HRESULT STDMETHODCALLTYPE LoadResource(BSTR bstrResourceUri/*[in]*/, 
                                                 VARIANT_BOOL fAlwaysReload/*[in]*/, 
                                                 LPUNKNOWN* pStream/*[out]*/, 
                                                 BSTR* pbstrMIMEType/*[out]*/, 
                                                 VARIANT_BOOL* pfModified/*[out]*/, 
                                                 BSTR* pbstrRedirectUrl/*[out]*/) = 0; // [1]
  virtual HRESULT STDMETHODCALLTYPE GetLocalCopy(BSTR bstrResourceUri/*[in]*/, 
                                                 BSTR* pbstrLocalPath/*[out]*/, 
                                                 BSTR* pbstrMIMEType/*[out]*/, 
                                                 BSTR* pbstrRedirectUrl/*[out]*/) = 0; // [2]
  virtual HRESULT STDMETHODCALLTYPE ReleaseLocalCopy(BSTR pbstrLocalPath/*[in]*/) = 0; // [3]

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)



#endif //   __TLB_NO_INTERFACE_WRAPPERS

};

// *********************************************************************//
// Interface: IInternetSecurityManager
// Flags:     (0)
// GUID:      {79EAC9EE-BAF9-11CE-8C82-00AA004BA90B}
// *********************************************************************//
interface IInternetSecurityManager  : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE SetSecuritySite(Speechlib_tlb::IInternetSecurityMgrSite* pSite/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetSecuritySite(Speechlib_tlb::IInternetSecurityMgrSite** ppSite/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE MapUrlToZone(LPWSTR pwszUrl/*[in]*/, 
                                                 unsigned_long* pdwZone/*[out]*/, 
                                                 unsigned_long dwFlags/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetSecurityId(LPWSTR pwszUrl/*[in]*/, 
                                                  unsigned_char* pbSecurityId/*[out]*/, 
                                                  unsigned_long* pcbSecurityId/*[in,out]*/, 
                                                  Speechlib_tlb::ULONG_PTR dwReserved/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE ProcessUrlAction(LPWSTR pwszUrl/*[in]*/, 
                                                     unsigned_long dwAction/*[in]*/, 
                                                     unsigned_char* pPolicy/*[out]*/, 
                                                     unsigned_long cbPolicy/*[in]*/, 
                                                     unsigned_char* pContext/*[in]*/, 
                                                     unsigned_long cbContext/*[in]*/, 
                                                     unsigned_long dwFlags/*[in]*/, 
                                                     unsigned_long dwReserved/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE QueryCustomPolicy(LPWSTR pwszUrl/*[in]*/, 
                                                      System::TGUID* guidKey/*[in]*/, 
                                                      unsigned_char** ppPolicy/*[out]*/, 
                                                      unsigned_long* pcbPolicy/*[out]*/, 
                                                      unsigned_char* pContext/*[in]*/, 
                                                      unsigned_long cbContext/*[in]*/, 
                                                      unsigned_long dwReserved/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE SetZoneMapping(unsigned_long dwZone/*[in]*/, 
                                                   LPWSTR lpszPattern/*[in]*/, 
                                                   unsigned_long dwFlags/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE GetZoneMappings(unsigned_long dwZone/*[in]*/, 
                                                    Speechlib_tlb::IEnumString** ppenumString/*[out]*/, 
                                                    unsigned_long dwFlags/*[in]*/) = 0; // [-1]
};

// *********************************************************************//
// Interface: IInternetSecurityMgrSite
// Flags:     (0)
// GUID:      {79EAC9ED-BAF9-11CE-8C82-00AA004BA90B}
// *********************************************************************//
interface IInternetSecurityMgrSite  : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE GetWindow(Speechlib_tlb::wireHWND* phwnd/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE EnableModeless(long fEnable/*[in]*/) = 0; // [-1]
};

// *********************************************************************//
// Interface: IEnumString
// Flags:     (0)
// GUID:      {00000101-0000-0000-C000-000000000046}
// *********************************************************************//
interface IEnumString  : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE RemoteNext(unsigned_long celt/*[in]*/, LPWSTR* rgelt/*[out]*/, 
                                               unsigned_long* pceltFetched/*[out]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE Skip(unsigned_long celt/*[in]*/) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE Reset(void) = 0; // [-1]
  virtual HRESULT STDMETHODCALLTYPE Clone(Speechlib_tlb::IEnumString** ppEnum/*[out]*/) = 0; // [-1]
};

#if !defined(__TLB_NO_INTERFACE_WRAPPERS)
typedef TComInterface<ISpeechDataKey>  TCOMISpeechDataKey;

// *********************************************************************//
// DispIntf:  ISpeechDataKey
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {CE17C09B-4EFA-44D5-A4C9-59D9585AB0CD}
// *********************************************************************//
template<class T>
class ISpeechDataKeyDispT : public TAutoDriver<ISpeechDataKey>
{
public:
  ISpeechDataKeyDispT(){}

  ISpeechDataKeyDispT(ISpeechDataKey *pintf)
  {
    TAutoDriver<ISpeechDataKey>::Bind(pintf, false);
  }

  ISpeechDataKeyDispT(ISpeechDataKeyPtr pintf)
  {
    TAutoDriver<ISpeechDataKey>::Bind(pintf, true);
  }

  ISpeechDataKeyDispT& operator=(ISpeechDataKey *pintf)
  {
    TAutoDriver<ISpeechDataKey>::Bind(pintf, false);
    return *this;
  }

  ISpeechDataKeyDispT& operator=(ISpeechDataKeyPtr pintf)
  {
    TAutoDriver<ISpeechDataKey>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall SetBinaryValue(BSTR ValueName/*[in]*/, VARIANT Value/*[in]*/);
  HRESULT         __fastcall GetBinaryValue(BSTR ValueName/*[in]*/, VARIANT* Value/*[out,retval]*/);
  VARIANT         __fastcall GetBinaryValue(BSTR ValueName/*[in]*/);
  HRESULT         __fastcall SetStringValue(BSTR ValueName/*[in]*/, BSTR Value/*[in]*/);
  HRESULT         __fastcall GetStringValue(BSTR ValueName/*[in]*/, BSTR* Value/*[out,retval]*/);
  BSTR            __fastcall GetStringValue(BSTR ValueName/*[in]*/);
  HRESULT         __fastcall SetLongValue(BSTR ValueName/*[in]*/, long Value/*[in]*/);
  HRESULT         __fastcall GetLongValue(BSTR ValueName/*[in]*/, long* Value/*[out,retval]*/);
  long            __fastcall GetLongValue(BSTR ValueName/*[in]*/);
  HRESULT         __fastcall OpenKey(BSTR SubKeyName/*[in]*/, 
                                     Speechlib_tlb::ISpeechDataKey** SubKey/*[out,retval]*/);
  Speechlib_tlb::ISpeechDataKey* __fastcall OpenKey(BSTR SubKeyName/*[in]*/);
  HRESULT         __fastcall CreateKey(BSTR SubKeyName/*[in]*/, 
                                       Speechlib_tlb::ISpeechDataKey** SubKey/*[out,retval]*/);
  Speechlib_tlb::ISpeechDataKey* __fastcall CreateKey(BSTR SubKeyName/*[in]*/);
  HRESULT         __fastcall DeleteKey(BSTR SubKeyName/*[in]*/);
  HRESULT         __fastcall DeleteValue(BSTR ValueName/*[in]*/);
  HRESULT         __fastcall EnumKeys(long Index/*[in]*/, BSTR* SubKeyName/*[out,retval]*/);
  BSTR            __fastcall EnumKeys(long Index/*[in]*/);
  HRESULT         __fastcall EnumValues(long Index/*[in]*/, BSTR* ValueName/*[out,retval]*/);
  BSTR            __fastcall EnumValues(long Index/*[in]*/);

};
typedef ISpeechDataKeyDispT<ISpeechDataKey> ISpeechDataKeyDisp;

// *********************************************************************//
// SmartIntf: TCOMISpeechObjectToken
// Interface: ISpeechObjectToken
// *********************************************************************//
template <class T /* ISpeechObjectToken */ >
class TCOMISpeechObjectTokenT : public TComInterface<ISpeechObjectToken>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMISpeechObjectTokenT() {}
  TCOMISpeechObjectTokenT(ISpeechObjectToken *intf, bool addRef = false) : TComInterface<ISpeechObjectToken>(intf, addRef) {}
  TCOMISpeechObjectTokenT(const TCOMISpeechObjectTokenT& src) : TComInterface<ISpeechObjectToken>(src) {}
  TCOMISpeechObjectTokenT& operator=(const TCOMISpeechObjectTokenT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall get_Id(BSTR* ObjectId/*[out,retval]*/);
  BSTR            __fastcall get_Id(void);
  HRESULT         __fastcall get_DataKey(Speechlib_tlb::ISpeechDataKey** DataKey/*[out,retval]*/);
  Speechlib_tlb::ISpeechDataKeyPtr __fastcall get_DataKey(void);
  HRESULT         __fastcall get_Category(Speechlib_tlb::ISpeechObjectTokenCategory** Category/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectTokenCategoryPtr __fastcall get_Category(void);
  HRESULT         __fastcall GetDescription(long Locale/*[in,def,opt]*/, 
                                            BSTR* Description/*[out,retval]*/);
  BSTR            __fastcall GetDescription(long Locale/*[in,def,opt]*/);
  HRESULT         __fastcall SetId(BSTR Id/*[in]*/, BSTR CategoryID/*[in,def,opt]*/, 
                                   VARIANT_BOOL CreateIfNotExist/*[in,def,opt]*/);
  HRESULT         __fastcall GetAttribute(BSTR AttributeName/*[in]*/, 
                                          BSTR* AttributeValue/*[out,retval]*/);
  BSTR            __fastcall GetAttribute(BSTR AttributeName/*[in]*/);
  HRESULT         __fastcall CreateInstance(LPUNKNOWN pUnkOuter/*[in,def,opt]*/, 
                                            Speechlib_tlb::SpeechTokenContext ClsContext/*[in,def,opt]*/, 
                                            LPUNKNOWN* Object/*[out,retval]*/);
  LPUNKNOWN       __fastcall CreateInstance(LPUNKNOWN pUnkOuter/*[in,def,opt]*/, 
                                            Speechlib_tlb::SpeechTokenContext ClsContext/*[in,def,opt]*/);
  HRESULT         __fastcall Remove(BSTR ObjectStorageCLSID/*[in]*/);
  HRESULT         __fastcall GetStorageFileName(BSTR ObjectStorageCLSID/*[in]*/, 
                                                BSTR KeyName/*[in]*/, BSTR FileName/*[in]*/, 
                                                Speechlib_tlb::SpeechTokenShellFolder Folder/*[in]*/, 
                                                BSTR* FilePath/*[out,retval]*/);
  BSTR            __fastcall GetStorageFileName(BSTR ObjectStorageCLSID/*[in]*/, 
                                                BSTR KeyName/*[in]*/, BSTR FileName/*[in]*/, 
                                                Speechlib_tlb::SpeechTokenShellFolder Folder/*[in]*/);
  HRESULT         __fastcall RemoveStorageFileName(BSTR ObjectStorageCLSID/*[in]*/, 
                                                   BSTR KeyName/*[in]*/, 
                                                   VARIANT_BOOL DeleteFile/*[in]*/);
  HRESULT         __fastcall IsUISupported(BSTR TypeOfUI/*[in]*/, VARIANT* ExtraData/*[in,def,opt]*/, 
                                           LPUNKNOWN Object/*[in,def,opt]*/, 
                                           VARIANT_BOOL* Supported/*[out,retval]*/);
  VARIANT_BOOL    __fastcall IsUISupported(BSTR TypeOfUI/*[in]*/, VARIANT* ExtraData/*[in,def,opt]*/, 
                                           LPUNKNOWN Object/*[in,def,opt]*/);
  HRESULT         __fastcall DisplayUI(long hWnd/*[in]*/, BSTR Title/*[in]*/, BSTR TypeOfUI/*[in]*/, 
                                       VARIANT* ExtraData/*[in,def,opt]*/, 
                                       LPUNKNOWN Object/*[in,def,opt]*/);
  HRESULT         __fastcall MatchesAttributes(BSTR Attributes/*[in]*/, 
                                               VARIANT_BOOL* Matches/*[out,retval]*/);
  VARIANT_BOOL    __fastcall MatchesAttributes(BSTR Attributes/*[in]*/);

  __property   BSTR            Id = {read = get_Id};
  __property   Speechlib_tlb::ISpeechDataKeyPtr DataKey = {read = get_DataKey};
  __property   Speechlib_tlb::ISpeechObjectTokenCategoryPtr Category = {read = get_Category};
};
typedef TCOMISpeechObjectTokenT<ISpeechObjectToken> TCOMISpeechObjectToken;

// *********************************************************************//
// DispIntf:  ISpeechObjectToken
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {C74A3ADC-B727-4500-A84A-B526721C8B8C}
// *********************************************************************//
template<class T>
class ISpeechObjectTokenDispT : public TAutoDriver<ISpeechObjectToken>
{
public:
  ISpeechObjectTokenDispT(){}

  ISpeechObjectTokenDispT(ISpeechObjectToken *pintf)
  {
    TAutoDriver<ISpeechObjectToken>::Bind(pintf, false);
  }

  ISpeechObjectTokenDispT(ISpeechObjectTokenPtr pintf)
  {
    TAutoDriver<ISpeechObjectToken>::Bind(pintf, true);
  }

  ISpeechObjectTokenDispT& operator=(ISpeechObjectToken *pintf)
  {
    TAutoDriver<ISpeechObjectToken>::Bind(pintf, false);
    return *this;
  }

  ISpeechObjectTokenDispT& operator=(ISpeechObjectTokenPtr pintf)
  {
    TAutoDriver<ISpeechObjectToken>::Bind(pintf, true);
    return *this;
  }

  HRESULT BindDefault()
  {
    return OLECHECK(Bind(CLSID_SpObjectToken));
  }

  HRESULT BindRunning()
  {
    return BindToActive(CLSID_SpObjectToken);
  }

  HRESULT         __fastcall get_Id(BSTR* ObjectId/*[out,retval]*/);
  BSTR            __fastcall get_Id(void);
  HRESULT         __fastcall get_DataKey(Speechlib_tlb::ISpeechDataKey** DataKey/*[out,retval]*/);
  Speechlib_tlb::ISpeechDataKeyPtr __fastcall get_DataKey(void);
  HRESULT         __fastcall get_Category(Speechlib_tlb::ISpeechObjectTokenCategory** Category/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectTokenCategoryPtr __fastcall get_Category(void);
  HRESULT         __fastcall GetDescription(long Locale/*[in,def,opt]*/, 
                                            BSTR* Description/*[out,retval]*/);
  BSTR            __fastcall GetDescription(long Locale/*[in,def,opt]*/);
  HRESULT         __fastcall SetId(BSTR Id/*[in]*/, BSTR CategoryID/*[in,def,opt]*/, 
                                   VARIANT_BOOL CreateIfNotExist/*[in,def,opt]*/);
  HRESULT         __fastcall GetAttribute(BSTR AttributeName/*[in]*/, 
                                          BSTR* AttributeValue/*[out,retval]*/);
  BSTR            __fastcall GetAttribute(BSTR AttributeName/*[in]*/);
  HRESULT         __fastcall CreateInstance(LPUNKNOWN pUnkOuter/*[in,def,opt]*/, 
                                            Speechlib_tlb::SpeechTokenContext ClsContext/*[in,def,opt]*/
                                            , LPUNKNOWN* Object/*[out,retval]*/);
  LPUNKNOWN       __fastcall CreateInstance(LPUNKNOWN pUnkOuter/*[in,def,opt]*/, 
                                            Speechlib_tlb::SpeechTokenContext ClsContext/*[in,def,opt]*/);
  HRESULT         __fastcall Remove(BSTR ObjectStorageCLSID/*[in]*/);
  HRESULT         __fastcall GetStorageFileName(BSTR ObjectStorageCLSID/*[in]*/, 
                                                BSTR KeyName/*[in]*/, BSTR FileName/*[in]*/, 
                                                Speechlib_tlb::SpeechTokenShellFolder Folder/*[in]*/
                                                , BSTR* FilePath/*[out,retval]*/);
  BSTR            __fastcall GetStorageFileName(BSTR ObjectStorageCLSID/*[in]*/, 
                                                BSTR KeyName/*[in]*/, BSTR FileName/*[in]*/, 
                                                Speechlib_tlb::SpeechTokenShellFolder Folder/*[in]*/);
  HRESULT         __fastcall RemoveStorageFileName(BSTR ObjectStorageCLSID/*[in]*/, 
                                                   BSTR KeyName/*[in]*/, 
                                                   VARIANT_BOOL DeleteFile/*[in]*/);
  HRESULT         __fastcall IsUISupported(BSTR TypeOfUI/*[in]*/, VARIANT* ExtraData/*[in,def,opt]*/
                                           , LPUNKNOWN Object/*[in,def,opt]*/, 
                                           VARIANT_BOOL* Supported/*[out,retval]*/);
  VARIANT_BOOL    __fastcall IsUISupported(BSTR TypeOfUI/*[in]*/, VARIANT* ExtraData/*[in,def,opt]*/, 
                                           LPUNKNOWN Object/*[in,def,opt]*/);
  HRESULT         __fastcall DisplayUI(long hWnd/*[in]*/, BSTR Title/*[in]*/, BSTR TypeOfUI/*[in]*/
                                       , VARIANT* ExtraData/*[in,def,opt]*/, 
                                       LPUNKNOWN Object/*[in,def,opt]*/);
  HRESULT         __fastcall MatchesAttributes(BSTR Attributes/*[in]*/, 
                                               VARIANT_BOOL* Matches/*[out,retval]*/);
  VARIANT_BOOL    __fastcall MatchesAttributes(BSTR Attributes/*[in]*/);

  __property   BSTR            Id = {read = get_Id};
  __property   Speechlib_tlb::ISpeechDataKeyPtr DataKey = {read = get_DataKey};
  __property   Speechlib_tlb::ISpeechObjectTokenCategoryPtr Category = {read = get_Category};
};
typedef ISpeechObjectTokenDispT<ISpeechObjectToken> ISpeechObjectTokenDisp;

// *********************************************************************//
// SmartIntf: TCOMISpeechObjectTokenCategory
// Interface: ISpeechObjectTokenCategory
// *********************************************************************//
template <class T /* ISpeechObjectTokenCategory */ >
class TCOMISpeechObjectTokenCategoryT : public TComInterface<ISpeechObjectTokenCategory>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMISpeechObjectTokenCategoryT() {}
  TCOMISpeechObjectTokenCategoryT(ISpeechObjectTokenCategory *intf, bool addRef = false) : TComInterface<ISpeechObjectTokenCategory>(intf, addRef) {}
  TCOMISpeechObjectTokenCategoryT(const TCOMISpeechObjectTokenCategoryT& src) : TComInterface<ISpeechObjectTokenCategory>(src) {}
  TCOMISpeechObjectTokenCategoryT& operator=(const TCOMISpeechObjectTokenCategoryT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall get_Id(BSTR* Id/*[out,retval]*/);
  BSTR            __fastcall get_Id(void);
  HRESULT         __fastcall set_Default(BSTR TokenId/*[in]*/);
  HRESULT         __fastcall get_Default(BSTR* TokenId/*[out,retval]*/);
  BSTR            __fastcall get_Default(void);
  HRESULT         __fastcall SetId(BSTR Id/*[in]*/, VARIANT_BOOL CreateIfNotExist/*[in,def,opt]*/);
  HRESULT         __fastcall GetDataKey(Speechlib_tlb::SpeechDataKeyLocation Location/*[in,def,opt]*/, 
                                        Speechlib_tlb::ISpeechDataKey** DataKey/*[out,retval]*/);
  Speechlib_tlb::ISpeechDataKey* __fastcall GetDataKey(Speechlib_tlb::SpeechDataKeyLocation Location/*[in,def,opt]*/);
  HRESULT         __fastcall EnumerateTokens(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                             BSTR OptionalAttributes/*[in,def,opt]*/, 
                                             Speechlib_tlb::ISpeechObjectTokens** Tokens/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectTokens* __fastcall EnumerateTokens(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                                 BSTR OptionalAttributes/*[in,def,opt]*/);

  __property   BSTR            Id = {read = get_Id};
  __property   BSTR            Default = {read = get_Default, write = set_Default};
};
typedef TCOMISpeechObjectTokenCategoryT<ISpeechObjectTokenCategory> TCOMISpeechObjectTokenCategory;

// *********************************************************************//
// DispIntf:  ISpeechObjectTokenCategory
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {CA7EAC50-2D01-4145-86D4-5AE7D70F4469}
// *********************************************************************//
template<class T>
class ISpeechObjectTokenCategoryDispT : public TAutoDriver<ISpeechObjectTokenCategory>
{
public:
  ISpeechObjectTokenCategoryDispT(){}

  ISpeechObjectTokenCategoryDispT(ISpeechObjectTokenCategory *pintf)
  {
    TAutoDriver<ISpeechObjectTokenCategory>::Bind(pintf, false);
  }

  ISpeechObjectTokenCategoryDispT(ISpeechObjectTokenCategoryPtr pintf)
  {
    TAutoDriver<ISpeechObjectTokenCategory>::Bind(pintf, true);
  }

  ISpeechObjectTokenCategoryDispT& operator=(ISpeechObjectTokenCategory *pintf)
  {
    TAutoDriver<ISpeechObjectTokenCategory>::Bind(pintf, false);
    return *this;
  }

  ISpeechObjectTokenCategoryDispT& operator=(ISpeechObjectTokenCategoryPtr pintf)
  {
    TAutoDriver<ISpeechObjectTokenCategory>::Bind(pintf, true);
    return *this;
  }

  HRESULT BindDefault()
  {
    return OLECHECK(Bind(CLSID_SpObjectTokenCategory));
  }

  HRESULT BindRunning()
  {
    return BindToActive(CLSID_SpObjectTokenCategory);
  }

  HRESULT         __fastcall get_Id(BSTR* Id/*[out,retval]*/);
  BSTR            __fastcall get_Id(void);
  HRESULT         __fastcall set_Default(BSTR TokenId/*[in]*/);
  HRESULT         __fastcall get_Default(BSTR* TokenId/*[out,retval]*/);
  BSTR            __fastcall get_Default(void);
  HRESULT         __fastcall SetId(BSTR Id/*[in]*/, VARIANT_BOOL CreateIfNotExist/*[in,def,opt]*/);
  HRESULT         __fastcall GetDataKey(Speechlib_tlb::SpeechDataKeyLocation Location/*[in,def,opt]*/
                                        , Speechlib_tlb::ISpeechDataKey** DataKey/*[out,retval]*/);
  Speechlib_tlb::ISpeechDataKey* __fastcall GetDataKey(Speechlib_tlb::SpeechDataKeyLocation Location/*[in,def,opt]*/);
  HRESULT         __fastcall EnumerateTokens(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                             BSTR OptionalAttributes/*[in,def,opt]*/, 
                                             Speechlib_tlb::ISpeechObjectTokens** Tokens/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectTokens* __fastcall EnumerateTokens(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                                 BSTR OptionalAttributes/*[in,def,opt]*/);

  __property   BSTR            Id = {read = get_Id};
  __property   BSTR            Default = {read = get_Default, write = set_Default};
};
typedef ISpeechObjectTokenCategoryDispT<ISpeechObjectTokenCategory> ISpeechObjectTokenCategoryDisp;

typedef TComInterface<ISpeechObjectTokens>  TCOMISpeechObjectTokens;

// *********************************************************************//
// DispIntf:  ISpeechObjectTokens
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {9285B776-2E7B-4BC0-B53E-580EB6FA967F}
// *********************************************************************//
template<class T>
class ISpeechObjectTokensDispT : public TAutoDriver<ISpeechObjectTokens>
{
public:
  ISpeechObjectTokensDispT(){}

  ISpeechObjectTokensDispT(ISpeechObjectTokens *pintf)
  {
    TAutoDriver<ISpeechObjectTokens>::Bind(pintf, false);
  }

  ISpeechObjectTokensDispT(ISpeechObjectTokensPtr pintf)
  {
    TAutoDriver<ISpeechObjectTokens>::Bind(pintf, true);
  }

  ISpeechObjectTokensDispT& operator=(ISpeechObjectTokens *pintf)
  {
    TAutoDriver<ISpeechObjectTokens>::Bind(pintf, false);
    return *this;
  }

  ISpeechObjectTokensDispT& operator=(ISpeechObjectTokensPtr pintf)
  {
    TAutoDriver<ISpeechObjectTokens>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_Count(long* Count/*[out,retval]*/);
  long            __fastcall get_Count(void);
  HRESULT         __fastcall Item(long Index/*[in]*/, 
                                  Speechlib_tlb::ISpeechObjectToken** Token/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectToken* __fastcall Item(long Index/*[in]*/);
  HRESULT         __fastcall get__NewEnum(LPUNKNOWN* ppEnumVARIANT/*[out,retval]*/);
  LPUNKNOWN       __fastcall get__NewEnum(void);

  __property   long            Count = {read = get_Count};
  __property   LPUNKNOWN       _NewEnum = {read = get__NewEnum};
};
typedef ISpeechObjectTokensDispT<ISpeechObjectTokens> ISpeechObjectTokensDisp;

typedef TComInterface<ISpeechAudioBufferInfo>  TCOMISpeechAudioBufferInfo;

// *********************************************************************//
// DispIntf:  ISpeechAudioBufferInfo
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {11B103D8-1142-4EDF-A093-82FB3915F8CC}
// *********************************************************************//
template<class T>
class ISpeechAudioBufferInfoDispT : public TAutoDriver<ISpeechAudioBufferInfo>
{
public:
  ISpeechAudioBufferInfoDispT(){}

  ISpeechAudioBufferInfoDispT(ISpeechAudioBufferInfo *pintf)
  {
    TAutoDriver<ISpeechAudioBufferInfo>::Bind(pintf, false);
  }

  ISpeechAudioBufferInfoDispT(ISpeechAudioBufferInfoPtr pintf)
  {
    TAutoDriver<ISpeechAudioBufferInfo>::Bind(pintf, true);
  }

  ISpeechAudioBufferInfoDispT& operator=(ISpeechAudioBufferInfo *pintf)
  {
    TAutoDriver<ISpeechAudioBufferInfo>::Bind(pintf, false);
    return *this;
  }

  ISpeechAudioBufferInfoDispT& operator=(ISpeechAudioBufferInfoPtr pintf)
  {
    TAutoDriver<ISpeechAudioBufferInfo>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_MinNotification(long* MinNotification/*[out,retval]*/);
  long            __fastcall get_MinNotification(void);
  HRESULT         __fastcall set_MinNotification(long MinNotification/*[in]*/);
  HRESULT         __fastcall get_BufferSize(long* BufferSize/*[out,retval]*/);
  long            __fastcall get_BufferSize(void);
  HRESULT         __fastcall set_BufferSize(long BufferSize/*[in]*/);
  HRESULT         __fastcall get_EventBias(long* EventBias/*[out,retval]*/);
  long            __fastcall get_EventBias(void);
  HRESULT         __fastcall set_EventBias(long EventBias/*[in]*/);

  __property   long            MinNotification = {read = get_MinNotification, write = set_MinNotification};
  __property   long            BufferSize = {read = get_BufferSize, write = set_BufferSize};
  __property   long            EventBias = {read = get_EventBias, write = set_EventBias};
};
typedef ISpeechAudioBufferInfoDispT<ISpeechAudioBufferInfo> ISpeechAudioBufferInfoDisp;

typedef TComInterface<ISpeechAudioStatus>  TCOMISpeechAudioStatus;

// *********************************************************************//
// DispIntf:  ISpeechAudioStatus
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {C62D9C91-7458-47F6-862D-1EF86FB0B278}
// *********************************************************************//
template<class T>
class ISpeechAudioStatusDispT : public TAutoDriver<ISpeechAudioStatus>
{
public:
  ISpeechAudioStatusDispT(){}

  ISpeechAudioStatusDispT(ISpeechAudioStatus *pintf)
  {
    TAutoDriver<ISpeechAudioStatus>::Bind(pintf, false);
  }

  ISpeechAudioStatusDispT(ISpeechAudioStatusPtr pintf)
  {
    TAutoDriver<ISpeechAudioStatus>::Bind(pintf, true);
  }

  ISpeechAudioStatusDispT& operator=(ISpeechAudioStatus *pintf)
  {
    TAutoDriver<ISpeechAudioStatus>::Bind(pintf, false);
    return *this;
  }

  ISpeechAudioStatusDispT& operator=(ISpeechAudioStatusPtr pintf)
  {
    TAutoDriver<ISpeechAudioStatus>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_FreeBufferSpace(long* FreeBufferSpace/*[out,retval]*/);
  long            __fastcall get_FreeBufferSpace(void);
  HRESULT         __fastcall get_NonBlockingIO(long* NonBlockingIO/*[out,retval]*/);
  long            __fastcall get_NonBlockingIO(void);
  HRESULT         __fastcall get_State(Speechlib_tlb::SpeechAudioState* State/*[out,retval]*/);
  Speechlib_tlb::SpeechAudioState __fastcall get_State(void);
  HRESULT         __fastcall get_CurrentSeekPosition(VARIANT* CurrentSeekPosition/*[out,retval]*/);
  VARIANT         __fastcall get_CurrentSeekPosition(void);
  HRESULT         __fastcall get_CurrentDevicePosition(VARIANT* CurrentDevicePosition/*[out,retval]*/);
  VARIANT         __fastcall get_CurrentDevicePosition(void);

  __property   long            FreeBufferSpace = {read = get_FreeBufferSpace};
  __property   long            NonBlockingIO = {read = get_NonBlockingIO};
  __property   Speechlib_tlb::SpeechAudioState State = {read = get_State};
};
typedef ISpeechAudioStatusDispT<ISpeechAudioStatus> ISpeechAudioStatusDisp;

// *********************************************************************//
// SmartIntf: TCOMISpeechAudioFormat
// Interface: ISpeechAudioFormat
// *********************************************************************//
template <class T /* ISpeechAudioFormat */ >
class TCOMISpeechAudioFormatT : public TComInterface<ISpeechAudioFormat>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMISpeechAudioFormatT() {}
  TCOMISpeechAudioFormatT(ISpeechAudioFormat *intf, bool addRef = false) : TComInterface<ISpeechAudioFormat>(intf, addRef) {}
  TCOMISpeechAudioFormatT(const TCOMISpeechAudioFormatT& src) : TComInterface<ISpeechAudioFormat>(src) {}
  TCOMISpeechAudioFormatT& operator=(const TCOMISpeechAudioFormatT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall get_Type(Speechlib_tlb::SpeechAudioFormatType* AudioFormat/*[out,retval]*/);
  Speechlib_tlb::SpeechAudioFormatType __fastcall get_Type(void);
  HRESULT         __fastcall set_Type(Speechlib_tlb::SpeechAudioFormatType AudioFormat/*[in]*/);
  HRESULT         __fastcall get_Guid(BSTR* Guid/*[out,retval]*/);
  BSTR            __fastcall get_Guid(void);
  HRESULT         __fastcall set_Guid(BSTR Guid/*[in]*/);
  HRESULT         __fastcall GetWaveFormatEx(Speechlib_tlb::ISpeechWaveFormatEx** SpeechWaveFormatEx/*[out,retval]*/);
  Speechlib_tlb::ISpeechWaveFormatEx* __fastcall GetWaveFormatEx(void);
  HRESULT         __fastcall SetWaveFormatEx(Speechlib_tlb::ISpeechWaveFormatEx* SpeechWaveFormatEx/*[in]*/);

  __property   Speechlib_tlb::SpeechAudioFormatType Type = {read = get_Type, write = set_Type};
  __property   BSTR            Guid = {read = get_Guid, write = set_Guid};
};
typedef TCOMISpeechAudioFormatT<ISpeechAudioFormat> TCOMISpeechAudioFormat;

// *********************************************************************//
// DispIntf:  ISpeechAudioFormat
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {E6E9C590-3E18-40E3-8299-061F98BDE7C7}
// *********************************************************************//
template<class T>
class ISpeechAudioFormatDispT : public TAutoDriver<ISpeechAudioFormat>
{
public:
  ISpeechAudioFormatDispT(){}

  ISpeechAudioFormatDispT(ISpeechAudioFormat *pintf)
  {
    TAutoDriver<ISpeechAudioFormat>::Bind(pintf, false);
  }

  ISpeechAudioFormatDispT(ISpeechAudioFormatPtr pintf)
  {
    TAutoDriver<ISpeechAudioFormat>::Bind(pintf, true);
  }

  ISpeechAudioFormatDispT& operator=(ISpeechAudioFormat *pintf)
  {
    TAutoDriver<ISpeechAudioFormat>::Bind(pintf, false);
    return *this;
  }

  ISpeechAudioFormatDispT& operator=(ISpeechAudioFormatPtr pintf)
  {
    TAutoDriver<ISpeechAudioFormat>::Bind(pintf, true);
    return *this;
  }

  HRESULT BindDefault()
  {
    return OLECHECK(Bind(CLSID_SpAudioFormat));
  }

  HRESULT BindRunning()
  {
    return BindToActive(CLSID_SpAudioFormat);
  }

  HRESULT         __fastcall get_Type(Speechlib_tlb::SpeechAudioFormatType* AudioFormat/*[out,retval]*/);
  Speechlib_tlb::SpeechAudioFormatType __fastcall get_Type(void);
  HRESULT         __fastcall set_Type(Speechlib_tlb::SpeechAudioFormatType AudioFormat/*[in]*/);
  HRESULT         __fastcall get_Guid(BSTR* Guid/*[out,retval]*/);
  BSTR            __fastcall get_Guid(void);
  HRESULT         __fastcall set_Guid(BSTR Guid/*[in]*/);
  HRESULT         __fastcall GetWaveFormatEx(Speechlib_tlb::ISpeechWaveFormatEx** SpeechWaveFormatEx/*[out,retval]*/);
  Speechlib_tlb::ISpeechWaveFormatEx* __fastcall GetWaveFormatEx(void);
  HRESULT         __fastcall SetWaveFormatEx(Speechlib_tlb::ISpeechWaveFormatEx* SpeechWaveFormatEx/*[in]*/);

  __property   Speechlib_tlb::SpeechAudioFormatType Type = {read = get_Type, write = set_Type};
  __property   BSTR            Guid = {read = get_Guid, write = set_Guid};
};
typedef ISpeechAudioFormatDispT<ISpeechAudioFormat> ISpeechAudioFormatDisp;

// *********************************************************************//
// SmartIntf: TCOMISpeechWaveFormatEx
// Interface: ISpeechWaveFormatEx
// *********************************************************************//
template <class T /* ISpeechWaveFormatEx */ >
class TCOMISpeechWaveFormatExT : public TComInterface<ISpeechWaveFormatEx>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMISpeechWaveFormatExT() {}
  TCOMISpeechWaveFormatExT(ISpeechWaveFormatEx *intf, bool addRef = false) : TComInterface<ISpeechWaveFormatEx>(intf, addRef) {}
  TCOMISpeechWaveFormatExT(const TCOMISpeechWaveFormatExT& src) : TComInterface<ISpeechWaveFormatEx>(src) {}
  TCOMISpeechWaveFormatExT& operator=(const TCOMISpeechWaveFormatExT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall get_FormatTag(short* FormatTag/*[out,retval]*/);
  short           __fastcall get_FormatTag(void);
  HRESULT         __fastcall set_FormatTag(short FormatTag/*[in]*/);
  HRESULT         __fastcall get_Channels(short* Channels/*[out,retval]*/);
  short           __fastcall get_Channels(void);
  HRESULT         __fastcall set_Channels(short Channels/*[in]*/);
  HRESULT         __fastcall get_SamplesPerSec(long* SamplesPerSec/*[out,retval]*/);
  long            __fastcall get_SamplesPerSec(void);
  HRESULT         __fastcall set_SamplesPerSec(long SamplesPerSec/*[in]*/);
  HRESULT         __fastcall get_AvgBytesPerSec(long* AvgBytesPerSec/*[out,retval]*/);
  long            __fastcall get_AvgBytesPerSec(void);
  HRESULT         __fastcall set_AvgBytesPerSec(long AvgBytesPerSec/*[in]*/);
  HRESULT         __fastcall get_BlockAlign(short* BlockAlign/*[out,retval]*/);
  short           __fastcall get_BlockAlign(void);
  HRESULT         __fastcall set_BlockAlign(short BlockAlign/*[in]*/);
  HRESULT         __fastcall get_BitsPerSample(short* BitsPerSample/*[out,retval]*/);
  short           __fastcall get_BitsPerSample(void);
  HRESULT         __fastcall set_BitsPerSample(short BitsPerSample/*[in]*/);
  HRESULT         __fastcall get_ExtraData(VARIANT* ExtraData/*[out,retval]*/);
  VARIANT         __fastcall get_ExtraData(void);
  HRESULT         __fastcall set_ExtraData(VARIANT ExtraData/*[in]*/);

  __property   short           FormatTag = {read = get_FormatTag, write = set_FormatTag};
  __property   short           Channels = {read = get_Channels, write = set_Channels};
  __property   long            SamplesPerSec = {read = get_SamplesPerSec, write = set_SamplesPerSec};
  __property   long            AvgBytesPerSec = {read = get_AvgBytesPerSec, write = set_AvgBytesPerSec};
  __property   short           BlockAlign = {read = get_BlockAlign, write = set_BlockAlign};
  __property   short           BitsPerSample = {read = get_BitsPerSample, write = set_BitsPerSample};
};
typedef TCOMISpeechWaveFormatExT<ISpeechWaveFormatEx> TCOMISpeechWaveFormatEx;

// *********************************************************************//
// DispIntf:  ISpeechWaveFormatEx
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {7A1EF0D5-1581-4741-88E4-209A49F11A10}
// *********************************************************************//
template<class T>
class ISpeechWaveFormatExDispT : public TAutoDriver<ISpeechWaveFormatEx>
{
public:
  ISpeechWaveFormatExDispT(){}

  ISpeechWaveFormatExDispT(ISpeechWaveFormatEx *pintf)
  {
    TAutoDriver<ISpeechWaveFormatEx>::Bind(pintf, false);
  }

  ISpeechWaveFormatExDispT(ISpeechWaveFormatExPtr pintf)
  {
    TAutoDriver<ISpeechWaveFormatEx>::Bind(pintf, true);
  }

  ISpeechWaveFormatExDispT& operator=(ISpeechWaveFormatEx *pintf)
  {
    TAutoDriver<ISpeechWaveFormatEx>::Bind(pintf, false);
    return *this;
  }

  ISpeechWaveFormatExDispT& operator=(ISpeechWaveFormatExPtr pintf)
  {
    TAutoDriver<ISpeechWaveFormatEx>::Bind(pintf, true);
    return *this;
  }

  HRESULT BindDefault()
  {
    return OLECHECK(Bind(CLSID_SpWaveFormatEx));
  }

  HRESULT BindRunning()
  {
    return BindToActive(CLSID_SpWaveFormatEx);
  }

  HRESULT         __fastcall get_FormatTag(short* FormatTag/*[out,retval]*/);
  short           __fastcall get_FormatTag(void);
  HRESULT         __fastcall set_FormatTag(short FormatTag/*[in]*/);
  HRESULT         __fastcall get_Channels(short* Channels/*[out,retval]*/);
  short           __fastcall get_Channels(void);
  HRESULT         __fastcall set_Channels(short Channels/*[in]*/);
  HRESULT         __fastcall get_SamplesPerSec(long* SamplesPerSec/*[out,retval]*/);
  long            __fastcall get_SamplesPerSec(void);
  HRESULT         __fastcall set_SamplesPerSec(long SamplesPerSec/*[in]*/);
  HRESULT         __fastcall get_AvgBytesPerSec(long* AvgBytesPerSec/*[out,retval]*/);
  long            __fastcall get_AvgBytesPerSec(void);
  HRESULT         __fastcall set_AvgBytesPerSec(long AvgBytesPerSec/*[in]*/);
  HRESULT         __fastcall get_BlockAlign(short* BlockAlign/*[out,retval]*/);
  short           __fastcall get_BlockAlign(void);
  HRESULT         __fastcall set_BlockAlign(short BlockAlign/*[in]*/);
  HRESULT         __fastcall get_BitsPerSample(short* BitsPerSample/*[out,retval]*/);
  short           __fastcall get_BitsPerSample(void);
  HRESULT         __fastcall set_BitsPerSample(short BitsPerSample/*[in]*/);
  HRESULT         __fastcall get_ExtraData(VARIANT* ExtraData/*[out,retval]*/);
  VARIANT         __fastcall get_ExtraData(void);
  HRESULT         __fastcall set_ExtraData(VARIANT ExtraData/*[in]*/);

  __property   short           FormatTag = {read = get_FormatTag, write = set_FormatTag};
  __property   short           Channels = {read = get_Channels, write = set_Channels};
  __property   long            SamplesPerSec = {read = get_SamplesPerSec, write = set_SamplesPerSec};
  __property   long            AvgBytesPerSec = {read = get_AvgBytesPerSec, write = set_AvgBytesPerSec};
  __property   short           BlockAlign = {read = get_BlockAlign, write = set_BlockAlign};
  __property   short           BitsPerSample = {read = get_BitsPerSample, write = set_BitsPerSample};
};
typedef ISpeechWaveFormatExDispT<ISpeechWaveFormatEx> ISpeechWaveFormatExDisp;

typedef TComInterface<ISpeechBaseStream>  TCOMISpeechBaseStream;

// *********************************************************************//
// DispIntf:  ISpeechBaseStream
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {6450336F-7D49-4CED-8097-49D6DEE37294}
// *********************************************************************//
template<class T>
class ISpeechBaseStreamDispT : public TAutoDriver<ISpeechBaseStream>
{
public:
  ISpeechBaseStreamDispT(){}

  ISpeechBaseStreamDispT(ISpeechBaseStream *pintf)
  {
    TAutoDriver<ISpeechBaseStream>::Bind(pintf, false);
  }

  ISpeechBaseStreamDispT(ISpeechBaseStreamPtr pintf)
  {
    TAutoDriver<ISpeechBaseStream>::Bind(pintf, true);
  }

  ISpeechBaseStreamDispT& operator=(ISpeechBaseStream *pintf)
  {
    TAutoDriver<ISpeechBaseStream>::Bind(pintf, false);
    return *this;
  }

  ISpeechBaseStreamDispT& operator=(ISpeechBaseStreamPtr pintf)
  {
    TAutoDriver<ISpeechBaseStream>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_Format(Speechlib_tlb::ISpeechAudioFormat** AudioFormat/*[out,retval]*/);
  Speechlib_tlb::ISpeechAudioFormatPtr __fastcall get_Format(void);
  HRESULT         __fastcall _set_Format(Speechlib_tlb::ISpeechAudioFormat* AudioFormat/*[in]*/);
  HRESULT         __fastcall Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/, 
                                  long* BytesRead/*[out,retval]*/);
  long            __fastcall Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/);
  HRESULT         __fastcall Write(VARIANT Buffer/*[in]*/, long* BytesWritten/*[out,retval]*/);
  long            __fastcall Write(VARIANT Buffer/*[in]*/);
  HRESULT         __fastcall Seek(VARIANT Position/*[in]*/, 
                                  Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/
                                  , VARIANT* NewPosition/*[out,retval]*/);
  VARIANT         __fastcall Seek(VARIANT Position/*[in]*/, 
                                  Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/);

  __property   Speechlib_tlb::ISpeechAudioFormatPtr Format = {read = get_Format};
};
typedef ISpeechBaseStreamDispT<ISpeechBaseStream> ISpeechBaseStreamDisp;

// *********************************************************************//
// SmartIntf: TCOMISpeechFileStream
// Interface: ISpeechFileStream
// *********************************************************************//
template <class T /* ISpeechFileStream */ >
class TCOMISpeechFileStreamT : public TComInterface<ISpeechFileStream>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMISpeechFileStreamT() {}
  TCOMISpeechFileStreamT(ISpeechFileStream *intf, bool addRef = false) : TComInterface<ISpeechFileStream>(intf, addRef) {}
  TCOMISpeechFileStreamT(const TCOMISpeechFileStreamT& src) : TComInterface<ISpeechFileStream>(src) {}
  TCOMISpeechFileStreamT& operator=(const TCOMISpeechFileStreamT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall Open(BSTR FileName/*[in]*/, 
                                  Speechlib_tlb::SpeechStreamFileMode FileMode/*[in,def,opt]*/, 
                                  VARIANT_BOOL DoEvents/*[in,def,opt]*/);
  HRESULT         __fastcall Close(void);

};
typedef TCOMISpeechFileStreamT<ISpeechFileStream> TCOMISpeechFileStream;

// *********************************************************************//
// DispIntf:  ISpeechFileStream
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {AF67F125-AB39-4E93-B4A2-CC2E66E182A7}
// *********************************************************************//
template<class T>
class ISpeechFileStreamDispT : public TAutoDriver<ISpeechFileStream>
{
public:
  ISpeechFileStreamDispT(){}

  ISpeechFileStreamDispT(ISpeechFileStream *pintf)
  {
    TAutoDriver<ISpeechFileStream>::Bind(pintf, false);
  }

  ISpeechFileStreamDispT(ISpeechFileStreamPtr pintf)
  {
    TAutoDriver<ISpeechFileStream>::Bind(pintf, true);
  }

  ISpeechFileStreamDispT& operator=(ISpeechFileStream *pintf)
  {
    TAutoDriver<ISpeechFileStream>::Bind(pintf, false);
    return *this;
  }

  ISpeechFileStreamDispT& operator=(ISpeechFileStreamPtr pintf)
  {
    TAutoDriver<ISpeechFileStream>::Bind(pintf, true);
    return *this;
  }

  HRESULT BindDefault()
  {
    return OLECHECK(Bind(CLSID_SpFileStream));
  }

  HRESULT BindRunning()
  {
    return BindToActive(CLSID_SpFileStream);
  }

  HRESULT         __fastcall Open(BSTR FileName/*[in]*/, 
                                  Speechlib_tlb::SpeechStreamFileMode FileMode/*[in,def,opt]*/, 
                                  VARIANT_BOOL DoEvents/*[in,def,opt]*/);
  HRESULT         __fastcall Close();
  HRESULT         __fastcall get_Format(Speechlib_tlb::ISpeechAudioFormat** AudioFormat/*[out,retval]*/);
  Speechlib_tlb::ISpeechAudioFormatPtr __fastcall get_Format(void);
  HRESULT         __fastcall _set_Format(Speechlib_tlb::ISpeechAudioFormat* AudioFormat/*[in]*/);
  HRESULT         __fastcall Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/, 
                                  long* BytesRead/*[out,retval]*/);
  long            __fastcall Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/);
  HRESULT         __fastcall Write(VARIANT Buffer/*[in]*/, long* BytesWritten/*[out,retval]*/);
  long            __fastcall Write(VARIANT Buffer/*[in]*/);
  HRESULT         __fastcall Seek(VARIANT Position/*[in]*/, 
                                  Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/
                                  , VARIANT* NewPosition/*[out,retval]*/);
  VARIANT         __fastcall Seek(VARIANT Position/*[in]*/, 
                                  Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/);


  __property   Speechlib_tlb::ISpeechAudioFormatPtr Format = {read = get_Format};
};
typedef ISpeechFileStreamDispT<ISpeechFileStream> ISpeechFileStreamDisp;

// *********************************************************************//
// SmartIntf: TCOMISpeechMemoryStream
// Interface: ISpeechMemoryStream
// *********************************************************************//
template <class T /* ISpeechMemoryStream */ >
class TCOMISpeechMemoryStreamT : public TComInterface<ISpeechMemoryStream>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMISpeechMemoryStreamT() {}
  TCOMISpeechMemoryStreamT(ISpeechMemoryStream *intf, bool addRef = false) : TComInterface<ISpeechMemoryStream>(intf, addRef) {}
  TCOMISpeechMemoryStreamT(const TCOMISpeechMemoryStreamT& src) : TComInterface<ISpeechMemoryStream>(src) {}
  TCOMISpeechMemoryStreamT& operator=(const TCOMISpeechMemoryStreamT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall SetData(VARIANT Data/*[in]*/);
  HRESULT         __fastcall GetData(VARIANT* pData/*[out,retval]*/);
  VARIANT         __fastcall GetData(void);

};
typedef TCOMISpeechMemoryStreamT<ISpeechMemoryStream> TCOMISpeechMemoryStream;

// *********************************************************************//
// DispIntf:  ISpeechMemoryStream
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {EEB14B68-808B-4ABE-A5EA-B51DA7588008}
// *********************************************************************//
template<class T>
class ISpeechMemoryStreamDispT : public TAutoDriver<ISpeechMemoryStream>
{
public:
  ISpeechMemoryStreamDispT(){}

  ISpeechMemoryStreamDispT(ISpeechMemoryStream *pintf)
  {
    TAutoDriver<ISpeechMemoryStream>::Bind(pintf, false);
  }

  ISpeechMemoryStreamDispT(ISpeechMemoryStreamPtr pintf)
  {
    TAutoDriver<ISpeechMemoryStream>::Bind(pintf, true);
  }

  ISpeechMemoryStreamDispT& operator=(ISpeechMemoryStream *pintf)
  {
    TAutoDriver<ISpeechMemoryStream>::Bind(pintf, false);
    return *this;
  }

  ISpeechMemoryStreamDispT& operator=(ISpeechMemoryStreamPtr pintf)
  {
    TAutoDriver<ISpeechMemoryStream>::Bind(pintf, true);
    return *this;
  }

  HRESULT BindDefault()
  {
    return OLECHECK(Bind(CLSID_SpMemoryStream));
  }

  HRESULT BindRunning()
  {
    return BindToActive(CLSID_SpMemoryStream);
  }

  HRESULT         __fastcall SetData(VARIANT Data/*[in]*/);
  HRESULT         __fastcall GetData(VARIANT* pData/*[out,retval]*/);
  VARIANT         __fastcall GetData(void);
  HRESULT         __fastcall get_Format(Speechlib_tlb::ISpeechAudioFormat** AudioFormat/*[out,retval]*/);
  Speechlib_tlb::ISpeechAudioFormatPtr __fastcall get_Format(void);
  HRESULT         __fastcall _set_Format(Speechlib_tlb::ISpeechAudioFormat* AudioFormat/*[in]*/);
  HRESULT         __fastcall Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/, 
                                  long* BytesRead/*[out,retval]*/);
  long            __fastcall Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/);
  HRESULT         __fastcall Write(VARIANT Buffer/*[in]*/, long* BytesWritten/*[out,retval]*/);
  long            __fastcall Write(VARIANT Buffer/*[in]*/);
  HRESULT         __fastcall Seek(VARIANT Position/*[in]*/, 
                                  Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/
                                  , VARIANT* NewPosition/*[out,retval]*/);
  VARIANT         __fastcall Seek(VARIANT Position/*[in]*/, 
                                  Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/);


  __property   Speechlib_tlb::ISpeechAudioFormatPtr Format = {read = get_Format};
};
typedef ISpeechMemoryStreamDispT<ISpeechMemoryStream> ISpeechMemoryStreamDisp;

// *********************************************************************//
// SmartIntf: TCOMISpeechCustomStream
// Interface: ISpeechCustomStream
// *********************************************************************//
template <class T /* ISpeechCustomStream */ >
class TCOMISpeechCustomStreamT : public TComInterface<ISpeechCustomStream>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMISpeechCustomStreamT() {}
  TCOMISpeechCustomStreamT(ISpeechCustomStream *intf, bool addRef = false) : TComInterface<ISpeechCustomStream>(intf, addRef) {}
  TCOMISpeechCustomStreamT(const TCOMISpeechCustomStreamT& src) : TComInterface<ISpeechCustomStream>(src) {}
  TCOMISpeechCustomStreamT& operator=(const TCOMISpeechCustomStreamT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall get_BaseStream(LPUNKNOWN* ppUnkStream/*[out,retval]*/);
  LPUNKNOWN       __fastcall get_BaseStream(void);
  HRESULT         __fastcall _set_BaseStream(LPUNKNOWN ppUnkStream/*[in]*/);

  __property   LPUNKNOWN       BaseStream = {read = get_BaseStream, write = _set_BaseStream};
};
typedef TCOMISpeechCustomStreamT<ISpeechCustomStream> TCOMISpeechCustomStream;

// *********************************************************************//
// DispIntf:  ISpeechCustomStream
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {1A9E9F4F-104F-4DB8-A115-EFD7FD0C97AE}
// *********************************************************************//
template<class T>
class ISpeechCustomStreamDispT : public TAutoDriver<ISpeechCustomStream>
{
public:
  ISpeechCustomStreamDispT(){}

  ISpeechCustomStreamDispT(ISpeechCustomStream *pintf)
  {
    TAutoDriver<ISpeechCustomStream>::Bind(pintf, false);
  }

  ISpeechCustomStreamDispT(ISpeechCustomStreamPtr pintf)
  {
    TAutoDriver<ISpeechCustomStream>::Bind(pintf, true);
  }

  ISpeechCustomStreamDispT& operator=(ISpeechCustomStream *pintf)
  {
    TAutoDriver<ISpeechCustomStream>::Bind(pintf, false);
    return *this;
  }

  ISpeechCustomStreamDispT& operator=(ISpeechCustomStreamPtr pintf)
  {
    TAutoDriver<ISpeechCustomStream>::Bind(pintf, true);
    return *this;
  }

  HRESULT BindDefault()
  {
    return OLECHECK(Bind(CLSID_SpCustomStream));
  }

  HRESULT BindRunning()
  {
    return BindToActive(CLSID_SpCustomStream);
  }

  HRESULT         __fastcall get_BaseStream(LPUNKNOWN* ppUnkStream/*[out,retval]*/);
  LPUNKNOWN       __fastcall get_BaseStream(void);
  HRESULT         __fastcall _set_BaseStream(LPUNKNOWN ppUnkStream/*[in]*/);
  HRESULT         __fastcall get_Format(Speechlib_tlb::ISpeechAudioFormat** AudioFormat/*[out,retval]*/);
  Speechlib_tlb::ISpeechAudioFormatPtr __fastcall get_Format(void);
  HRESULT         __fastcall _set_Format(Speechlib_tlb::ISpeechAudioFormat* AudioFormat/*[in]*/);
  HRESULT         __fastcall Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/, 
                                  long* BytesRead/*[out,retval]*/);
  long            __fastcall Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/);
  HRESULT         __fastcall Write(VARIANT Buffer/*[in]*/, long* BytesWritten/*[out,retval]*/);
  long            __fastcall Write(VARIANT Buffer/*[in]*/);
  HRESULT         __fastcall Seek(VARIANT Position/*[in]*/, 
                                  Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/
                                  , VARIANT* NewPosition/*[out,retval]*/);
  VARIANT         __fastcall Seek(VARIANT Position/*[in]*/, 
                                  Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/);

  __property   LPUNKNOWN       BaseStream = {read = get_BaseStream, write = _set_BaseStream};

  __property   Speechlib_tlb::ISpeechAudioFormatPtr Format = {read = get_Format};
};
typedef ISpeechCustomStreamDispT<ISpeechCustomStream> ISpeechCustomStreamDisp;

typedef TComInterface<ISpeechAudio>  TCOMISpeechAudio;

// *********************************************************************//
// DispIntf:  ISpeechAudio
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {CFF8E175-019E-11D3-A08E-00C04F8EF9B5}
// *********************************************************************//
template<class T>
class ISpeechAudioDispT : public TAutoDriver<ISpeechAudio>
{
public:
  ISpeechAudioDispT(){}

  ISpeechAudioDispT(ISpeechAudio *pintf)
  {
    TAutoDriver<ISpeechAudio>::Bind(pintf, false);
  }

  ISpeechAudioDispT(ISpeechAudioPtr pintf)
  {
    TAutoDriver<ISpeechAudio>::Bind(pintf, true);
  }

  ISpeechAudioDispT& operator=(ISpeechAudio *pintf)
  {
    TAutoDriver<ISpeechAudio>::Bind(pintf, false);
    return *this;
  }

  ISpeechAudioDispT& operator=(ISpeechAudioPtr pintf)
  {
    TAutoDriver<ISpeechAudio>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_Status(Speechlib_tlb::ISpeechAudioStatus** Status/*[out,retval]*/);
  Speechlib_tlb::ISpeechAudioStatusPtr __fastcall get_Status(void);
  HRESULT         __fastcall get_BufferInfo(Speechlib_tlb::ISpeechAudioBufferInfo** BufferInfo/*[out,retval]*/);
  Speechlib_tlb::ISpeechAudioBufferInfoPtr __fastcall get_BufferInfo(void);
  HRESULT         __fastcall get_DefaultFormat(Speechlib_tlb::ISpeechAudioFormat** StreamFormat/*[out,retval]*/);
  Speechlib_tlb::ISpeechAudioFormatPtr __fastcall get_DefaultFormat(void);
  HRESULT         __fastcall get_Volume(long* Volume/*[out,retval]*/);
  long            __fastcall get_Volume(void);
  HRESULT         __fastcall set_Volume(long Volume/*[in]*/);
  HRESULT         __fastcall get_BufferNotifySize(long* BufferNotifySize/*[out,retval]*/);
  long            __fastcall get_BufferNotifySize(void);
  HRESULT         __fastcall set_BufferNotifySize(long BufferNotifySize/*[in]*/);
  HRESULT         __fastcall get_EventHandle(long* EventHandle/*[out,retval]*/);
  long            __fastcall get_EventHandle(void);
  HRESULT         __fastcall SetState(Speechlib_tlb::SpeechAudioState State/*[in]*/);
  HRESULT         __fastcall get_Format(Speechlib_tlb::ISpeechAudioFormat** AudioFormat/*[out,retval]*/);
  Speechlib_tlb::ISpeechAudioFormatPtr __fastcall get_Format(void);
  HRESULT         __fastcall _set_Format(Speechlib_tlb::ISpeechAudioFormat* AudioFormat/*[in]*/);
  HRESULT         __fastcall Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/, 
                                  long* BytesRead/*[out,retval]*/);
  long            __fastcall Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/);
  HRESULT         __fastcall Write(VARIANT Buffer/*[in]*/, long* BytesWritten/*[out,retval]*/);
  long            __fastcall Write(VARIANT Buffer/*[in]*/);
  HRESULT         __fastcall Seek(VARIANT Position/*[in]*/, 
                                  Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/
                                  , VARIANT* NewPosition/*[out,retval]*/);
  VARIANT         __fastcall Seek(VARIANT Position/*[in]*/, 
                                  Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/);

  __property   Speechlib_tlb::ISpeechAudioStatusPtr Status = {read = get_Status};
  __property   Speechlib_tlb::ISpeechAudioBufferInfoPtr BufferInfo = {read = get_BufferInfo};
  __property   Speechlib_tlb::ISpeechAudioFormatPtr DefaultFormat = {read = get_DefaultFormat};
  __property   long            Volume = {read = get_Volume, write = set_Volume};
  __property   long            BufferNotifySize = {read = get_BufferNotifySize, write = set_BufferNotifySize};
  __property   long            EventHandle = {read = get_EventHandle};

  __property   Speechlib_tlb::ISpeechAudioFormatPtr Format = {read = get_Format};
};
typedef ISpeechAudioDispT<ISpeechAudio> ISpeechAudioDisp;

// *********************************************************************//
// SmartIntf: TCOMISpeechMMSysAudio
// Interface: ISpeechMMSysAudio
// *********************************************************************//
template <class T /* ISpeechMMSysAudio */ >
class TCOMISpeechMMSysAudioT : public TComInterface<ISpeechMMSysAudio>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMISpeechMMSysAudioT() {}
  TCOMISpeechMMSysAudioT(ISpeechMMSysAudio *intf, bool addRef = false) : TComInterface<ISpeechMMSysAudio>(intf, addRef) {}
  TCOMISpeechMMSysAudioT(const TCOMISpeechMMSysAudioT& src) : TComInterface<ISpeechMMSysAudio>(src) {}
  TCOMISpeechMMSysAudioT& operator=(const TCOMISpeechMMSysAudioT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall get_DeviceId(long* DeviceId/*[out,retval]*/);
  long            __fastcall get_DeviceId(void);
  HRESULT         __fastcall set_DeviceId(long DeviceId/*[in]*/);
  HRESULT         __fastcall get_LineId(long* LineId/*[out,retval]*/);
  long            __fastcall get_LineId(void);
  HRESULT         __fastcall set_LineId(long LineId/*[in]*/);
  HRESULT         __fastcall get_MMHandle(long* Handle/*[out,retval]*/);
  long            __fastcall get_MMHandle(void);

  __property   long            DeviceId = {read = get_DeviceId, write = set_DeviceId};
  __property   long            LineId = {read = get_LineId, write = set_LineId};
  __property   long            MMHandle = {read = get_MMHandle};
};
typedef TCOMISpeechMMSysAudioT<ISpeechMMSysAudio> TCOMISpeechMMSysAudio;

// *********************************************************************//
// DispIntf:  ISpeechMMSysAudio
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {3C76AF6D-1FD7-4831-81D1-3B71D5A13C44}
// *********************************************************************//
template<class T>
class ISpeechMMSysAudioDispT : public TAutoDriver<ISpeechMMSysAudio>
{
public:
  ISpeechMMSysAudioDispT(){}

  ISpeechMMSysAudioDispT(ISpeechMMSysAudio *pintf)
  {
    TAutoDriver<ISpeechMMSysAudio>::Bind(pintf, false);
  }

  ISpeechMMSysAudioDispT(ISpeechMMSysAudioPtr pintf)
  {
    TAutoDriver<ISpeechMMSysAudio>::Bind(pintf, true);
  }

  ISpeechMMSysAudioDispT& operator=(ISpeechMMSysAudio *pintf)
  {
    TAutoDriver<ISpeechMMSysAudio>::Bind(pintf, false);
    return *this;
  }

  ISpeechMMSysAudioDispT& operator=(ISpeechMMSysAudioPtr pintf)
  {
    TAutoDriver<ISpeechMMSysAudio>::Bind(pintf, true);
    return *this;
  }

  HRESULT BindDefault()
  {
    return OLECHECK(Bind(CLSID_SpMMAudioIn));
  }

  HRESULT BindRunning()
  {
    return BindToActive(CLSID_SpMMAudioIn);
  }

  HRESULT         __fastcall get_DeviceId(long* DeviceId/*[out,retval]*/);
  long            __fastcall get_DeviceId(void);
  HRESULT         __fastcall set_DeviceId(long DeviceId/*[in]*/);
  HRESULT         __fastcall get_LineId(long* LineId/*[out,retval]*/);
  long            __fastcall get_LineId(void);
  HRESULT         __fastcall set_LineId(long LineId/*[in]*/);
  HRESULT         __fastcall get_MMHandle(long* Handle/*[out,retval]*/);
  long            __fastcall get_MMHandle(void);
  HRESULT         __fastcall get_Status(Speechlib_tlb::ISpeechAudioStatus** Status/*[out,retval]*/);
  Speechlib_tlb::ISpeechAudioStatusPtr __fastcall get_Status(void);
  HRESULT         __fastcall get_BufferInfo(Speechlib_tlb::ISpeechAudioBufferInfo** BufferInfo/*[out,retval]*/);
  Speechlib_tlb::ISpeechAudioBufferInfoPtr __fastcall get_BufferInfo(void);
  HRESULT         __fastcall get_DefaultFormat(Speechlib_tlb::ISpeechAudioFormat** StreamFormat/*[out,retval]*/);
  Speechlib_tlb::ISpeechAudioFormatPtr __fastcall get_DefaultFormat(void);
  HRESULT         __fastcall get_Volume(long* Volume/*[out,retval]*/);
  long            __fastcall get_Volume(void);
  HRESULT         __fastcall set_Volume(long Volume/*[in]*/);
  HRESULT         __fastcall get_BufferNotifySize(long* BufferNotifySize/*[out,retval]*/);
  long            __fastcall get_BufferNotifySize(void);
  HRESULT         __fastcall set_BufferNotifySize(long BufferNotifySize/*[in]*/);
  HRESULT         __fastcall get_EventHandle(long* EventHandle/*[out,retval]*/);
  long            __fastcall get_EventHandle(void);
  HRESULT         __fastcall SetState(Speechlib_tlb::SpeechAudioState State/*[in]*/);
  HRESULT         __fastcall get_Format(Speechlib_tlb::ISpeechAudioFormat** AudioFormat/*[out,retval]*/);
  Speechlib_tlb::ISpeechAudioFormatPtr __fastcall get_Format(void);
  HRESULT         __fastcall _set_Format(Speechlib_tlb::ISpeechAudioFormat* AudioFormat/*[in]*/);
  HRESULT         __fastcall Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/, 
                                  long* BytesRead/*[out,retval]*/);
  long            __fastcall Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/);
  HRESULT         __fastcall Write(VARIANT Buffer/*[in]*/, long* BytesWritten/*[out,retval]*/);
  long            __fastcall Write(VARIANT Buffer/*[in]*/);
  HRESULT         __fastcall Seek(VARIANT Position/*[in]*/, 
                                  Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/
                                  , VARIANT* NewPosition/*[out,retval]*/);
  VARIANT         __fastcall Seek(VARIANT Position/*[in]*/, 
                                  Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/);

  __property   long            DeviceId = {read = get_DeviceId, write = set_DeviceId};
  __property   long            LineId = {read = get_LineId, write = set_LineId};
  __property   long            MMHandle = {read = get_MMHandle};

  __property   Speechlib_tlb::ISpeechAudioStatusPtr Status = {read = get_Status};
  __property   Speechlib_tlb::ISpeechAudioBufferInfoPtr BufferInfo = {read = get_BufferInfo};
  __property   Speechlib_tlb::ISpeechAudioFormatPtr DefaultFormat = {read = get_DefaultFormat};
  __property   long            Volume = {read = get_Volume, write = set_Volume};
  __property   long            BufferNotifySize = {read = get_BufferNotifySize, write = set_BufferNotifySize};
  __property   long            EventHandle = {read = get_EventHandle};

  __property   Speechlib_tlb::ISpeechAudioFormatPtr Format = {read = get_Format};
};
typedef ISpeechMMSysAudioDispT<ISpeechMMSysAudio> ISpeechMMSysAudioDisp;

// *********************************************************************//
// SmartIntf: TCOMISpeechVoice
// Interface: ISpeechVoice
// *********************************************************************//
template <class T /* ISpeechVoice */ >
class TCOMISpeechVoiceT : public TComInterface<ISpeechVoice>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMISpeechVoiceT() {}
  TCOMISpeechVoiceT(ISpeechVoice *intf, bool addRef = false) : TComInterface<ISpeechVoice>(intf, addRef) {}
  TCOMISpeechVoiceT(const TCOMISpeechVoiceT& src) : TComInterface<ISpeechVoice>(src) {}
  TCOMISpeechVoiceT& operator=(const TCOMISpeechVoiceT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall get_Status(Speechlib_tlb::ISpeechVoiceStatus** Status/*[out,retval]*/);
  Speechlib_tlb::ISpeechVoiceStatusPtr __fastcall get_Status(void);
  HRESULT         __fastcall get_Voice(Speechlib_tlb::ISpeechObjectToken** Voice/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectTokenPtr __fastcall get_Voice(void);
  HRESULT         __fastcall _set_Voice(Speechlib_tlb::ISpeechObjectToken* Voice/*[in]*/);
  HRESULT         __fastcall get_AudioOutput(Speechlib_tlb::ISpeechObjectToken** AudioOutput/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectTokenPtr __fastcall get_AudioOutput(void);
  HRESULT         __fastcall _set_AudioOutput(Speechlib_tlb::ISpeechObjectToken* AudioOutput/*[in]*/);
  HRESULT         __fastcall get_AudioOutputStream(Speechlib_tlb::ISpeechBaseStream** AudioOutputStream/*[out,retval]*/);
  Speechlib_tlb::ISpeechBaseStreamPtr __fastcall get_AudioOutputStream(void);
  HRESULT         __fastcall _set_AudioOutputStream(Speechlib_tlb::ISpeechBaseStream* AudioOutputStream/*[in]*/);
  HRESULT         __fastcall get_Rate(long* Rate/*[out,retval]*/);
  long            __fastcall get_Rate(void);
  HRESULT         __fastcall set_Rate(long Rate/*[in]*/);
  HRESULT         __fastcall get_Volume(long* Volume/*[out,retval]*/);
  long            __fastcall get_Volume(void);
  HRESULT         __fastcall set_Volume(long Volume/*[in]*/);
  HRESULT         __fastcall set_AllowAudioOutputFormatChangesOnNextSet(VARIANT_BOOL Allow/*[in]*/);
  HRESULT         __fastcall get_AllowAudioOutputFormatChangesOnNextSet(VARIANT_BOOL* Allow/*[out,retval]*/);
  VARIANT_BOOL    __fastcall get_AllowAudioOutputFormatChangesOnNextSet(void);
  HRESULT         __fastcall get_EventInterests(Speechlib_tlb::SpeechVoiceEvents* EventInterestFlags/*[out,retval]*/);
  Speechlib_tlb::SpeechVoiceEvents __fastcall get_EventInterests(void);
  HRESULT         __fastcall set_EventInterests(Speechlib_tlb::SpeechVoiceEvents EventInterestFlags/*[in]*/);
  HRESULT         __fastcall set_Priority(Speechlib_tlb::SpeechVoicePriority Priority/*[in]*/);
  HRESULT         __fastcall get_Priority(Speechlib_tlb::SpeechVoicePriority* Priority/*[out,retval]*/);
  Speechlib_tlb::SpeechVoicePriority __fastcall get_Priority(void);
  HRESULT         __fastcall set_AlertBoundary(Speechlib_tlb::SpeechVoiceEvents Boundary/*[in]*/);
  HRESULT         __fastcall get_AlertBoundary(Speechlib_tlb::SpeechVoiceEvents* Boundary/*[out,retval]*/);
  Speechlib_tlb::SpeechVoiceEvents __fastcall get_AlertBoundary(void);
  HRESULT         __fastcall set_SynchronousSpeakTimeout(long msTimeout/*[in]*/);
  HRESULT         __fastcall get_SynchronousSpeakTimeout(long* msTimeout/*[out,retval]*/);
  long            __fastcall get_SynchronousSpeakTimeout(void);
  HRESULT         __fastcall Speak(BSTR Text/*[in]*/, 
                                   Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/, 
                                   long* StreamNumber/*[out,retval]*/);
  long            __fastcall Speak(BSTR Text/*[in]*/, 
                                   Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/);
  HRESULT         __fastcall SpeakStream(Speechlib_tlb::ISpeechBaseStream* Stream/*[in]*/, 
                                         Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/, 
                                         long* StreamNumber/*[out,retval]*/);
  long            __fastcall SpeakStream(Speechlib_tlb::ISpeechBaseStream* Stream/*[in]*/, 
                                         Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/);
  HRESULT         __fastcall Pause(void);
  HRESULT         __fastcall Resume(void);
  HRESULT         __fastcall Skip(BSTR Type/*[in]*/, long NumItems/*[in]*/, 
                                  long* NumSkipped/*[out,retval]*/);
  long            __fastcall Skip(BSTR Type/*[in]*/, long NumItems/*[in]*/);
  HRESULT         __fastcall GetVoices(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                       BSTR OptionalAttributes/*[in,def,opt]*/, 
                                       Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectTokens* __fastcall GetVoices(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                           BSTR OptionalAttributes/*[in,def,opt]*/);
  HRESULT         __fastcall GetAudioOutputs(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                             BSTR OptionalAttributes/*[in,def,opt]*/, 
                                             Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectTokens* __fastcall GetAudioOutputs(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                                 BSTR OptionalAttributes/*[in,def,opt]*/);
  HRESULT         __fastcall WaitUntilDone(long msTimeout/*[in]*/, 
                                           VARIANT_BOOL* Done/*[out,retval]*/);
  VARIANT_BOOL    __fastcall WaitUntilDone(long msTimeout/*[in]*/);
  HRESULT         __fastcall SpeakCompleteEvent(long* Handle/*[out,retval]*/);
  long            __fastcall SpeakCompleteEvent(void);
  HRESULT         __fastcall IsUISupported(BSTR TypeOfUI/*[in]*/, VARIANT* ExtraData/*[in,def,opt]*/, 
                                           VARIANT_BOOL* Supported/*[out,retval]*/);
  VARIANT_BOOL    __fastcall IsUISupported(BSTR TypeOfUI/*[in]*/, 
                                           VARIANT* ExtraData/*[in,def,opt]*/= TNoParam());
  HRESULT         __fastcall DisplayUI(long hWndParent/*[in]*/, BSTR Title/*[in]*/, 
                                       BSTR TypeOfUI/*[in]*/, 
                                       VARIANT* ExtraData/*[in,def,opt]*/= TNoParam());

  __property   Speechlib_tlb::ISpeechVoiceStatusPtr Status = {read = get_Status};
  __property   Speechlib_tlb::ISpeechObjectTokenPtr Voice = {read = get_Voice};
  __property   Speechlib_tlb::ISpeechObjectTokenPtr AudioOutput = {read = get_AudioOutput};
  __property   Speechlib_tlb::ISpeechBaseStreamPtr AudioOutputStream = {read = get_AudioOutputStream};
  __property   long            Rate = {read = get_Rate, write = set_Rate};
  __property   long            Volume = {read = get_Volume, write = set_Volume};
  __property   VARIANT_BOOL    AllowAudioOutputFormatChangesOnNextSet = {read = get_AllowAudioOutputFormatChangesOnNextSet, write = set_AllowAudioOutputFormatChangesOnNextSet};
  __property   Speechlib_tlb::SpeechVoiceEvents EventInterests = {read = get_EventInterests, write = set_EventInterests};
  __property   Speechlib_tlb::SpeechVoicePriority Priority = {read = get_Priority, write = set_Priority};
  __property   Speechlib_tlb::SpeechVoiceEvents AlertBoundary = {read = get_AlertBoundary, write = set_AlertBoundary};
  __property   long            SynchronousSpeakTimeout = {read = get_SynchronousSpeakTimeout, write = set_SynchronousSpeakTimeout};
};
typedef TCOMISpeechVoiceT<ISpeechVoice> TCOMISpeechVoice;

// *********************************************************************//
// DispIntf:  ISpeechVoice
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {269316D8-57BD-11D2-9EEE-00C04F797396}
// *********************************************************************//
template<class T>
class ISpeechVoiceDispT : public TAutoDriver<ISpeechVoice>
{
public:
  ISpeechVoiceDispT(){}

  ISpeechVoiceDispT(ISpeechVoice *pintf)
  {
    TAutoDriver<ISpeechVoice>::Bind(pintf, false);
  }

  ISpeechVoiceDispT(ISpeechVoicePtr pintf)
  {
    TAutoDriver<ISpeechVoice>::Bind(pintf, true);
  }

  ISpeechVoiceDispT& operator=(ISpeechVoice *pintf)
  {
    TAutoDriver<ISpeechVoice>::Bind(pintf, false);
    return *this;
  }

  ISpeechVoiceDispT& operator=(ISpeechVoicePtr pintf)
  {
    TAutoDriver<ISpeechVoice>::Bind(pintf, true);
    return *this;
  }

  HRESULT BindDefault()
  {
    return OLECHECK(Bind(CLSID_SpVoice));
  }

  HRESULT BindRunning()
  {
    return BindToActive(CLSID_SpVoice);
  }

  HRESULT         __fastcall get_Status(Speechlib_tlb::ISpeechVoiceStatus** Status/*[out,retval]*/);
  Speechlib_tlb::ISpeechVoiceStatusPtr __fastcall get_Status(void);
  HRESULT         __fastcall get_Voice(Speechlib_tlb::ISpeechObjectToken** Voice/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectTokenPtr __fastcall get_Voice(void);
  HRESULT         __fastcall _set_Voice(Speechlib_tlb::ISpeechObjectToken* Voice/*[in]*/);
  HRESULT         __fastcall get_AudioOutput(Speechlib_tlb::ISpeechObjectToken** AudioOutput/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectTokenPtr __fastcall get_AudioOutput(void);
  HRESULT         __fastcall _set_AudioOutput(Speechlib_tlb::ISpeechObjectToken* AudioOutput/*[in]*/);
  HRESULT         __fastcall get_AudioOutputStream(Speechlib_tlb::ISpeechBaseStream** AudioOutputStream/*[out,retval]*/);
  Speechlib_tlb::ISpeechBaseStreamPtr __fastcall get_AudioOutputStream(void);
  HRESULT         __fastcall _set_AudioOutputStream(Speechlib_tlb::ISpeechBaseStream* AudioOutputStream/*[in]*/);
  HRESULT         __fastcall get_Rate(long* Rate/*[out,retval]*/);
  long            __fastcall get_Rate(void);
  HRESULT         __fastcall set_Rate(long Rate/*[in]*/);
  HRESULT         __fastcall get_Volume(long* Volume/*[out,retval]*/);
  long            __fastcall get_Volume(void);
  HRESULT         __fastcall set_Volume(long Volume/*[in]*/);
  HRESULT         __fastcall set_AllowAudioOutputFormatChangesOnNextSet(VARIANT_BOOL Allow/*[in]*/);
  HRESULT         __fastcall get_AllowAudioOutputFormatChangesOnNextSet(VARIANT_BOOL* Allow/*[out,retval]*/);
  VARIANT_BOOL    __fastcall get_AllowAudioOutputFormatChangesOnNextSet(void);
  HRESULT         __fastcall get_EventInterests(Speechlib_tlb::SpeechVoiceEvents* EventInterestFlags/*[out,retval]*/);
  Speechlib_tlb::SpeechVoiceEvents __fastcall get_EventInterests(void);
  HRESULT         __fastcall set_EventInterests(Speechlib_tlb::SpeechVoiceEvents EventInterestFlags/*[in]*/);
  HRESULT         __fastcall set_Priority(Speechlib_tlb::SpeechVoicePriority Priority/*[in]*/);
  HRESULT         __fastcall get_Priority(Speechlib_tlb::SpeechVoicePriority* Priority/*[out,retval]*/);
  Speechlib_tlb::SpeechVoicePriority __fastcall get_Priority(void);
  HRESULT         __fastcall set_AlertBoundary(Speechlib_tlb::SpeechVoiceEvents Boundary/*[in]*/);
  HRESULT         __fastcall get_AlertBoundary(Speechlib_tlb::SpeechVoiceEvents* Boundary/*[out,retval]*/);
  Speechlib_tlb::SpeechVoiceEvents __fastcall get_AlertBoundary(void);
  HRESULT         __fastcall set_SynchronousSpeakTimeout(long msTimeout/*[in]*/);
  HRESULT         __fastcall get_SynchronousSpeakTimeout(long* msTimeout/*[out,retval]*/);
  long            __fastcall get_SynchronousSpeakTimeout(void);
  HRESULT         __fastcall Speak(BSTR Text/*[in]*/, 
                                   Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/, 
                                   long* StreamNumber/*[out,retval]*/);
  long            __fastcall Speak(BSTR Text/*[in]*/, 
                                   Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/);
  HRESULT         __fastcall SpeakStream(Speechlib_tlb::ISpeechBaseStream* Stream/*[in]*/, 
                                         Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/
                                         , long* StreamNumber/*[out,retval]*/);
  long            __fastcall SpeakStream(Speechlib_tlb::ISpeechBaseStream* Stream/*[in]*/, 
                                         Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/);
  HRESULT         __fastcall Pause();
  HRESULT         __fastcall Resume();
  HRESULT         __fastcall Skip(BSTR Type/*[in]*/, long NumItems/*[in]*/, 
                                  long* NumSkipped/*[out,retval]*/);
  long            __fastcall Skip(BSTR Type/*[in]*/, long NumItems/*[in]*/);
  HRESULT         __fastcall GetVoices(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                       BSTR OptionalAttributes/*[in,def,opt]*/, 
                                       Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectTokens* __fastcall GetVoices(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                           BSTR OptionalAttributes/*[in,def,opt]*/);
  HRESULT         __fastcall GetAudioOutputs(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                             BSTR OptionalAttributes/*[in,def,opt]*/, 
                                             Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectTokens* __fastcall GetAudioOutputs(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                                 BSTR OptionalAttributes/*[in,def,opt]*/);
  HRESULT         __fastcall WaitUntilDone(long msTimeout/*[in]*/, 
                                           VARIANT_BOOL* Done/*[out,retval]*/);
  VARIANT_BOOL    __fastcall WaitUntilDone(long msTimeout/*[in]*/);
  HRESULT         __fastcall SpeakCompleteEvent(long* Handle/*[out,retval]*/);
  long            __fastcall SpeakCompleteEvent(void);
  HRESULT         __fastcall IsUISupported(BSTR TypeOfUI/*[in]*/, VARIANT* ExtraData/*[in,def,opt]*/
                                           , VARIANT_BOOL* Supported/*[out,retval]*/);
  VARIANT_BOOL    __fastcall IsUISupported(BSTR TypeOfUI/*[in]*/, 
                                           VARIANT* ExtraData/*[in,def,opt]*/= TNoParam());
  HRESULT         __fastcall DisplayUI(long hWndParent/*[in]*/, BSTR Title/*[in]*/, 
                                       BSTR TypeOfUI/*[in]*/, 
                                       VARIANT* ExtraData/*[in,def,opt]*/= TNoParam());

  __property   Speechlib_tlb::ISpeechVoiceStatusPtr Status = {read = get_Status};
  __property   Speechlib_tlb::ISpeechObjectTokenPtr Voice = {read = get_Voice};
  __property   Speechlib_tlb::ISpeechObjectTokenPtr AudioOutput = {read = get_AudioOutput};
  __property   Speechlib_tlb::ISpeechBaseStreamPtr AudioOutputStream = {read = get_AudioOutputStream};
  __property   long            Rate = {read = get_Rate, write = set_Rate};
  __property   long            Volume = {read = get_Volume, write = set_Volume};
  __property   VARIANT_BOOL    AllowAudioOutputFormatChangesOnNextSet = {read = get_AllowAudioOutputFormatChangesOnNextSet, write = set_AllowAudioOutputFormatChangesOnNextSet};
  __property   Speechlib_tlb::SpeechVoiceEvents EventInterests = {read = get_EventInterests, write = set_EventInterests};
  __property   Speechlib_tlb::SpeechVoicePriority Priority = {read = get_Priority, write = set_Priority};
  __property   Speechlib_tlb::SpeechVoiceEvents AlertBoundary = {read = get_AlertBoundary, write = set_AlertBoundary};
  __property   long            SynchronousSpeakTimeout = {read = get_SynchronousSpeakTimeout, write = set_SynchronousSpeakTimeout};
};
typedef ISpeechVoiceDispT<ISpeechVoice> ISpeechVoiceDisp;

typedef TComInterface<ISpeechVoiceStatus>  TCOMISpeechVoiceStatus;

// *********************************************************************//
// DispIntf:  ISpeechVoiceStatus
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {8BE47B07-57F6-11D2-9EEE-00C04F797396}
// *********************************************************************//
template<class T>
class ISpeechVoiceStatusDispT : public TAutoDriver<ISpeechVoiceStatus>
{
public:
  ISpeechVoiceStatusDispT(){}

  ISpeechVoiceStatusDispT(ISpeechVoiceStatus *pintf)
  {
    TAutoDriver<ISpeechVoiceStatus>::Bind(pintf, false);
  }

  ISpeechVoiceStatusDispT(ISpeechVoiceStatusPtr pintf)
  {
    TAutoDriver<ISpeechVoiceStatus>::Bind(pintf, true);
  }

  ISpeechVoiceStatusDispT& operator=(ISpeechVoiceStatus *pintf)
  {
    TAutoDriver<ISpeechVoiceStatus>::Bind(pintf, false);
    return *this;
  }

  ISpeechVoiceStatusDispT& operator=(ISpeechVoiceStatusPtr pintf)
  {
    TAutoDriver<ISpeechVoiceStatus>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_CurrentStreamNumber(long* StreamNumber/*[out,retval]*/);
  long            __fastcall get_CurrentStreamNumber(void);
  HRESULT         __fastcall get_LastStreamNumberQueued(long* StreamNumber/*[out,retval]*/);
  long            __fastcall get_LastStreamNumberQueued(void);
  HRESULT         __fastcall get_LastHResult(long* HResult/*[out,retval]*/);
  long            __fastcall get_LastHResult(void);
  HRESULT         __fastcall get_RunningState(Speechlib_tlb::SpeechRunState* State/*[out,retval]*/);
  Speechlib_tlb::SpeechRunState __fastcall get_RunningState(void);
  HRESULT         __fastcall get_InputWordPosition(long* Position/*[out,retval]*/);
  long            __fastcall get_InputWordPosition(void);
  HRESULT         __fastcall get_InputWordLength(long* Length/*[out,retval]*/);
  long            __fastcall get_InputWordLength(void);
  HRESULT         __fastcall get_InputSentencePosition(long* Position/*[out,retval]*/);
  long            __fastcall get_InputSentencePosition(void);
  HRESULT         __fastcall get_InputSentenceLength(long* Length/*[out,retval]*/);
  long            __fastcall get_InputSentenceLength(void);
  HRESULT         __fastcall get_LastBookmark(BSTR* Bookmark/*[out,retval]*/);
  BSTR            __fastcall get_LastBookmark(void);
  HRESULT         __fastcall get_LastBookmarkId(long* BookmarkId/*[out,retval]*/);
  long            __fastcall get_LastBookmarkId(void);
  HRESULT         __fastcall get_PhonemeId(short* PhoneId/*[out,retval]*/);
  short           __fastcall get_PhonemeId(void);
  HRESULT         __fastcall get_VisemeId(short* VisemeId/*[out,retval]*/);
  short           __fastcall get_VisemeId(void);

  __property   long            CurrentStreamNumber = {read = get_CurrentStreamNumber};
  __property   long            LastStreamNumberQueued = {read = get_LastStreamNumberQueued};
  __property   long            LastHResult = {read = get_LastHResult};
  __property   Speechlib_tlb::SpeechRunState RunningState = {read = get_RunningState};
  __property   long            InputWordPosition = {read = get_InputWordPosition};
  __property   long            InputWordLength = {read = get_InputWordLength};
  __property   long            InputSentencePosition = {read = get_InputSentencePosition};
  __property   long            InputSentenceLength = {read = get_InputSentenceLength};
  __property   BSTR            LastBookmark = {read = get_LastBookmark};
  __property   long            LastBookmarkId = {read = get_LastBookmarkId};
  __property   short           PhonemeId = {read = get_PhonemeId};
  __property   short           VisemeId = {read = get_VisemeId};
};
typedef ISpeechVoiceStatusDispT<ISpeechVoiceStatus> ISpeechVoiceStatusDisp;

// *********************************************************************//
// DispIntf:  _ISpeechVoiceEvents
// Flags:     (4096) Dispatchable
// GUID:      {A372ACD1-3BEF-4BBD-8FFB-CB3E2B416AF8}
// *********************************************************************//
template <class T>
class _ISpeechVoiceEventsDispT : public TAutoDriver<_ISpeechVoiceEvents>
{
public:
  _ISpeechVoiceEventsDispT(){}

  void Attach(LPUNKNOWN punk)
  { m_Dispatch = static_cast<T*>(punk); }

  void            __fastcall StartStream(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/);
  void            __fastcall EndStream(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/);
  void            __fastcall VoiceChange(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                         Speechlib_tlb::ISpeechObjectToken* VoiceObjectToken/*[in]*/);
  void            __fastcall Bookmark(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                      BSTR Bookmark/*[in]*/, long BookmarkId/*[in]*/);
  void            __fastcall Word(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                  long CharacterPosition/*[in]*/, long Length/*[in]*/);
  void            __fastcall Sentence(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                      long CharacterPosition/*[in]*/, long Length/*[in]*/);
  void            __fastcall Phoneme(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                     long Duration/*[in]*/, short NextPhoneId/*[in]*/, 
                                     Speechlib_tlb::SpeechVisemeFeature Feature/*[in]*/, 
                                     short CurrentPhoneId/*[in]*/);
  void            __fastcall Viseme(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                    long Duration/*[in]*/, 
                                    Speechlib_tlb::SpeechVisemeType NextVisemeId/*[in]*/, 
                                    Speechlib_tlb::SpeechVisemeFeature Feature/*[in]*/, 
                                    Speechlib_tlb::SpeechVisemeType CurrentVisemeId/*[in]*/);
  void            __fastcall AudioLevel(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                        long AudioLevel/*[in]*/);
  void            __fastcall EnginePrivate(long StreamNumber/*[in]*/, long StreamPosition/*[in]*/, 
                                           VARIANT EngineData/*[in]*/);

};
typedef _ISpeechVoiceEventsDispT<_ISpeechVoiceEvents> _ISpeechVoiceEventsDisp;

// *********************************************************************//
// SmartIntf: TCOMISpeechRecognizer
// Interface: ISpeechRecognizer
// *********************************************************************//
template <class T /* ISpeechRecognizer */ >
class TCOMISpeechRecognizerT : public TComInterface<ISpeechRecognizer>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMISpeechRecognizerT() {}
  TCOMISpeechRecognizerT(ISpeechRecognizer *intf, bool addRef = false) : TComInterface<ISpeechRecognizer>(intf, addRef) {}
  TCOMISpeechRecognizerT(const TCOMISpeechRecognizerT& src) : TComInterface<ISpeechRecognizer>(src) {}
  TCOMISpeechRecognizerT& operator=(const TCOMISpeechRecognizerT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall _set_Recognizer(Speechlib_tlb::ISpeechObjectToken* Recognizer/*[in]*/);
  HRESULT         __fastcall get_Recognizer(Speechlib_tlb::ISpeechObjectToken** Recognizer/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectTokenPtr __fastcall get_Recognizer(void);
  HRESULT         __fastcall set_AllowAudioInputFormatChangesOnNextSet(VARIANT_BOOL Allow/*[in]*/);
  HRESULT         __fastcall get_AllowAudioInputFormatChangesOnNextSet(VARIANT_BOOL* Allow/*[out,retval]*/);
  VARIANT_BOOL    __fastcall get_AllowAudioInputFormatChangesOnNextSet(void);
  HRESULT         __fastcall _set_AudioInput(Speechlib_tlb::ISpeechObjectToken* AudioInput/*[in,def,opt]*/);
  HRESULT         __fastcall get_AudioInput(Speechlib_tlb::ISpeechObjectToken** AudioInput/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectTokenPtr __fastcall get_AudioInput(void);
  HRESULT         __fastcall _set_AudioInputStream(Speechlib_tlb::ISpeechBaseStream* AudioInputStream/*[in,def,opt]*/);
  HRESULT         __fastcall get_AudioInputStream(Speechlib_tlb::ISpeechBaseStream** AudioInputStream/*[out,retval]*/);
  Speechlib_tlb::ISpeechBaseStreamPtr __fastcall get_AudioInputStream(void);
  HRESULT         __fastcall get_IsShared(VARIANT_BOOL* Shared/*[out,retval]*/);
  VARIANT_BOOL    __fastcall get_IsShared(void);
  HRESULT         __fastcall set_State(Speechlib_tlb::SpeechRecognizerState State/*[in]*/);
  HRESULT         __fastcall get_State(Speechlib_tlb::SpeechRecognizerState* State/*[out,retval]*/);
  Speechlib_tlb::SpeechRecognizerState __fastcall get_State(void);
  HRESULT         __fastcall get_Status(Speechlib_tlb::ISpeechRecognizerStatus** Status/*[out,retval]*/);
  Speechlib_tlb::ISpeechRecognizerStatusPtr __fastcall get_Status(void);
  HRESULT         __fastcall _set_Profile(Speechlib_tlb::ISpeechObjectToken* Profile/*[in,def,opt]*/);
  HRESULT         __fastcall get_Profile(Speechlib_tlb::ISpeechObjectToken** Profile/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectTokenPtr __fastcall get_Profile(void);
  HRESULT         __fastcall EmulateRecognition(VARIANT TextElements/*[in]*/, 
                                                VARIANT* ElementDisplayAttributes/*[in,def,opt]*/, 
                                                long LanguageId/*[in,def,opt]*/);
  HRESULT         __fastcall CreateRecoContext(Speechlib_tlb::ISpeechRecoContext** NewContext/*[out,retval]*/);
  Speechlib_tlb::ISpeechRecoContext* __fastcall CreateRecoContext(void);
  HRESULT         __fastcall GetFormat(Speechlib_tlb::SpeechFormatType Type/*[in]*/, 
                                       Speechlib_tlb::ISpeechAudioFormat** Format/*[out,retval]*/);
  Speechlib_tlb::ISpeechAudioFormat* __fastcall GetFormat(Speechlib_tlb::SpeechFormatType Type/*[in]*/);
  HRESULT         __fastcall SetPropertyNumber(BSTR Name/*[in]*/, long Value/*[in]*/, 
                                               VARIANT_BOOL* Supported/*[out,retval]*/);
  VARIANT_BOOL    __fastcall SetPropertyNumber(BSTR Name/*[in]*/, long Value/*[in]*/);
  HRESULT         __fastcall GetPropertyNumber(BSTR Name/*[in]*/, long* Value/*[in,out]*/, 
                                               VARIANT_BOOL* Supported/*[out,retval]*/);
  VARIANT_BOOL    __fastcall GetPropertyNumber(BSTR Name/*[in]*/, long* Value/*[in,out]*/);
  HRESULT         __fastcall SetPropertyString(BSTR Name/*[in]*/, BSTR Value/*[in]*/, 
                                               VARIANT_BOOL* Supported/*[out,retval]*/);
  VARIANT_BOOL    __fastcall SetPropertyString(BSTR Name/*[in]*/, BSTR Value/*[in]*/);
  HRESULT         __fastcall GetPropertyString(BSTR Name/*[in]*/, BSTR* Value/*[in,out]*/, 
                                               VARIANT_BOOL* Supported/*[out,retval]*/);
  VARIANT_BOOL    __fastcall GetPropertyString(BSTR Name/*[in]*/, BSTR* Value/*[in,out]*/);
  HRESULT         __fastcall IsUISupported(BSTR TypeOfUI/*[in]*/, VARIANT* ExtraData/*[in,def,opt]*/, 
                                           VARIANT_BOOL* Supported/*[out,retval]*/);
  VARIANT_BOOL    __fastcall IsUISupported(BSTR TypeOfUI/*[in]*/, 
                                           VARIANT* ExtraData/*[in,def,opt]*/= TNoParam());
  HRESULT         __fastcall DisplayUI(long hWndParent/*[in]*/, BSTR Title/*[in]*/, 
                                       BSTR TypeOfUI/*[in]*/, 
                                       VARIANT* ExtraData/*[in,def,opt]*/= TNoParam());
  HRESULT         __fastcall GetRecognizers(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                            BSTR OptionalAttributes/*[in,def,opt]*/, 
                                            Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectTokens* __fastcall GetRecognizers(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                                BSTR OptionalAttributes/*[in,def,opt]*/);
  HRESULT         __fastcall GetAudioInputs(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                            BSTR OptionalAttributes/*[in,def,opt]*/, 
                                            Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectTokens* __fastcall GetAudioInputs(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                                BSTR OptionalAttributes/*[in,def,opt]*/);
  HRESULT         __fastcall GetProfiles(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                         BSTR OptionalAttributes/*[in,def,opt]*/, 
                                         Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectTokens* __fastcall GetProfiles(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                             BSTR OptionalAttributes/*[in,def,opt]*/);

  __property   Speechlib_tlb::ISpeechObjectToken* Recognizer = {write = _set_Recognizer};
  __property   VARIANT_BOOL    AllowAudioInputFormatChangesOnNextSet = {read = get_AllowAudioInputFormatChangesOnNextSet, write = set_AllowAudioInputFormatChangesOnNextSet};
  __property   Speechlib_tlb::ISpeechObjectToken* AudioInput = {write = _set_AudioInput};
  __property   Speechlib_tlb::ISpeechBaseStream* AudioInputStream = {write = _set_AudioInputStream};
  __property   VARIANT_BOOL    IsShared = {read = get_IsShared};
  __property   Speechlib_tlb::SpeechRecognizerState State = {read = get_State, write = set_State};
  __property   Speechlib_tlb::ISpeechRecognizerStatusPtr Status = {read = get_Status};
  __property   Speechlib_tlb::ISpeechObjectToken* Profile = {write = _set_Profile};
};
typedef TCOMISpeechRecognizerT<ISpeechRecognizer> TCOMISpeechRecognizer;

// *********************************************************************//
// DispIntf:  ISpeechRecognizer
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {2D5F1C0C-BD75-4B08-9478-3B11FEA2586C}
// *********************************************************************//
template<class T>
class ISpeechRecognizerDispT : public TAutoDriver<ISpeechRecognizer>
{
public:
  ISpeechRecognizerDispT(){}

  ISpeechRecognizerDispT(ISpeechRecognizer *pintf)
  {
    TAutoDriver<ISpeechRecognizer>::Bind(pintf, false);
  }

  ISpeechRecognizerDispT(ISpeechRecognizerPtr pintf)
  {
    TAutoDriver<ISpeechRecognizer>::Bind(pintf, true);
  }

  ISpeechRecognizerDispT& operator=(ISpeechRecognizer *pintf)
  {
    TAutoDriver<ISpeechRecognizer>::Bind(pintf, false);
    return *this;
  }

  ISpeechRecognizerDispT& operator=(ISpeechRecognizerPtr pintf)
  {
    TAutoDriver<ISpeechRecognizer>::Bind(pintf, true);
    return *this;
  }

  HRESULT BindDefault()
  {
    return OLECHECK(Bind(CLSID_SpInprocRecognizer));
  }

  HRESULT BindRunning()
  {
    return BindToActive(CLSID_SpInprocRecognizer);
  }

  HRESULT         __fastcall _set_Recognizer(Speechlib_tlb::ISpeechObjectToken* Recognizer/*[in]*/);
  HRESULT         __fastcall get_Recognizer(Speechlib_tlb::ISpeechObjectToken** Recognizer/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectTokenPtr __fastcall get_Recognizer(void);
  HRESULT         __fastcall set_AllowAudioInputFormatChangesOnNextSet(VARIANT_BOOL Allow/*[in]*/);
  HRESULT         __fastcall get_AllowAudioInputFormatChangesOnNextSet(VARIANT_BOOL* Allow/*[out,retval]*/);
  VARIANT_BOOL    __fastcall get_AllowAudioInputFormatChangesOnNextSet(void);
  HRESULT         __fastcall _set_AudioInput(Speechlib_tlb::ISpeechObjectToken* AudioInput/*[in,def,opt]*/);
  HRESULT         __fastcall get_AudioInput(Speechlib_tlb::ISpeechObjectToken** AudioInput/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectTokenPtr __fastcall get_AudioInput(void);
  HRESULT         __fastcall _set_AudioInputStream(Speechlib_tlb::ISpeechBaseStream* AudioInputStream/*[in,def,opt]*/);
  HRESULT         __fastcall get_AudioInputStream(Speechlib_tlb::ISpeechBaseStream** AudioInputStream/*[out,retval]*/);
  Speechlib_tlb::ISpeechBaseStreamPtr __fastcall get_AudioInputStream(void);
  HRESULT         __fastcall get_IsShared(VARIANT_BOOL* Shared/*[out,retval]*/);
  VARIANT_BOOL    __fastcall get_IsShared(void);
  HRESULT         __fastcall set_State(Speechlib_tlb::SpeechRecognizerState State/*[in]*/);
  HRESULT         __fastcall get_State(Speechlib_tlb::SpeechRecognizerState* State/*[out,retval]*/);
  Speechlib_tlb::SpeechRecognizerState __fastcall get_State(void);
  HRESULT         __fastcall get_Status(Speechlib_tlb::ISpeechRecognizerStatus** Status/*[out,retval]*/);
  Speechlib_tlb::ISpeechRecognizerStatusPtr __fastcall get_Status(void);
  HRESULT         __fastcall _set_Profile(Speechlib_tlb::ISpeechObjectToken* Profile/*[in,def,opt]*/);
  HRESULT         __fastcall get_Profile(Speechlib_tlb::ISpeechObjectToken** Profile/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectTokenPtr __fastcall get_Profile(void);
  HRESULT         __fastcall EmulateRecognition(VARIANT TextElements/*[in]*/, 
                                                VARIANT* ElementDisplayAttributes/*[in,def,opt]*/, 
                                                long LanguageId/*[in,def,opt]*/);
  HRESULT         __fastcall CreateRecoContext(Speechlib_tlb::ISpeechRecoContext** NewContext/*[out,retval]*/);
  Speechlib_tlb::ISpeechRecoContext* __fastcall CreateRecoContext(void);
  HRESULT         __fastcall GetFormat(Speechlib_tlb::SpeechFormatType Type/*[in]*/, 
                                       Speechlib_tlb::ISpeechAudioFormat** Format/*[out,retval]*/);
  Speechlib_tlb::ISpeechAudioFormat* __fastcall GetFormat(Speechlib_tlb::SpeechFormatType Type/*[in]*/);
  HRESULT         __fastcall SetPropertyNumber(BSTR Name/*[in]*/, long Value/*[in]*/, 
                                               VARIANT_BOOL* Supported/*[out,retval]*/);
  VARIANT_BOOL    __fastcall SetPropertyNumber(BSTR Name/*[in]*/, long Value/*[in]*/);
  HRESULT         __fastcall GetPropertyNumber(BSTR Name/*[in]*/, long* Value/*[in,out]*/, 
                                               VARIANT_BOOL* Supported/*[out,retval]*/);
  VARIANT_BOOL    __fastcall GetPropertyNumber(BSTR Name/*[in]*/, long* Value/*[in,out]*/);
  HRESULT         __fastcall SetPropertyString(BSTR Name/*[in]*/, BSTR Value/*[in]*/, 
                                               VARIANT_BOOL* Supported/*[out,retval]*/);
  VARIANT_BOOL    __fastcall SetPropertyString(BSTR Name/*[in]*/, BSTR Value/*[in]*/);
  HRESULT         __fastcall GetPropertyString(BSTR Name/*[in]*/, BSTR* Value/*[in,out]*/, 
                                               VARIANT_BOOL* Supported/*[out,retval]*/);
  VARIANT_BOOL    __fastcall GetPropertyString(BSTR Name/*[in]*/, BSTR* Value/*[in,out]*/);
  HRESULT         __fastcall IsUISupported(BSTR TypeOfUI/*[in]*/, VARIANT* ExtraData/*[in,def,opt]*/
                                           , VARIANT_BOOL* Supported/*[out,retval]*/);
  VARIANT_BOOL    __fastcall IsUISupported(BSTR TypeOfUI/*[in]*/, 
                                           VARIANT* ExtraData/*[in,def,opt]*/= TNoParam());
  HRESULT         __fastcall DisplayUI(long hWndParent/*[in]*/, BSTR Title/*[in]*/, 
                                       BSTR TypeOfUI/*[in]*/, 
                                       VARIANT* ExtraData/*[in,def,opt]*/= TNoParam());
  HRESULT         __fastcall GetRecognizers(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                            BSTR OptionalAttributes/*[in,def,opt]*/, 
                                            Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectTokens* __fastcall GetRecognizers(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                                BSTR OptionalAttributes/*[in,def,opt]*/);
  HRESULT         __fastcall GetAudioInputs(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                            BSTR OptionalAttributes/*[in,def,opt]*/, 
                                            Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectTokens* __fastcall GetAudioInputs(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                                BSTR OptionalAttributes/*[in,def,opt]*/);
  HRESULT         __fastcall GetProfiles(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                         BSTR OptionalAttributes/*[in,def,opt]*/, 
                                         Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/);
  Speechlib_tlb::ISpeechObjectTokens* __fastcall GetProfiles(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                             BSTR OptionalAttributes/*[in,def,opt]*/);

  __property   Speechlib_tlb::ISpeechObjectToken* Recognizer = {write = _set_Recognizer};
  __property   VARIANT_BOOL    AllowAudioInputFormatChangesOnNextSet = {read = get_AllowAudioInputFormatChangesOnNextSet, write = set_AllowAudioInputFormatChangesOnNextSet};
  __property   Speechlib_tlb::ISpeechObjectToken* AudioInput = {write = _set_AudioInput};
  __property   Speechlib_tlb::ISpeechBaseStream* AudioInputStream = {write = _set_AudioInputStream};
  __property   VARIANT_BOOL    IsShared = {read = get_IsShared};
  __property   Speechlib_tlb::SpeechRecognizerState State = {read = get_State, write = set_State};
  __property   Speechlib_tlb::ISpeechRecognizerStatusPtr Status = {read = get_Status};
  __property   Speechlib_tlb::ISpeechObjectToken* Profile = {write = _set_Profile};
};
typedef ISpeechRecognizerDispT<ISpeechRecognizer> ISpeechRecognizerDisp;

typedef TComInterface<ISpeechRecognizerStatus>  TCOMISpeechRecognizerStatus;

// *********************************************************************//
// DispIntf:  ISpeechRecognizerStatus
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {BFF9E781-53EC-484E-BB8A-0E1B5551E35C}
// *********************************************************************//
template<class T>
class ISpeechRecognizerStatusDispT : public TAutoDriver<ISpeechRecognizerStatus>
{
public:
  ISpeechRecognizerStatusDispT(){}

  ISpeechRecognizerStatusDispT(ISpeechRecognizerStatus *pintf)
  {
    TAutoDriver<ISpeechRecognizerStatus>::Bind(pintf, false);
  }

  ISpeechRecognizerStatusDispT(ISpeechRecognizerStatusPtr pintf)
  {
    TAutoDriver<ISpeechRecognizerStatus>::Bind(pintf, true);
  }

  ISpeechRecognizerStatusDispT& operator=(ISpeechRecognizerStatus *pintf)
  {
    TAutoDriver<ISpeechRecognizerStatus>::Bind(pintf, false);
    return *this;
  }

  ISpeechRecognizerStatusDispT& operator=(ISpeechRecognizerStatusPtr pintf)
  {
    TAutoDriver<ISpeechRecognizerStatus>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_AudioStatus(Speechlib_tlb::ISpeechAudioStatus** AudioStatus/*[out,retval]*/);
  Speechlib_tlb::ISpeechAudioStatusPtr __fastcall get_AudioStatus(void);
  HRESULT         __fastcall get_CurrentStreamPosition(VARIANT* pCurrentStreamPos/*[out,retval]*/);
  VARIANT         __fastcall get_CurrentStreamPosition(void);
  HRESULT         __fastcall get_CurrentStreamNumber(long* StreamNumber/*[out,retval]*/);
  long            __fastcall get_CurrentStreamNumber(void);
  HRESULT         __fastcall get_NumberOfActiveRules(long* NumberOfActiveRules/*[out,retval]*/);
  long            __fastcall get_NumberOfActiveRules(void);
  HRESULT         __fastcall get_ClsidEngine(BSTR* ClsidEngine/*[out,retval]*/);
  BSTR            __fastcall get_ClsidEngine(void);
  HRESULT         __fastcall get_SupportedLanguages(VARIANT* SupportedLanguages/*[out,retval]*/);
  VARIANT         __fastcall get_SupportedLanguages(void);

  __property   Speechlib_tlb::ISpeechAudioStatusPtr AudioStatus = {read = get_AudioStatus};
  __property   long            CurrentStreamNumber = {read = get_CurrentStreamNumber};
  __property   long            NumberOfActiveRules = {read = get_NumberOfActiveRules};
  __property   BSTR            ClsidEngine = {read = get_ClsidEngine};
};
typedef ISpeechRecognizerStatusDispT<ISpeechRecognizerStatus> ISpeechRecognizerStatusDisp;

// *********************************************************************//
// SmartIntf: TCOMISpeechRecoContext
// Interface: ISpeechRecoContext
// *********************************************************************//
template <class T /* ISpeechRecoContext */ >
class TCOMISpeechRecoContextT : public TComInterface<ISpeechRecoContext>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMISpeechRecoContextT() {}
  TCOMISpeechRecoContextT(ISpeechRecoContext *intf, bool addRef = false) : TComInterface<ISpeechRecoContext>(intf, addRef) {}
  TCOMISpeechRecoContextT(const TCOMISpeechRecoContextT& src) : TComInterface<ISpeechRecoContext>(src) {}
  TCOMISpeechRecoContextT& operator=(const TCOMISpeechRecoContextT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall get_Recognizer(Speechlib_tlb::ISpeechRecognizer** Recognizer/*[out,retval]*/);
  Speechlib_tlb::ISpeechRecognizerPtr __fastcall get_Recognizer(void);
  HRESULT         __fastcall get_AudioInputInterferenceStatus(Speechlib_tlb::SpeechInterference* Interference/*[out,retval]*/);
  Speechlib_tlb::SpeechInterference __fastcall get_AudioInputInterferenceStatus(void);
  HRESULT         __fastcall get_RequestedUIType(BSTR* UIType/*[out,retval]*/);
  BSTR            __fastcall get_RequestedUIType(void);
  HRESULT         __fastcall _set_Voice(Speechlib_tlb::ISpeechVoice* Voice/*[in]*/);
  HRESULT         __fastcall get_Voice(Speechlib_tlb::ISpeechVoice** Voice/*[out,retval]*/);
  Speechlib_tlb::ISpeechVoicePtr __fastcall get_Voice(void);
  HRESULT         __fastcall set_AllowVoiceFormatMatchingOnNextSet(VARIANT_BOOL pAllow/*[in]*/);
  HRESULT         __fastcall get_AllowVoiceFormatMatchingOnNextSet(VARIANT_BOOL* pAllow/*[out,retval]*/);
  VARIANT_BOOL    __fastcall get_AllowVoiceFormatMatchingOnNextSet(void);
  HRESULT         __fastcall set_VoicePurgeEvent(Speechlib_tlb::SpeechRecoEvents EventInterest/*[in]*/);
  HRESULT         __fastcall get_VoicePurgeEvent(Speechlib_tlb::SpeechRecoEvents* EventInterest/*[out,retval]*/);
  Speechlib_tlb::SpeechRecoEvents __fastcall get_VoicePurgeEvent(void);
  HRESULT         __fastcall set_EventInterests(Speechlib_tlb::SpeechRecoEvents EventInterest/*[in]*/);
  HRESULT         __fastcall get_EventInterests(Speechlib_tlb::SpeechRecoEvents* EventInterest/*[out,retval]*/);
  Speechlib_tlb::SpeechRecoEvents __fastcall get_EventInterests(void);
  HRESULT         __fastcall set_CmdMaxAlternates(long MaxAlternates/*[in]*/);
  HRESULT         __fastcall get_CmdMaxAlternates(long* MaxAlternates/*[out,retval]*/);
  long            __fastcall get_CmdMaxAlternates(void);
  HRESULT         __fastcall set_State(Speechlib_tlb::SpeechRecoContextState State/*[in]*/);
  HRESULT         __fastcall get_State(Speechlib_tlb::SpeechRecoContextState* State/*[out,retval]*/);
  Speechlib_tlb::SpeechRecoContextState __fastcall get_State(void);
  HRESULT         __fastcall set_RetainedAudio(Speechlib_tlb::SpeechRetainedAudioOptions Option/*[in]*/);
  HRESULT         __fastcall get_RetainedAudio(Speechlib_tlb::SpeechRetainedAudioOptions* Option/*[out,retval]*/);
  Speechlib_tlb::SpeechRetainedAudioOptions __fastcall get_RetainedAudio(void);
  HRESULT         __fastcall _set_RetainedAudioFormat(Speechlib_tlb::ISpeechAudioFormat* Format/*[in]*/);
  HRESULT         __fastcall get_RetainedAudioFormat(Speechlib_tlb::ISpeechAudioFormat** Format/*[out,retval]*/);
  Speechlib_tlb::ISpeechAudioFormatPtr __fastcall get_RetainedAudioFormat(void);
  HRESULT         __fastcall Pause(void);
  HRESULT         __fastcall Resume(void);
  HRESULT         __fastcall CreateGrammar(VARIANT GrammarId/*[in,def,opt]*/, 
                                           Speechlib_tlb::ISpeechRecoGrammar** Grammar/*[out,retval]*/);
  Speechlib_tlb::ISpeechRecoGrammar* __fastcall CreateGrammar(VARIANT GrammarId/*[in,def,opt]*/= TNoParam());
  HRESULT         __fastcall CreateResultFromMemory(VARIANT* ResultBlock/*[in]*/, 
                                                    Speechlib_tlb::ISpeechRecoResult** Result/*[out,retval]*/);
  Speechlib_tlb::ISpeechRecoResult* __fastcall CreateResultFromMemory(VARIANT* ResultBlock/*[in]*/);
  HRESULT         __fastcall Bookmark(Speechlib_tlb::SpeechBookmarkOptions Options/*[in]*/, 
                                      VARIANT StreamPos/*[in]*/, VARIANT BookmarkId/*[in]*/);
  HRESULT         __fastcall SetAdaptationData(BSTR AdaptationString/*[in]*/);

  __property   Speechlib_tlb::ISpeechRecognizerPtr Recognizer = {read = get_Recognizer};
  __property   Speechlib_tlb::SpeechInterference AudioInputInterferenceStatus = {read = get_AudioInputInterferenceStatus};
  __property   BSTR            RequestedUIType = {read = get_RequestedUIType};
  __property   Speechlib_tlb::ISpeechVoice* Voice = {write = _set_Voice};
  __property   VARIANT_BOOL    AllowVoiceFormatMatchingOnNextSet = {read = get_AllowVoiceFormatMatchingOnNextSet, write = set_AllowVoiceFormatMatchingOnNextSet};
  __property   Speechlib_tlb::SpeechRecoEvents VoicePurgeEvent = {read = get_VoicePurgeEvent, write = set_VoicePurgeEvent};
  __property   Speechlib_tlb::SpeechRecoEvents EventInterests = {read = get_EventInterests, write = set_EventInterests};
  __property   long            CmdMaxAlternates = {read = get_CmdMaxAlternates, write = set_CmdMaxAlternates};
  __property   Speechlib_tlb::SpeechRecoContextState State = {read = get_State, write = set_State};
  __property   Speechlib_tlb::SpeechRetainedAudioOptions RetainedAudio = {read = get_RetainedAudio, write = set_RetainedAudio};
  __property   Speechlib_tlb::ISpeechAudioFormat* RetainedAudioFormat = {write = _set_RetainedAudioFormat};
};
typedef TCOMISpeechRecoContextT<ISpeechRecoContext> TCOMISpeechRecoContext;

// *********************************************************************//
// DispIntf:  ISpeechRecoContext
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {580AA49D-7E1E-4809-B8E2-57DA806104B8}
// *********************************************************************//
template<class T>
class ISpeechRecoContextDispT : public TAutoDriver<ISpeechRecoContext>
{
public:
  ISpeechRecoContextDispT(){}

  ISpeechRecoContextDispT(ISpeechRecoContext *pintf)
  {
    TAutoDriver<ISpeechRecoContext>::Bind(pintf, false);
  }

  ISpeechRecoContextDispT(ISpeechRecoContextPtr pintf)
  {
    TAutoDriver<ISpeechRecoContext>::Bind(pintf, true);
  }

  ISpeechRecoContextDispT& operator=(ISpeechRecoContext *pintf)
  {
    TAutoDriver<ISpeechRecoContext>::Bind(pintf, false);
    return *this;
  }

  ISpeechRecoContextDispT& operator=(ISpeechRecoContextPtr pintf)
  {
    TAutoDriver<ISpeechRecoContext>::Bind(pintf, true);
    return *this;
  }

  HRESULT BindDefault()
  {
    return OLECHECK(Bind(CLSID_SpSharedRecoContext));
  }

  HRESULT BindRunning()
  {
    return BindToActive(CLSID_SpSharedRecoContext);
  }

  HRESULT         __fastcall get_Recognizer(Speechlib_tlb::ISpeechRecognizer** Recognizer/*[out,retval]*/);
  Speechlib_tlb::ISpeechRecognizerPtr __fastcall get_Recognizer(void);
  HRESULT         __fastcall get_AudioInputInterferenceStatus(Speechlib_tlb::SpeechInterference* Interference/*[out,retval]*/);
  Speechlib_tlb::SpeechInterference __fastcall get_AudioInputInterferenceStatus(void);
  HRESULT         __fastcall get_RequestedUIType(BSTR* UIType/*[out,retval]*/);
  BSTR            __fastcall get_RequestedUIType(void);
  HRESULT         __fastcall _set_Voice(Speechlib_tlb::ISpeechVoice* Voice/*[in]*/);
  HRESULT         __fastcall get_Voice(Speechlib_tlb::ISpeechVoice** Voice/*[out,retval]*/);
  Speechlib_tlb::ISpeechVoicePtr __fastcall get_Voice(void);
  HRESULT         __fastcall set_AllowVoiceFormatMatchingOnNextSet(VARIANT_BOOL pAllow/*[in]*/);
  HRESULT         __fastcall get_AllowVoiceFormatMatchingOnNextSet(VARIANT_BOOL* pAllow/*[out,retval]*/);
  VARIANT_BOOL    __fastcall get_AllowVoiceFormatMatchingOnNextSet(void);
  HRESULT         __fastcall set_VoicePurgeEvent(Speechlib_tlb::SpeechRecoEvents EventInterest/*[in]*/);
  HRESULT         __fastcall get_VoicePurgeEvent(Speechlib_tlb::SpeechRecoEvents* EventInterest/*[out,retval]*/);
  Speechlib_tlb::SpeechRecoEvents __fastcall get_VoicePurgeEvent(void);
  HRESULT         __fastcall set_EventInterests(Speechlib_tlb::SpeechRecoEvents EventInterest/*[in]*/);
  HRESULT         __fastcall get_EventInterests(Speechlib_tlb::SpeechRecoEvents* EventInterest/*[out,retval]*/);
  Speechlib_tlb::SpeechRecoEvents __fastcall get_EventInterests(void);
  HRESULT         __fastcall set_CmdMaxAlternates(long MaxAlternates/*[in]*/);
  HRESULT         __fastcall get_CmdMaxAlternates(long* MaxAlternates/*[out,retval]*/);
  long            __fastcall get_CmdMaxAlternates(void);
  HRESULT         __fastcall set_State(Speechlib_tlb::SpeechRecoContextState State/*[in]*/);
  HRESULT         __fastcall get_State(Speechlib_tlb::SpeechRecoContextState* State/*[out,retval]*/);
  Speechlib_tlb::SpeechRecoContextState __fastcall get_State(void);
  HRESULT         __fastcall set_RetainedAudio(Speechlib_tlb::SpeechRetainedAudioOptions Option/*[in]*/);
  HRESULT         __fastcall get_RetainedAudio(Speechlib_tlb::SpeechRetainedAudioOptions* Option/*[out,retval]*/);
  Speechlib_tlb::SpeechRetainedAudioOptions __fastcall get_RetainedAudio(void);
  HRESULT         __fastcall _set_RetainedAudioFormat(Speechlib_tlb::ISpeechAudioFormat* Format/*[in]*/);
  HRESULT         __fastcall get_RetainedAudioFormat(Speechlib_tlb::ISpeechAudioFormat** Format/*[out,retval]*/);
  Speechlib_tlb::ISpeechAudioFormatPtr __fastcall get_RetainedAudioFormat(void);
  HRESULT         __fastcall Pause();
  HRESULT         __fastcall Resume();
  HRESULT         __fastcall CreateGrammar(VARIANT GrammarId/*[in,def,opt]*/, 
                                           Speechlib_tlb::ISpeechRecoGrammar** Grammar/*[out,retval]*/);
  Speechlib_tlb::ISpeechRecoGrammar* __fastcall CreateGrammar(VARIANT GrammarId/*[in,def,opt]*/= TNoParam());
  HRESULT         __fastcall CreateResultFromMemory(VARIANT* ResultBlock/*[in]*/, 
                                                    Speechlib_tlb::ISpeechRecoResult** Result/*[out,retval]*/);
  Speechlib_tlb::ISpeechRecoResult* __fastcall CreateResultFromMemory(VARIANT* ResultBlock/*[in]*/);
  HRESULT         __fastcall Bookmark(Speechlib_tlb::SpeechBookmarkOptions Options/*[in]*/, 
                                      VARIANT StreamPos/*[in]*/, VARIANT BookmarkId/*[in]*/);
  HRESULT         __fastcall SetAdaptationData(BSTR AdaptationString/*[in]*/);

  __property   Speechlib_tlb::ISpeechRecognizerPtr Recognizer = {read = get_Recognizer};
  __property   Speechlib_tlb::SpeechInterference AudioInputInterferenceStatus = {read = get_AudioInputInterferenceStatus};
  __property   BSTR            RequestedUIType = {read = get_RequestedUIType};
  __property   Speechlib_tlb::ISpeechVoice* Voice = {write = _set_Voice};
  __property   VARIANT_BOOL    AllowVoiceFormatMatchingOnNextSet = {read = get_AllowVoiceFormatMatchingOnNextSet, write = set_AllowVoiceFormatMatchingOnNextSet};
  __property   Speechlib_tlb::SpeechRecoEvents VoicePurgeEvent = {read = get_VoicePurgeEvent, write = set_VoicePurgeEvent};
  __property   Speechlib_tlb::SpeechRecoEvents EventInterests = {read = get_EventInterests, write = set_EventInterests};
  __property   long            CmdMaxAlternates = {read = get_CmdMaxAlternates, write = set_CmdMaxAlternates};
  __property   Speechlib_tlb::SpeechRecoContextState State = {read = get_State, write = set_State};
  __property   Speechlib_tlb::SpeechRetainedAudioOptions RetainedAudio = {read = get_RetainedAudio, write = set_RetainedAudio};
  __property   Speechlib_tlb::ISpeechAudioFormat* RetainedAudioFormat = {write = _set_RetainedAudioFormat};
};
typedef ISpeechRecoContextDispT<ISpeechRecoContext> ISpeechRecoContextDisp;

typedef TComInterface<ISpeechRecoGrammar>  TCOMISpeechRecoGrammar;

// *********************************************************************//
// DispIntf:  ISpeechRecoGrammar
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {B6D6F79F-2158-4E50-B5BC-9A9CCD852A09}
// *********************************************************************//
template<class T>
class ISpeechRecoGrammarDispT : public TAutoDriver<ISpeechRecoGrammar>
{
public:
  ISpeechRecoGrammarDispT(){}

  ISpeechRecoGrammarDispT(ISpeechRecoGrammar *pintf)
  {
    TAutoDriver<ISpeechRecoGrammar>::Bind(pintf, false);
  }

  ISpeechRecoGrammarDispT(ISpeechRecoGrammarPtr pintf)
  {
    TAutoDriver<ISpeechRecoGrammar>::Bind(pintf, true);
  }

  ISpeechRecoGrammarDispT& operator=(ISpeechRecoGrammar *pintf)
  {
    TAutoDriver<ISpeechRecoGrammar>::Bind(pintf, false);
    return *this;
  }

  ISpeechRecoGrammarDispT& operator=(ISpeechRecoGrammarPtr pintf)
  {
    TAutoDriver<ISpeechRecoGrammar>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_Id(VARIANT* Id/*[out,retval]*/);
  VARIANT         __fastcall get_Id(void);
  HRESULT         __fastcall get_RecoContext(Speechlib_tlb::ISpeechRecoContext** RecoContext/*[out,retval]*/);
  Speechlib_tlb::ISpeechRecoContextPtr __fastcall get_RecoContext(void);
  HRESULT         __fastcall set_State(Speechlib_tlb::SpeechGrammarState State/*[in]*/);
  HRESULT         __fastcall get_State(Speechlib_tlb::SpeechGrammarState* State/*[out,retval]*/);
  Speechlib_tlb::SpeechGrammarState __fastcall get_State(void);
  HRESULT         __fastcall get_Rules(Speechlib_tlb::ISpeechGrammarRules** Rules/*[out,retval]*/);
  Speechlib_tlb::ISpeechGrammarRulesPtr __fastcall get_Rules(void);
  HRESULT         __fastcall Reset(long NewLanguage/*[in,def,opt]*/);
  HRESULT         __fastcall CmdLoadFromFile(BSTR FileName/*[in]*/, 
                                             Speechlib_tlb::SpeechLoadOption LoadOption/*[in,def,opt]*/);
  HRESULT         __fastcall CmdLoadFromObject(BSTR ClassId/*[in]*/, BSTR GrammarName/*[in]*/, 
                                               Speechlib_tlb::SpeechLoadOption LoadOption/*[in,def,opt]*/);
  HRESULT         __fastcall CmdLoadFromResource(long hModule/*[in]*/, VARIANT ResourceName/*[in]*/
                                                 , VARIANT ResourceType/*[in]*/, 
                                                 long LanguageId/*[in]*/, 
                                                 Speechlib_tlb::SpeechLoadOption LoadOption/*[in,def,opt]*/);
  HRESULT         __fastcall CmdLoadFromMemory(VARIANT GrammarData/*[in]*/, 
                                               Speechlib_tlb::SpeechLoadOption LoadOption/*[in,def,opt]*/);
  HRESULT         __fastcall CmdLoadFromProprietaryGrammar(BSTR ProprietaryGuid/*[in]*/, 
                                                           BSTR ProprietaryString/*[in]*/, 
                                                           VARIANT ProprietaryData/*[in]*/, 
                                                           Speechlib_tlb::SpeechLoadOption LoadOption/*[in,def,opt]*/);
  HRESULT         __fastcall CmdSetRuleState(BSTR Name/*[in]*/, 
                                             Speechlib_tlb::SpeechRuleState State/*[in]*/);
  HRESULT         __fastcall CmdSetRuleIdState(long RuleId/*[in]*/, 
                                               Speechlib_tlb::SpeechRuleState State/*[in]*/);
  HRESULT         __fastcall DictationLoad(BSTR TopicName/*[in,def,opt]*/, 
                                           Speechlib_tlb::SpeechLoadOption LoadOption/*[in,def,opt]*/);
  HRESULT         __fastcall DictationUnload();
  HRESULT         __fastcall DictationSetState(Speechlib_tlb::SpeechRuleState State/*[in]*/);
  HRESULT         __fastcall SetWordSequenceData(BSTR Text/*[in]*/, long TextLength/*[in]*/, 
                                                 Speechlib_tlb::ISpeechTextSelectionInformation* Info/*[in]*/);
  HRESULT         __fastcall SetTextSelection(Speechlib_tlb::ISpeechTextSelectionInformation* Info/*[in]*/);
  HRESULT         __fastcall IsPronounceable(BSTR Word/*[in]*/, 
                                             Speechlib_tlb::SpeechWordPronounceable* WordPronounceable/*[out,retval]*/);
  Speechlib_tlb::SpeechWordPronounceable __fastcall IsPronounceable(BSTR Word/*[in]*/);

  __property   Speechlib_tlb::ISpeechRecoContextPtr RecoContext = {read = get_RecoContext};
  __property   Speechlib_tlb::SpeechGrammarState State = {read = get_State, write = set_State};
  __property   Speechlib_tlb::ISpeechGrammarRulesPtr Rules = {read = get_Rules};
};
typedef ISpeechRecoGrammarDispT<ISpeechRecoGrammar> ISpeechRecoGrammarDisp;

typedef TComInterface<ISpeechGrammarRules>  TCOMISpeechGrammarRules;

// *********************************************************************//
// DispIntf:  ISpeechGrammarRules
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {6FFA3B44-FC2D-40D1-8AFC-32911C7F1AD1}
// *********************************************************************//
template<class T>
class ISpeechGrammarRulesDispT : public TAutoDriver<ISpeechGrammarRules>
{
public:
  ISpeechGrammarRulesDispT(){}

  ISpeechGrammarRulesDispT(ISpeechGrammarRules *pintf)
  {
    TAutoDriver<ISpeechGrammarRules>::Bind(pintf, false);
  }

  ISpeechGrammarRulesDispT(ISpeechGrammarRulesPtr pintf)
  {
    TAutoDriver<ISpeechGrammarRules>::Bind(pintf, true);
  }

  ISpeechGrammarRulesDispT& operator=(ISpeechGrammarRules *pintf)
  {
    TAutoDriver<ISpeechGrammarRules>::Bind(pintf, false);
    return *this;
  }

  ISpeechGrammarRulesDispT& operator=(ISpeechGrammarRulesPtr pintf)
  {
    TAutoDriver<ISpeechGrammarRules>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_Count(long* Count/*[out,retval]*/);
  long            __fastcall get_Count(void);
  HRESULT         __fastcall FindRule(VARIANT RuleNameOrId/*[in]*/, 
                                      Speechlib_tlb::ISpeechGrammarRule** Rule/*[out,retval]*/);
  Speechlib_tlb::ISpeechGrammarRule* __fastcall FindRule(VARIANT RuleNameOrId/*[in]*/);
  HRESULT         __fastcall Item(long Index/*[in]*/, 
                                  Speechlib_tlb::ISpeechGrammarRule** Rule/*[out,retval]*/);
  Speechlib_tlb::ISpeechGrammarRule* __fastcall Item(long Index/*[in]*/);
  HRESULT         __fastcall get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/);
  LPUNKNOWN       __fastcall get__NewEnum(void);
  HRESULT         __fastcall get_Dynamic(VARIANT_BOOL* Dynamic/*[out,retval]*/);
  VARIANT_BOOL    __fastcall get_Dynamic(void);
  HRESULT         __fastcall Add(BSTR RuleName/*[in]*/, 
                                 Speechlib_tlb::SpeechRuleAttributes Attributes/*[in]*/, 
                                 long RuleId/*[in,def,opt]*/, 
                                 Speechlib_tlb::ISpeechGrammarRule** Rule/*[out,retval]*/);
  Speechlib_tlb::ISpeechGrammarRule* __fastcall Add(BSTR RuleName/*[in]*/, 
                                                    Speechlib_tlb::SpeechRuleAttributes Attributes/*[in]*/, 
                                                    long RuleId/*[in,def,opt]*/);
  HRESULT         __fastcall Commit();
  HRESULT         __fastcall CommitAndSave(BSTR* ErrorText/*[out]*/, 
                                           VARIANT* SaveStream/*[out,retval]*/);
  VARIANT         __fastcall CommitAndSave(BSTR* ErrorText/*[out]*/);

  __property   long            Count = {read = get_Count};
  __property   LPUNKNOWN       _NewEnum = {read = get__NewEnum};
  __property   VARIANT_BOOL    Dynamic = {read = get_Dynamic};
};
typedef ISpeechGrammarRulesDispT<ISpeechGrammarRules> ISpeechGrammarRulesDisp;

typedef TComInterface<ISpeechGrammarRule>  TCOMISpeechGrammarRule;

// *********************************************************************//
// DispIntf:  ISpeechGrammarRule
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {AFE719CF-5DD1-44F2-999C-7A399F1CFCCC}
// *********************************************************************//
template<class T>
class ISpeechGrammarRuleDispT : public TAutoDriver<ISpeechGrammarRule>
{
public:
  ISpeechGrammarRuleDispT(){}

  ISpeechGrammarRuleDispT(ISpeechGrammarRule *pintf)
  {
    TAutoDriver<ISpeechGrammarRule>::Bind(pintf, false);
  }

  ISpeechGrammarRuleDispT(ISpeechGrammarRulePtr pintf)
  {
    TAutoDriver<ISpeechGrammarRule>::Bind(pintf, true);
  }

  ISpeechGrammarRuleDispT& operator=(ISpeechGrammarRule *pintf)
  {
    TAutoDriver<ISpeechGrammarRule>::Bind(pintf, false);
    return *this;
  }

  ISpeechGrammarRuleDispT& operator=(ISpeechGrammarRulePtr pintf)
  {
    TAutoDriver<ISpeechGrammarRule>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_Attributes(Speechlib_tlb::SpeechRuleAttributes* Attributes/*[out,retval]*/);
  Speechlib_tlb::SpeechRuleAttributes __fastcall get_Attributes(void);
  HRESULT         __fastcall get_InitialState(Speechlib_tlb::ISpeechGrammarRuleState** State/*[out,retval]*/);
  Speechlib_tlb::ISpeechGrammarRuleStatePtr __fastcall get_InitialState(void);
  HRESULT         __fastcall get_Name(BSTR* Name/*[out,retval]*/);
  BSTR            __fastcall get_Name(void);
  HRESULT         __fastcall get_Id(long* Id/*[out,retval]*/);
  long            __fastcall get_Id(void);
  HRESULT         __fastcall Clear();
  HRESULT         __fastcall AddResource(BSTR ResourceName/*[in]*/, BSTR ResourceValue/*[in]*/);
  HRESULT         __fastcall AddState(Speechlib_tlb::ISpeechGrammarRuleState** State/*[out,retval]*/);
  Speechlib_tlb::ISpeechGrammarRuleState* __fastcall AddState(void);

  __property   Speechlib_tlb::SpeechRuleAttributes Attributes = {read = get_Attributes};
  __property   Speechlib_tlb::ISpeechGrammarRuleStatePtr InitialState = {read = get_InitialState};
  __property   BSTR            Name = {read = get_Name};
  __property   long            Id = {read = get_Id};
};
typedef ISpeechGrammarRuleDispT<ISpeechGrammarRule> ISpeechGrammarRuleDisp;

typedef TComInterface<ISpeechGrammarRuleState>  TCOMISpeechGrammarRuleState;

// *********************************************************************//
// DispIntf:  ISpeechGrammarRuleState
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {D4286F2C-EE67-45AE-B928-28D695362EDA}
// *********************************************************************//
template<class T>
class ISpeechGrammarRuleStateDispT : public TAutoDriver<ISpeechGrammarRuleState>
{
public:
  ISpeechGrammarRuleStateDispT(){}

  ISpeechGrammarRuleStateDispT(ISpeechGrammarRuleState *pintf)
  {
    TAutoDriver<ISpeechGrammarRuleState>::Bind(pintf, false);
  }

  ISpeechGrammarRuleStateDispT(ISpeechGrammarRuleStatePtr pintf)
  {
    TAutoDriver<ISpeechGrammarRuleState>::Bind(pintf, true);
  }

  ISpeechGrammarRuleStateDispT& operator=(ISpeechGrammarRuleState *pintf)
  {
    TAutoDriver<ISpeechGrammarRuleState>::Bind(pintf, false);
    return *this;
  }

  ISpeechGrammarRuleStateDispT& operator=(ISpeechGrammarRuleStatePtr pintf)
  {
    TAutoDriver<ISpeechGrammarRuleState>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_Rule(Speechlib_tlb::ISpeechGrammarRule** Rule/*[out,retval]*/);
  Speechlib_tlb::ISpeechGrammarRulePtr __fastcall get_Rule(void);
  HRESULT         __fastcall get_Transitions(Speechlib_tlb::ISpeechGrammarRuleStateTransitions** Transitions/*[out,retval]*/);
  Speechlib_tlb::ISpeechGrammarRuleStateTransitionsPtr __fastcall get_Transitions(void);
  HRESULT         __fastcall AddWordTransition(Speechlib_tlb::ISpeechGrammarRuleState* DestState/*[in]*/
                                               , BSTR Words/*[in]*/, BSTR Separators/*[in,def,opt]*/
                                               , 
                                               Speechlib_tlb::SpeechGrammarWordType Type/*[in,def,opt]*/
                                               , BSTR PropertyName/*[in,def,opt]*/, 
                                               long PropertyId/*[in,def,opt]*/, 
                                               VARIANT* PropertyValue/*[in,def,opt]*/, 
                                               float Weight/*[in,def,opt]*/);
  HRESULT         __fastcall AddRuleTransition(Speechlib_tlb::ISpeechGrammarRuleState* DestinationState/*[in]*/
                                               , Speechlib_tlb::ISpeechGrammarRule* Rule/*[in]*/, 
                                               BSTR PropertyName/*[in,def,opt]*/, 
                                               long PropertyId/*[in,def,opt]*/, 
                                               VARIANT* PropertyValue/*[in,def,opt]*/, 
                                               float Weight/*[in,def,opt]*/);
  HRESULT         __fastcall AddSpecialTransition(Speechlib_tlb::ISpeechGrammarRuleState* DestinationState/*[in]*/
                                                  , 
                                                  Speechlib_tlb::SpeechSpecialTransitionType Type/*[in]*/
                                                  , BSTR PropertyName/*[in,def,opt]*/, 
                                                  long PropertyId/*[in,def,opt]*/, 
                                                  VARIANT* PropertyValue/*[in,def,opt]*/, 
                                                  float Weight/*[in,def,opt]*/);

  __property   Speechlib_tlb::ISpeechGrammarRulePtr Rule = {read = get_Rule};
  __property   Speechlib_tlb::ISpeechGrammarRuleStateTransitionsPtr Transitions = {read = get_Transitions};
};
typedef ISpeechGrammarRuleStateDispT<ISpeechGrammarRuleState> ISpeechGrammarRuleStateDisp;

typedef TComInterface<ISpeechGrammarRuleStateTransitions>  TCOMISpeechGrammarRuleStateTransitions;

// *********************************************************************//
// DispIntf:  ISpeechGrammarRuleStateTransitions
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {EABCE657-75BC-44A2-AA7F-C56476742963}
// *********************************************************************//
template<class T>
class ISpeechGrammarRuleStateTransitionsDispT : public TAutoDriver<ISpeechGrammarRuleStateTransitions>
{
public:
  ISpeechGrammarRuleStateTransitionsDispT(){}

  ISpeechGrammarRuleStateTransitionsDispT(ISpeechGrammarRuleStateTransitions *pintf)
  {
    TAutoDriver<ISpeechGrammarRuleStateTransitions>::Bind(pintf, false);
  }

  ISpeechGrammarRuleStateTransitionsDispT(ISpeechGrammarRuleStateTransitionsPtr pintf)
  {
    TAutoDriver<ISpeechGrammarRuleStateTransitions>::Bind(pintf, true);
  }

  ISpeechGrammarRuleStateTransitionsDispT& operator=(ISpeechGrammarRuleStateTransitions *pintf)
  {
    TAutoDriver<ISpeechGrammarRuleStateTransitions>::Bind(pintf, false);
    return *this;
  }

  ISpeechGrammarRuleStateTransitionsDispT& operator=(ISpeechGrammarRuleStateTransitionsPtr pintf)
  {
    TAutoDriver<ISpeechGrammarRuleStateTransitions>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_Count(long* Count/*[out,retval]*/);
  long            __fastcall get_Count(void);
  HRESULT         __fastcall Item(long Index/*[in]*/, 
                                  Speechlib_tlb::ISpeechGrammarRuleStateTransition** Transition/*[out,retval]*/);
  Speechlib_tlb::ISpeechGrammarRuleStateTransition* __fastcall Item(long Index/*[in]*/);
  HRESULT         __fastcall get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/);
  LPUNKNOWN       __fastcall get__NewEnum(void);

  __property   long            Count = {read = get_Count};
  __property   LPUNKNOWN       _NewEnum = {read = get__NewEnum};
};
typedef ISpeechGrammarRuleStateTransitionsDispT<ISpeechGrammarRuleStateTransitions> ISpeechGrammarRuleStateTransitionsDisp;

typedef TComInterface<ISpeechGrammarRuleStateTransition>  TCOMISpeechGrammarRuleStateTransition;

// *********************************************************************//
// DispIntf:  ISpeechGrammarRuleStateTransition
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {CAFD1DB1-41D1-4A06-9863-E2E81DA17A9A}
// *********************************************************************//
template<class T>
class ISpeechGrammarRuleStateTransitionDispT : public TAutoDriver<ISpeechGrammarRuleStateTransition>
{
public:
  ISpeechGrammarRuleStateTransitionDispT(){}

  ISpeechGrammarRuleStateTransitionDispT(ISpeechGrammarRuleStateTransition *pintf)
  {
    TAutoDriver<ISpeechGrammarRuleStateTransition>::Bind(pintf, false);
  }

  ISpeechGrammarRuleStateTransitionDispT(ISpeechGrammarRuleStateTransitionPtr pintf)
  {
    TAutoDriver<ISpeechGrammarRuleStateTransition>::Bind(pintf, true);
  }

  ISpeechGrammarRuleStateTransitionDispT& operator=(ISpeechGrammarRuleStateTransition *pintf)
  {
    TAutoDriver<ISpeechGrammarRuleStateTransition>::Bind(pintf, false);
    return *this;
  }

  ISpeechGrammarRuleStateTransitionDispT& operator=(ISpeechGrammarRuleStateTransitionPtr pintf)
  {
    TAutoDriver<ISpeechGrammarRuleStateTransition>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_Type(Speechlib_tlb::SpeechGrammarRuleStateTransitionType* Type/*[out,retval]*/);
  Speechlib_tlb::SpeechGrammarRuleStateTransitionType __fastcall get_Type(void);
  HRESULT         __fastcall get_Text(BSTR* Text/*[out,retval]*/);
  BSTR            __fastcall get_Text(void);
  HRESULT         __fastcall get_Rule(Speechlib_tlb::ISpeechGrammarRule** Rule/*[out,retval]*/);
  Speechlib_tlb::ISpeechGrammarRulePtr __fastcall get_Rule(void);
  HRESULT         __fastcall get_Weight(VARIANT* Weight/*[out,retval]*/);
  VARIANT         __fastcall get_Weight(void);
  HRESULT         __fastcall get_PropertyName(BSTR* PropertyName/*[out,retval]*/);
  BSTR            __fastcall get_PropertyName(void);
  HRESULT         __fastcall get_PropertyId(long* PropertyId/*[out,retval]*/);
  long            __fastcall get_PropertyId(void);
  HRESULT         __fastcall get_PropertyValue(VARIANT* PropertyValue/*[out,retval]*/);
  VARIANT         __fastcall get_PropertyValue(void);
  HRESULT         __fastcall get_NextState(Speechlib_tlb::ISpeechGrammarRuleState** NextState/*[out,retval]*/);
  Speechlib_tlb::ISpeechGrammarRuleStatePtr __fastcall get_NextState(void);

  __property   Speechlib_tlb::SpeechGrammarRuleStateTransitionType Type = {read = get_Type};
  __property   BSTR            Text = {read = get_Text};
  __property   Speechlib_tlb::ISpeechGrammarRulePtr Rule = {read = get_Rule};
  __property   BSTR            PropertyName = {read = get_PropertyName};
  __property   long            PropertyId = {read = get_PropertyId};
  __property   Speechlib_tlb::ISpeechGrammarRuleStatePtr NextState = {read = get_NextState};
};
typedef ISpeechGrammarRuleStateTransitionDispT<ISpeechGrammarRuleStateTransition> ISpeechGrammarRuleStateTransitionDisp;

// *********************************************************************//
// SmartIntf: TCOMISpeechTextSelectionInformation
// Interface: ISpeechTextSelectionInformation
// *********************************************************************//
template <class T /* ISpeechTextSelectionInformation */ >
class TCOMISpeechTextSelectionInformationT : public TComInterface<ISpeechTextSelectionInformation>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMISpeechTextSelectionInformationT() {}
  TCOMISpeechTextSelectionInformationT(ISpeechTextSelectionInformation *intf, bool addRef = false) : TComInterface<ISpeechTextSelectionInformation>(intf, addRef) {}
  TCOMISpeechTextSelectionInformationT(const TCOMISpeechTextSelectionInformationT& src) : TComInterface<ISpeechTextSelectionInformation>(src) {}
  TCOMISpeechTextSelectionInformationT& operator=(const TCOMISpeechTextSelectionInformationT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall set_ActiveOffset(long ActiveOffset/*[in]*/);
  HRESULT         __fastcall get_ActiveOffset(long* ActiveOffset/*[out,retval]*/);
  long            __fastcall get_ActiveOffset(void);
  HRESULT         __fastcall set_ActiveLength(long ActiveLength/*[in]*/);
  HRESULT         __fastcall get_ActiveLength(long* ActiveLength/*[out,retval]*/);
  long            __fastcall get_ActiveLength(void);
  HRESULT         __fastcall set_SelectionOffset(long SelectionOffset/*[in]*/);
  HRESULT         __fastcall get_SelectionOffset(long* SelectionOffset/*[out,retval]*/);
  long            __fastcall get_SelectionOffset(void);
  HRESULT         __fastcall set_SelectionLength(long SelectionLength/*[in]*/);
  HRESULT         __fastcall get_SelectionLength(long* SelectionLength/*[out,retval]*/);
  long            __fastcall get_SelectionLength(void);

  __property   long            ActiveOffset = {read = get_ActiveOffset, write = set_ActiveOffset};
  __property   long            ActiveLength = {read = get_ActiveLength, write = set_ActiveLength};
  __property   long            SelectionOffset = {read = get_SelectionOffset, write = set_SelectionOffset};
  __property   long            SelectionLength = {read = get_SelectionLength, write = set_SelectionLength};
};
typedef TCOMISpeechTextSelectionInformationT<ISpeechTextSelectionInformation> TCOMISpeechTextSelectionInformation;

// *********************************************************************//
// DispIntf:  ISpeechTextSelectionInformation
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {3B9C7E7A-6EEE-4DED-9092-11657279ADBE}
// *********************************************************************//
template<class T>
class ISpeechTextSelectionInformationDispT : public TAutoDriver<ISpeechTextSelectionInformation>
{
public:
  ISpeechTextSelectionInformationDispT(){}

  ISpeechTextSelectionInformationDispT(ISpeechTextSelectionInformation *pintf)
  {
    TAutoDriver<ISpeechTextSelectionInformation>::Bind(pintf, false);
  }

  ISpeechTextSelectionInformationDispT(ISpeechTextSelectionInformationPtr pintf)
  {
    TAutoDriver<ISpeechTextSelectionInformation>::Bind(pintf, true);
  }

  ISpeechTextSelectionInformationDispT& operator=(ISpeechTextSelectionInformation *pintf)
  {
    TAutoDriver<ISpeechTextSelectionInformation>::Bind(pintf, false);
    return *this;
  }

  ISpeechTextSelectionInformationDispT& operator=(ISpeechTextSelectionInformationPtr pintf)
  {
    TAutoDriver<ISpeechTextSelectionInformation>::Bind(pintf, true);
    return *this;
  }

  HRESULT BindDefault()
  {
    return OLECHECK(Bind(CLSID_SpTextSelectionInformation));
  }

  HRESULT BindRunning()
  {
    return BindToActive(CLSID_SpTextSelectionInformation);
  }

  HRESULT         __fastcall set_ActiveOffset(long ActiveOffset/*[in]*/);
  HRESULT         __fastcall get_ActiveOffset(long* ActiveOffset/*[out,retval]*/);
  long            __fastcall get_ActiveOffset(void);
  HRESULT         __fastcall set_ActiveLength(long ActiveLength/*[in]*/);
  HRESULT         __fastcall get_ActiveLength(long* ActiveLength/*[out,retval]*/);
  long            __fastcall get_ActiveLength(void);
  HRESULT         __fastcall set_SelectionOffset(long SelectionOffset/*[in]*/);
  HRESULT         __fastcall get_SelectionOffset(long* SelectionOffset/*[out,retval]*/);
  long            __fastcall get_SelectionOffset(void);
  HRESULT         __fastcall set_SelectionLength(long SelectionLength/*[in]*/);
  HRESULT         __fastcall get_SelectionLength(long* SelectionLength/*[out,retval]*/);
  long            __fastcall get_SelectionLength(void);

  __property   long            ActiveOffset = {read = get_ActiveOffset, write = set_ActiveOffset};
  __property   long            ActiveLength = {read = get_ActiveLength, write = set_ActiveLength};
  __property   long            SelectionOffset = {read = get_SelectionOffset, write = set_SelectionOffset};
  __property   long            SelectionLength = {read = get_SelectionLength, write = set_SelectionLength};
};
typedef ISpeechTextSelectionInformationDispT<ISpeechTextSelectionInformation> ISpeechTextSelectionInformationDisp;

typedef TComInterface<ISpeechRecoResult>  TCOMISpeechRecoResult;

// *********************************************************************//
// DispIntf:  ISpeechRecoResult
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {ED2879CF-CED9-4EE6-A534-DE0191D5468D}
// *********************************************************************//
template<class T>
class ISpeechRecoResultDispT : public TAutoDriver<ISpeechRecoResult>
{
public:
  ISpeechRecoResultDispT(){}

  ISpeechRecoResultDispT(ISpeechRecoResult *pintf)
  {
    TAutoDriver<ISpeechRecoResult>::Bind(pintf, false);
  }

  ISpeechRecoResultDispT(ISpeechRecoResultPtr pintf)
  {
    TAutoDriver<ISpeechRecoResult>::Bind(pintf, true);
  }

  ISpeechRecoResultDispT& operator=(ISpeechRecoResult *pintf)
  {
    TAutoDriver<ISpeechRecoResult>::Bind(pintf, false);
    return *this;
  }

  ISpeechRecoResultDispT& operator=(ISpeechRecoResultPtr pintf)
  {
    TAutoDriver<ISpeechRecoResult>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_RecoContext(Speechlib_tlb::ISpeechRecoContext** RecoContext/*[out,retval]*/);
  Speechlib_tlb::ISpeechRecoContextPtr __fastcall get_RecoContext(void);
  HRESULT         __fastcall get_Times(Speechlib_tlb::ISpeechRecoResultTimes** Times/*[out,retval]*/);
  Speechlib_tlb::ISpeechRecoResultTimesPtr __fastcall get_Times(void);
  HRESULT         __fastcall _set_AudioFormat(Speechlib_tlb::ISpeechAudioFormat* Format/*[in]*/);
  HRESULT         __fastcall get_AudioFormat(Speechlib_tlb::ISpeechAudioFormat** Format/*[out,retval]*/);
  Speechlib_tlb::ISpeechAudioFormatPtr __fastcall get_AudioFormat(void);
  HRESULT         __fastcall get_PhraseInfo(Speechlib_tlb::ISpeechPhraseInfo** PhraseInfo/*[out,retval]*/);
  Speechlib_tlb::ISpeechPhraseInfoPtr __fastcall get_PhraseInfo(void);
  HRESULT         __fastcall Alternates(long RequestCount/*[in]*/, long StartElement/*[in,def,opt]*/
                                        , long Elements/*[in,def,opt]*/, 
                                        Speechlib_tlb::ISpeechPhraseAlternates** Alternates/*[out,retval]*/);
  Speechlib_tlb::ISpeechPhraseAlternates* __fastcall Alternates(long RequestCount/*[in]*/, 
                                                                long StartElement/*[in,def,opt]*/, 
                                                                long Elements/*[in,def,opt]*/);
  HRESULT         __fastcall Audio(long StartElement/*[in,def,opt]*/, long Elements/*[in,def,opt]*/
                                   , Speechlib_tlb::ISpeechMemoryStream** Stream/*[out,retval]*/);
  Speechlib_tlb::ISpeechMemoryStream* __fastcall Audio(long StartElement/*[in,def,opt]*/, 
                                                       long Elements/*[in,def,opt]*/);
  HRESULT         __fastcall SpeakAudio(long StartElement/*[in,def,opt]*/, 
                                        long Elements/*[in,def,opt]*/, 
                                        Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/, 
                                        long* StreamNumber/*[out,retval]*/);
  long            __fastcall SpeakAudio(long StartElement/*[in,def,opt]*/, 
                                        long Elements/*[in,def,opt]*/, 
                                        Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/);
  HRESULT         __fastcall SaveToMemory(VARIANT* ResultBlock/*[out,retval]*/);
  VARIANT         __fastcall SaveToMemory(void);
  HRESULT         __fastcall DiscardResultInfo(Speechlib_tlb::SpeechDiscardType ValueTypes/*[in]*/);

  __property   Speechlib_tlb::ISpeechRecoContextPtr RecoContext = {read = get_RecoContext};
  __property   Speechlib_tlb::ISpeechRecoResultTimesPtr Times = {read = get_Times};
  __property   Speechlib_tlb::ISpeechAudioFormat* AudioFormat = {write = _set_AudioFormat};
  __property   Speechlib_tlb::ISpeechPhraseInfoPtr PhraseInfo = {read = get_PhraseInfo};
};
typedef ISpeechRecoResultDispT<ISpeechRecoResult> ISpeechRecoResultDisp;

typedef TComInterface<ISpeechRecoResultTimes>  TCOMISpeechRecoResultTimes;

// *********************************************************************//
// DispIntf:  ISpeechRecoResultTimes
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {62B3B8FB-F6E7-41BE-BDCB-056B1C29EFC0}
// *********************************************************************//
template<class T>
class ISpeechRecoResultTimesDispT : public TAutoDriver<ISpeechRecoResultTimes>
{
public:
  ISpeechRecoResultTimesDispT(){}

  ISpeechRecoResultTimesDispT(ISpeechRecoResultTimes *pintf)
  {
    TAutoDriver<ISpeechRecoResultTimes>::Bind(pintf, false);
  }

  ISpeechRecoResultTimesDispT(ISpeechRecoResultTimesPtr pintf)
  {
    TAutoDriver<ISpeechRecoResultTimes>::Bind(pintf, true);
  }

  ISpeechRecoResultTimesDispT& operator=(ISpeechRecoResultTimes *pintf)
  {
    TAutoDriver<ISpeechRecoResultTimes>::Bind(pintf, false);
    return *this;
  }

  ISpeechRecoResultTimesDispT& operator=(ISpeechRecoResultTimesPtr pintf)
  {
    TAutoDriver<ISpeechRecoResultTimes>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_StreamTime(VARIANT* Time/*[out,retval]*/);
  VARIANT         __fastcall get_StreamTime(void);
  HRESULT         __fastcall get_Length(VARIANT* Length/*[out,retval]*/);
  VARIANT         __fastcall get_Length(void);
  HRESULT         __fastcall get_TickCount(long* TickCount/*[out,retval]*/);
  long            __fastcall get_TickCount(void);
  HRESULT         __fastcall get_OffsetFromStart(VARIANT* OffsetFromStart/*[out,retval]*/);
  VARIANT         __fastcall get_OffsetFromStart(void);

  __property   long            TickCount = {read = get_TickCount};
};
typedef ISpeechRecoResultTimesDispT<ISpeechRecoResultTimes> ISpeechRecoResultTimesDisp;

typedef TComInterface<ISpeechPhraseInfo>  TCOMISpeechPhraseInfo;

// *********************************************************************//
// DispIntf:  ISpeechPhraseInfo
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {961559CF-4E67-4662-8BF0-D93F1FCD61B3}
// *********************************************************************//
template<class T>
class ISpeechPhraseInfoDispT : public TAutoDriver<ISpeechPhraseInfo>
{
public:
  ISpeechPhraseInfoDispT(){}

  ISpeechPhraseInfoDispT(ISpeechPhraseInfo *pintf)
  {
    TAutoDriver<ISpeechPhraseInfo>::Bind(pintf, false);
  }

  ISpeechPhraseInfoDispT(ISpeechPhraseInfoPtr pintf)
  {
    TAutoDriver<ISpeechPhraseInfo>::Bind(pintf, true);
  }

  ISpeechPhraseInfoDispT& operator=(ISpeechPhraseInfo *pintf)
  {
    TAutoDriver<ISpeechPhraseInfo>::Bind(pintf, false);
    return *this;
  }

  ISpeechPhraseInfoDispT& operator=(ISpeechPhraseInfoPtr pintf)
  {
    TAutoDriver<ISpeechPhraseInfo>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_LanguageId(long* LanguageId/*[out,retval]*/);
  long            __fastcall get_LanguageId(void);
  HRESULT         __fastcall get_GrammarId(VARIANT* GrammarId/*[out,retval]*/);
  VARIANT         __fastcall get_GrammarId(void);
  HRESULT         __fastcall get_StartTime(VARIANT* StartTime/*[out,retval]*/);
  VARIANT         __fastcall get_StartTime(void);
  HRESULT         __fastcall get_AudioStreamPosition(VARIANT* AudioStreamPosition/*[out,retval]*/);
  VARIANT         __fastcall get_AudioStreamPosition(void);
  HRESULT         __fastcall get_AudioSizeBytes(long* pAudioSizeBytes/*[out,retval]*/);
  long            __fastcall get_AudioSizeBytes(void);
  HRESULT         __fastcall get_RetainedSizeBytes(long* RetainedSizeBytes/*[out,retval]*/);
  long            __fastcall get_RetainedSizeBytes(void);
  HRESULT         __fastcall get_AudioSizeTime(long* AudioSizeTime/*[out,retval]*/);
  long            __fastcall get_AudioSizeTime(void);
  HRESULT         __fastcall get_Rule(Speechlib_tlb::ISpeechPhraseRule** Rule/*[out,retval]*/);
  Speechlib_tlb::ISpeechPhraseRulePtr __fastcall get_Rule(void);
  HRESULT         __fastcall get_Properties(Speechlib_tlb::ISpeechPhraseProperties** Properties/*[out,retval]*/);
  Speechlib_tlb::ISpeechPhrasePropertiesPtr __fastcall get_Properties(void);
  HRESULT         __fastcall get_Elements(Speechlib_tlb::ISpeechPhraseElements** Elements/*[out,retval]*/);
  Speechlib_tlb::ISpeechPhraseElementsPtr __fastcall get_Elements(void);
  HRESULT         __fastcall get_Replacements(Speechlib_tlb::ISpeechPhraseReplacements** Replacements/*[out,retval]*/);
  Speechlib_tlb::ISpeechPhraseReplacementsPtr __fastcall get_Replacements(void);
  HRESULT         __fastcall get_EngineId(BSTR* EngineIdGuid/*[out,retval]*/);
  BSTR            __fastcall get_EngineId(void);
  HRESULT         __fastcall get_EnginePrivateData(VARIANT* PrivateData/*[out,retval]*/);
  VARIANT         __fastcall get_EnginePrivateData(void);
  HRESULT         __fastcall SaveToMemory(VARIANT* PhraseBlock/*[out,retval]*/);
  VARIANT         __fastcall SaveToMemory(void);
  HRESULT         __fastcall GetText(long StartElement/*[in,def,opt]*/, 
                                     long Elements/*[in,def,opt]*/, 
                                     VARIANT_BOOL UseReplacements/*[in,def,opt]*/, 
                                     BSTR* Text/*[out,retval]*/);
  BSTR            __fastcall GetText(long StartElement/*[in,def,opt]*/, 
                                     long Elements/*[in,def,opt]*/, 
                                     VARIANT_BOOL UseReplacements/*[in,def,opt]*/);
  HRESULT         __fastcall GetDisplayAttributes(long StartElement/*[in,def,opt]*/, 
                                                  long Elements/*[in,def,opt]*/, 
                                                  VARIANT_BOOL UseReplacements/*[in,def,opt]*/, 
                                                  Speechlib_tlb::SpeechDisplayAttributes* DisplayAttributes/*[out,retval]*/);
  Speechlib_tlb::SpeechDisplayAttributes __fastcall GetDisplayAttributes(long StartElement/*[in,def,opt]*/, 
                                                                         long Elements/*[in,def,opt]*/, 
                                                                         VARIANT_BOOL UseReplacements/*[in,def,opt]*/);

  __property   long            LanguageId = {read = get_LanguageId};
  __property   long            AudioSizeBytes = {read = get_AudioSizeBytes};
  __property   long            RetainedSizeBytes = {read = get_RetainedSizeBytes};
  __property   long            AudioSizeTime = {read = get_AudioSizeTime};
  __property   Speechlib_tlb::ISpeechPhraseRulePtr Rule = {read = get_Rule};
  __property   Speechlib_tlb::ISpeechPhrasePropertiesPtr Properties = {read = get_Properties};
  __property   Speechlib_tlb::ISpeechPhraseElementsPtr Elements = {read = get_Elements};
  __property   Speechlib_tlb::ISpeechPhraseReplacementsPtr Replacements = {read = get_Replacements};
  __property   BSTR            EngineId = {read = get_EngineId};
};
typedef ISpeechPhraseInfoDispT<ISpeechPhraseInfo> ISpeechPhraseInfoDisp;

typedef TComInterface<ISpeechPhraseRule>  TCOMISpeechPhraseRule;

// *********************************************************************//
// DispIntf:  ISpeechPhraseRule
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {A7BFE112-A4A0-48D9-B602-C313843F6964}
// *********************************************************************//
template<class T>
class ISpeechPhraseRuleDispT : public TAutoDriver<ISpeechPhraseRule>
{
public:
  ISpeechPhraseRuleDispT(){}

  ISpeechPhraseRuleDispT(ISpeechPhraseRule *pintf)
  {
    TAutoDriver<ISpeechPhraseRule>::Bind(pintf, false);
  }

  ISpeechPhraseRuleDispT(ISpeechPhraseRulePtr pintf)
  {
    TAutoDriver<ISpeechPhraseRule>::Bind(pintf, true);
  }

  ISpeechPhraseRuleDispT& operator=(ISpeechPhraseRule *pintf)
  {
    TAutoDriver<ISpeechPhraseRule>::Bind(pintf, false);
    return *this;
  }

  ISpeechPhraseRuleDispT& operator=(ISpeechPhraseRulePtr pintf)
  {
    TAutoDriver<ISpeechPhraseRule>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_Name(BSTR* Name/*[out,retval]*/);
  BSTR            __fastcall get_Name(void);
  HRESULT         __fastcall get_Id(long* Id/*[out,retval]*/);
  long            __fastcall get_Id(void);
  HRESULT         __fastcall get_FirstElement(long* FirstElement/*[out,retval]*/);
  long            __fastcall get_FirstElement(void);
  HRESULT         __fastcall get_NumberOfElements(long* NumberOfElements/*[out,retval]*/);
  long            __fastcall get_NumberOfElements(void);
  HRESULT         __fastcall get_Parent(Speechlib_tlb::ISpeechPhraseRule** Parent/*[out,retval]*/);
  Speechlib_tlb::ISpeechPhraseRulePtr __fastcall get_Parent(void);
  HRESULT         __fastcall get_Children(Speechlib_tlb::ISpeechPhraseRules** Children/*[out,retval]*/);
  Speechlib_tlb::ISpeechPhraseRulesPtr __fastcall get_Children(void);
  HRESULT         __fastcall get_Confidence(Speechlib_tlb::SpeechEngineConfidence* ActualConfidence/*[out,retval]*/);
  Speechlib_tlb::SpeechEngineConfidence __fastcall get_Confidence(void);
  HRESULT         __fastcall get_EngineConfidence(float* EngineConfidence/*[out,retval]*/);
  float           __fastcall get_EngineConfidence(void);

  __property   BSTR            Name = {read = get_Name};
  __property   long            Id = {read = get_Id};
  __property   long            FirstElement = {read = get_FirstElement};
  __property   long            NumberOfElements = {read = get_NumberOfElements};
  __property   Speechlib_tlb::ISpeechPhraseRulePtr Parent = {read = get_Parent};
  __property   Speechlib_tlb::ISpeechPhraseRulesPtr Children = {read = get_Children};
  __property   Speechlib_tlb::SpeechEngineConfidence Confidence = {read = get_Confidence};
  __property   float           EngineConfidence = {read = get_EngineConfidence};
};
typedef ISpeechPhraseRuleDispT<ISpeechPhraseRule> ISpeechPhraseRuleDisp;

typedef TComInterface<ISpeechPhraseRules>  TCOMISpeechPhraseRules;

// *********************************************************************//
// DispIntf:  ISpeechPhraseRules
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {9047D593-01DD-4B72-81A3-E4A0CA69F407}
// *********************************************************************//
template<class T>
class ISpeechPhraseRulesDispT : public TAutoDriver<ISpeechPhraseRules>
{
public:
  ISpeechPhraseRulesDispT(){}

  ISpeechPhraseRulesDispT(ISpeechPhraseRules *pintf)
  {
    TAutoDriver<ISpeechPhraseRules>::Bind(pintf, false);
  }

  ISpeechPhraseRulesDispT(ISpeechPhraseRulesPtr pintf)
  {
    TAutoDriver<ISpeechPhraseRules>::Bind(pintf, true);
  }

  ISpeechPhraseRulesDispT& operator=(ISpeechPhraseRules *pintf)
  {
    TAutoDriver<ISpeechPhraseRules>::Bind(pintf, false);
    return *this;
  }

  ISpeechPhraseRulesDispT& operator=(ISpeechPhraseRulesPtr pintf)
  {
    TAutoDriver<ISpeechPhraseRules>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_Count(long* Count/*[out,retval]*/);
  long            __fastcall get_Count(void);
  HRESULT         __fastcall Item(long Index/*[in]*/, 
                                  Speechlib_tlb::ISpeechPhraseRule** Rule/*[out,retval]*/);
  Speechlib_tlb::ISpeechPhraseRule* __fastcall Item(long Index/*[in]*/);
  HRESULT         __fastcall get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/);
  LPUNKNOWN       __fastcall get__NewEnum(void);

  __property   long            Count = {read = get_Count};
  __property   LPUNKNOWN       _NewEnum = {read = get__NewEnum};
};
typedef ISpeechPhraseRulesDispT<ISpeechPhraseRules> ISpeechPhraseRulesDisp;

typedef TComInterface<ISpeechPhraseProperties>  TCOMISpeechPhraseProperties;

// *********************************************************************//
// DispIntf:  ISpeechPhraseProperties
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {08166B47-102E-4B23-A599-BDB98DBFD1F4}
// *********************************************************************//
template<class T>
class ISpeechPhrasePropertiesDispT : public TAutoDriver<ISpeechPhraseProperties>
{
public:
  ISpeechPhrasePropertiesDispT(){}

  ISpeechPhrasePropertiesDispT(ISpeechPhraseProperties *pintf)
  {
    TAutoDriver<ISpeechPhraseProperties>::Bind(pintf, false);
  }

  ISpeechPhrasePropertiesDispT(ISpeechPhrasePropertiesPtr pintf)
  {
    TAutoDriver<ISpeechPhraseProperties>::Bind(pintf, true);
  }

  ISpeechPhrasePropertiesDispT& operator=(ISpeechPhraseProperties *pintf)
  {
    TAutoDriver<ISpeechPhraseProperties>::Bind(pintf, false);
    return *this;
  }

  ISpeechPhrasePropertiesDispT& operator=(ISpeechPhrasePropertiesPtr pintf)
  {
    TAutoDriver<ISpeechPhraseProperties>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_Count(long* Count/*[out,retval]*/);
  long            __fastcall get_Count(void);
  HRESULT         __fastcall Item(long Index/*[in]*/, 
                                  Speechlib_tlb::ISpeechPhraseProperty** Property/*[out,retval]*/);
  Speechlib_tlb::ISpeechPhraseProperty* __fastcall Item(long Index/*[in]*/);
  HRESULT         __fastcall get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/);
  LPUNKNOWN       __fastcall get__NewEnum(void);

  __property   long            Count = {read = get_Count};
  __property   LPUNKNOWN       _NewEnum = {read = get__NewEnum};
};
typedef ISpeechPhrasePropertiesDispT<ISpeechPhraseProperties> ISpeechPhrasePropertiesDisp;

typedef TComInterface<ISpeechPhraseProperty>  TCOMISpeechPhraseProperty;

// *********************************************************************//
// DispIntf:  ISpeechPhraseProperty
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {CE563D48-961E-4732-A2E1-378A42B430BE}
// *********************************************************************//
template<class T>
class ISpeechPhrasePropertyDispT : public TAutoDriver<ISpeechPhraseProperty>
{
public:
  ISpeechPhrasePropertyDispT(){}

  ISpeechPhrasePropertyDispT(ISpeechPhraseProperty *pintf)
  {
    TAutoDriver<ISpeechPhraseProperty>::Bind(pintf, false);
  }

  ISpeechPhrasePropertyDispT(ISpeechPhrasePropertyPtr pintf)
  {
    TAutoDriver<ISpeechPhraseProperty>::Bind(pintf, true);
  }

  ISpeechPhrasePropertyDispT& operator=(ISpeechPhraseProperty *pintf)
  {
    TAutoDriver<ISpeechPhraseProperty>::Bind(pintf, false);
    return *this;
  }

  ISpeechPhrasePropertyDispT& operator=(ISpeechPhrasePropertyPtr pintf)
  {
    TAutoDriver<ISpeechPhraseProperty>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_Name(BSTR* Name/*[out,retval]*/);
  BSTR            __fastcall get_Name(void);
  HRESULT         __fastcall get_Id(long* Id/*[out,retval]*/);
  long            __fastcall get_Id(void);
  HRESULT         __fastcall get_Value(VARIANT* Value/*[out,retval]*/);
  VARIANT         __fastcall get_Value(void);
  HRESULT         __fastcall get_FirstElement(long* FirstElement/*[out,retval]*/);
  long            __fastcall get_FirstElement(void);
  HRESULT         __fastcall get_NumberOfElements(long* NumberOfElements/*[out,retval]*/);
  long            __fastcall get_NumberOfElements(void);
  HRESULT         __fastcall get_EngineConfidence(float* Confidence/*[out,retval]*/);
  float           __fastcall get_EngineConfidence(void);
  HRESULT         __fastcall get_Confidence(Speechlib_tlb::SpeechEngineConfidence* Confidence/*[out,retval]*/);
  Speechlib_tlb::SpeechEngineConfidence __fastcall get_Confidence(void);
  HRESULT         __fastcall get_Parent(Speechlib_tlb::ISpeechPhraseProperty** ParentProperty/*[out,retval]*/);
  Speechlib_tlb::ISpeechPhrasePropertyPtr __fastcall get_Parent(void);
  HRESULT         __fastcall get_Children(Speechlib_tlb::ISpeechPhraseProperties** Children/*[out,retval]*/);
  Speechlib_tlb::ISpeechPhrasePropertiesPtr __fastcall get_Children(void);

  __property   BSTR            Name = {read = get_Name};
  __property   long            Id = {read = get_Id};
  __property   long            FirstElement = {read = get_FirstElement};
  __property   long            NumberOfElements = {read = get_NumberOfElements};
  __property   float           EngineConfidence = {read = get_EngineConfidence};
  __property   Speechlib_tlb::SpeechEngineConfidence Confidence = {read = get_Confidence};
  __property   Speechlib_tlb::ISpeechPhrasePropertyPtr Parent = {read = get_Parent};
  __property   Speechlib_tlb::ISpeechPhrasePropertiesPtr Children = {read = get_Children};
};
typedef ISpeechPhrasePropertyDispT<ISpeechPhraseProperty> ISpeechPhrasePropertyDisp;

typedef TComInterface<ISpeechPhraseElements>  TCOMISpeechPhraseElements;

// *********************************************************************//
// DispIntf:  ISpeechPhraseElements
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {0626B328-3478-467D-A0B3-D0853B93DDA3}
// *********************************************************************//
template<class T>
class ISpeechPhraseElementsDispT : public TAutoDriver<ISpeechPhraseElements>
{
public:
  ISpeechPhraseElementsDispT(){}

  ISpeechPhraseElementsDispT(ISpeechPhraseElements *pintf)
  {
    TAutoDriver<ISpeechPhraseElements>::Bind(pintf, false);
  }

  ISpeechPhraseElementsDispT(ISpeechPhraseElementsPtr pintf)
  {
    TAutoDriver<ISpeechPhraseElements>::Bind(pintf, true);
  }

  ISpeechPhraseElementsDispT& operator=(ISpeechPhraseElements *pintf)
  {
    TAutoDriver<ISpeechPhraseElements>::Bind(pintf, false);
    return *this;
  }

  ISpeechPhraseElementsDispT& operator=(ISpeechPhraseElementsPtr pintf)
  {
    TAutoDriver<ISpeechPhraseElements>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_Count(long* Count/*[out,retval]*/);
  long            __fastcall get_Count(void);
  HRESULT         __fastcall Item(long Index/*[in]*/, 
                                  Speechlib_tlb::ISpeechPhraseElement** Element/*[out,retval]*/);
  Speechlib_tlb::ISpeechPhraseElement* __fastcall Item(long Index/*[in]*/);
  HRESULT         __fastcall get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/);
  LPUNKNOWN       __fastcall get__NewEnum(void);

  __property   long            Count = {read = get_Count};
  __property   LPUNKNOWN       _NewEnum = {read = get__NewEnum};
};
typedef ISpeechPhraseElementsDispT<ISpeechPhraseElements> ISpeechPhraseElementsDisp;

typedef TComInterface<ISpeechPhraseElement>  TCOMISpeechPhraseElement;

// *********************************************************************//
// DispIntf:  ISpeechPhraseElement
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {E6176F96-E373-4801-B223-3B62C068C0B4}
// *********************************************************************//
template<class T>
class ISpeechPhraseElementDispT : public TAutoDriver<ISpeechPhraseElement>
{
public:
  ISpeechPhraseElementDispT(){}

  ISpeechPhraseElementDispT(ISpeechPhraseElement *pintf)
  {
    TAutoDriver<ISpeechPhraseElement>::Bind(pintf, false);
  }

  ISpeechPhraseElementDispT(ISpeechPhraseElementPtr pintf)
  {
    TAutoDriver<ISpeechPhraseElement>::Bind(pintf, true);
  }

  ISpeechPhraseElementDispT& operator=(ISpeechPhraseElement *pintf)
  {
    TAutoDriver<ISpeechPhraseElement>::Bind(pintf, false);
    return *this;
  }

  ISpeechPhraseElementDispT& operator=(ISpeechPhraseElementPtr pintf)
  {
    TAutoDriver<ISpeechPhraseElement>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_AudioTimeOffset(long* AudioTimeOffset/*[out,retval]*/);
  long            __fastcall get_AudioTimeOffset(void);
  HRESULT         __fastcall get_AudioSizeTime(long* AudioSizeTime/*[out,retval]*/);
  long            __fastcall get_AudioSizeTime(void);
  HRESULT         __fastcall get_AudioStreamOffset(long* AudioStreamOffset/*[out,retval]*/);
  long            __fastcall get_AudioStreamOffset(void);
  HRESULT         __fastcall get_AudioSizeBytes(long* AudioSizeBytes/*[out,retval]*/);
  long            __fastcall get_AudioSizeBytes(void);
  HRESULT         __fastcall get_RetainedStreamOffset(long* RetainedStreamOffset/*[out,retval]*/);
  long            __fastcall get_RetainedStreamOffset(void);
  HRESULT         __fastcall get_RetainedSizeBytes(long* RetainedSizeBytes/*[out,retval]*/);
  long            __fastcall get_RetainedSizeBytes(void);
  HRESULT         __fastcall get_DisplayText(BSTR* DisplayText/*[out,retval]*/);
  BSTR            __fastcall get_DisplayText(void);
  HRESULT         __fastcall get_LexicalForm(BSTR* LexicalForm/*[out,retval]*/);
  BSTR            __fastcall get_LexicalForm(void);
  HRESULT         __fastcall get_Pronunciation(VARIANT* Pronunciation/*[out,retval]*/);
  VARIANT         __fastcall get_Pronunciation(void);
  HRESULT         __fastcall get_DisplayAttributes(Speechlib_tlb::SpeechDisplayAttributes* DisplayAttributes/*[out,retval]*/);
  Speechlib_tlb::SpeechDisplayAttributes __fastcall get_DisplayAttributes(void);
  HRESULT         __fastcall get_RequiredConfidence(Speechlib_tlb::SpeechEngineConfidence* RequiredConfidence/*[out,retval]*/);
  Speechlib_tlb::SpeechEngineConfidence __fastcall get_RequiredConfidence(void);
  HRESULT         __fastcall get_ActualConfidence(Speechlib_tlb::SpeechEngineConfidence* ActualConfidence/*[out,retval]*/);
  Speechlib_tlb::SpeechEngineConfidence __fastcall get_ActualConfidence(void);
  HRESULT         __fastcall get_EngineConfidence(float* EngineConfidence/*[out,retval]*/);
  float           __fastcall get_EngineConfidence(void);

  __property   long            AudioTimeOffset = {read = get_AudioTimeOffset};
  __property   long            AudioSizeTime = {read = get_AudioSizeTime};
  __property   long            AudioStreamOffset = {read = get_AudioStreamOffset};
  __property   long            AudioSizeBytes = {read = get_AudioSizeBytes};
  __property   long            RetainedStreamOffset = {read = get_RetainedStreamOffset};
  __property   long            RetainedSizeBytes = {read = get_RetainedSizeBytes};
  __property   BSTR            DisplayText = {read = get_DisplayText};
  __property   BSTR            LexicalForm = {read = get_LexicalForm};
  __property   Speechlib_tlb::SpeechDisplayAttributes DisplayAttributes = {read = get_DisplayAttributes};
  __property   Speechlib_tlb::SpeechEngineConfidence RequiredConfidence = {read = get_RequiredConfidence};
  __property   Speechlib_tlb::SpeechEngineConfidence ActualConfidence = {read = get_ActualConfidence};
  __property   float           EngineConfidence = {read = get_EngineConfidence};
};
typedef ISpeechPhraseElementDispT<ISpeechPhraseElement> ISpeechPhraseElementDisp;

typedef TComInterface<ISpeechPhraseReplacements>  TCOMISpeechPhraseReplacements;

// *********************************************************************//
// DispIntf:  ISpeechPhraseReplacements
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {38BC662F-2257-4525-959E-2069D2596C05}
// *********************************************************************//
template<class T>
class ISpeechPhraseReplacementsDispT : public TAutoDriver<ISpeechPhraseReplacements>
{
public:
  ISpeechPhraseReplacementsDispT(){}

  ISpeechPhraseReplacementsDispT(ISpeechPhraseReplacements *pintf)
  {
    TAutoDriver<ISpeechPhraseReplacements>::Bind(pintf, false);
  }

  ISpeechPhraseReplacementsDispT(ISpeechPhraseReplacementsPtr pintf)
  {
    TAutoDriver<ISpeechPhraseReplacements>::Bind(pintf, true);
  }

  ISpeechPhraseReplacementsDispT& operator=(ISpeechPhraseReplacements *pintf)
  {
    TAutoDriver<ISpeechPhraseReplacements>::Bind(pintf, false);
    return *this;
  }

  ISpeechPhraseReplacementsDispT& operator=(ISpeechPhraseReplacementsPtr pintf)
  {
    TAutoDriver<ISpeechPhraseReplacements>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_Count(long* Count/*[out,retval]*/);
  long            __fastcall get_Count(void);
  HRESULT         __fastcall Item(long Index/*[in]*/, 
                                  Speechlib_tlb::ISpeechPhraseReplacement** Reps/*[out,retval]*/);
  Speechlib_tlb::ISpeechPhraseReplacement* __fastcall Item(long Index/*[in]*/);
  HRESULT         __fastcall get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/);
  LPUNKNOWN       __fastcall get__NewEnum(void);

  __property   long            Count = {read = get_Count};
  __property   LPUNKNOWN       _NewEnum = {read = get__NewEnum};
};
typedef ISpeechPhraseReplacementsDispT<ISpeechPhraseReplacements> ISpeechPhraseReplacementsDisp;

typedef TComInterface<ISpeechPhraseReplacement>  TCOMISpeechPhraseReplacement;

// *********************************************************************//
// DispIntf:  ISpeechPhraseReplacement
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {2890A410-53A7-4FB5-94EC-06D4998E3D02}
// *********************************************************************//
template<class T>
class ISpeechPhraseReplacementDispT : public TAutoDriver<ISpeechPhraseReplacement>
{
public:
  ISpeechPhraseReplacementDispT(){}

  ISpeechPhraseReplacementDispT(ISpeechPhraseReplacement *pintf)
  {
    TAutoDriver<ISpeechPhraseReplacement>::Bind(pintf, false);
  }

  ISpeechPhraseReplacementDispT(ISpeechPhraseReplacementPtr pintf)
  {
    TAutoDriver<ISpeechPhraseReplacement>::Bind(pintf, true);
  }

  ISpeechPhraseReplacementDispT& operator=(ISpeechPhraseReplacement *pintf)
  {
    TAutoDriver<ISpeechPhraseReplacement>::Bind(pintf, false);
    return *this;
  }

  ISpeechPhraseReplacementDispT& operator=(ISpeechPhraseReplacementPtr pintf)
  {
    TAutoDriver<ISpeechPhraseReplacement>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_DisplayAttributes(Speechlib_tlb::SpeechDisplayAttributes* DisplayAttributes/*[out,retval]*/);
  Speechlib_tlb::SpeechDisplayAttributes __fastcall get_DisplayAttributes(void);
  HRESULT         __fastcall get_Text(BSTR* Text/*[out,retval]*/);
  BSTR            __fastcall get_Text(void);
  HRESULT         __fastcall get_FirstElement(long* FirstElement/*[out,retval]*/);
  long            __fastcall get_FirstElement(void);
  HRESULT         __fastcall get_NumberOfElements(long* NumberOfElements/*[out,retval]*/);
  long            __fastcall get_NumberOfElements(void);

  __property   Speechlib_tlb::SpeechDisplayAttributes DisplayAttributes = {read = get_DisplayAttributes};
  __property   BSTR            Text = {read = get_Text};
  __property   long            FirstElement = {read = get_FirstElement};
  __property   long            NumberOfElements = {read = get_NumberOfElements};
};
typedef ISpeechPhraseReplacementDispT<ISpeechPhraseReplacement> ISpeechPhraseReplacementDisp;

typedef TComInterface<ISpeechPhraseAlternates>  TCOMISpeechPhraseAlternates;

// *********************************************************************//
// DispIntf:  ISpeechPhraseAlternates
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {B238B6D5-F276-4C3D-A6C1-2974801C3CC2}
// *********************************************************************//
template<class T>
class ISpeechPhraseAlternatesDispT : public TAutoDriver<ISpeechPhraseAlternates>
{
public:
  ISpeechPhraseAlternatesDispT(){}

  ISpeechPhraseAlternatesDispT(ISpeechPhraseAlternates *pintf)
  {
    TAutoDriver<ISpeechPhraseAlternates>::Bind(pintf, false);
  }

  ISpeechPhraseAlternatesDispT(ISpeechPhraseAlternatesPtr pintf)
  {
    TAutoDriver<ISpeechPhraseAlternates>::Bind(pintf, true);
  }

  ISpeechPhraseAlternatesDispT& operator=(ISpeechPhraseAlternates *pintf)
  {
    TAutoDriver<ISpeechPhraseAlternates>::Bind(pintf, false);
    return *this;
  }

  ISpeechPhraseAlternatesDispT& operator=(ISpeechPhraseAlternatesPtr pintf)
  {
    TAutoDriver<ISpeechPhraseAlternates>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_Count(long* Count/*[out,retval]*/);
  long            __fastcall get_Count(void);
  HRESULT         __fastcall Item(long Index/*[in]*/, 
                                  Speechlib_tlb::ISpeechPhraseAlternate** PhraseAlternate/*[out,retval]*/);
  Speechlib_tlb::ISpeechPhraseAlternate* __fastcall Item(long Index/*[in]*/);
  HRESULT         __fastcall get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/);
  LPUNKNOWN       __fastcall get__NewEnum(void);

  __property   long            Count = {read = get_Count};
  __property   LPUNKNOWN       _NewEnum = {read = get__NewEnum};
};
typedef ISpeechPhraseAlternatesDispT<ISpeechPhraseAlternates> ISpeechPhraseAlternatesDisp;

typedef TComInterface<ISpeechPhraseAlternate>  TCOMISpeechPhraseAlternate;

// *********************************************************************//
// DispIntf:  ISpeechPhraseAlternate
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {27864A2A-2B9F-4CB8-92D3-0D2722FD1E73}
// *********************************************************************//
template<class T>
class ISpeechPhraseAlternateDispT : public TAutoDriver<ISpeechPhraseAlternate>
{
public:
  ISpeechPhraseAlternateDispT(){}

  ISpeechPhraseAlternateDispT(ISpeechPhraseAlternate *pintf)
  {
    TAutoDriver<ISpeechPhraseAlternate>::Bind(pintf, false);
  }

  ISpeechPhraseAlternateDispT(ISpeechPhraseAlternatePtr pintf)
  {
    TAutoDriver<ISpeechPhraseAlternate>::Bind(pintf, true);
  }

  ISpeechPhraseAlternateDispT& operator=(ISpeechPhraseAlternate *pintf)
  {
    TAutoDriver<ISpeechPhraseAlternate>::Bind(pintf, false);
    return *this;
  }

  ISpeechPhraseAlternateDispT& operator=(ISpeechPhraseAlternatePtr pintf)
  {
    TAutoDriver<ISpeechPhraseAlternate>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_RecoResult(Speechlib_tlb::ISpeechRecoResult** RecoResult/*[out,retval]*/);
  Speechlib_tlb::ISpeechRecoResultPtr __fastcall get_RecoResult(void);
  HRESULT         __fastcall get_StartElementInResult(long* StartElement/*[out,retval]*/);
  long            __fastcall get_StartElementInResult(void);
  HRESULT         __fastcall get_NumberOfElementsInResult(long* NumberOfElements/*[out,retval]*/);
  long            __fastcall get_NumberOfElementsInResult(void);
  HRESULT         __fastcall get_PhraseInfo(Speechlib_tlb::ISpeechPhraseInfo** PhraseInfo/*[out,retval]*/);
  Speechlib_tlb::ISpeechPhraseInfoPtr __fastcall get_PhraseInfo(void);
  HRESULT         __fastcall Commit();

  __property   Speechlib_tlb::ISpeechRecoResultPtr RecoResult = {read = get_RecoResult};
  __property   long            StartElementInResult = {read = get_StartElementInResult};
  __property   long            NumberOfElementsInResult = {read = get_NumberOfElementsInResult};
  __property   Speechlib_tlb::ISpeechPhraseInfoPtr PhraseInfo = {read = get_PhraseInfo};
};
typedef ISpeechPhraseAlternateDispT<ISpeechPhraseAlternate> ISpeechPhraseAlternateDisp;

// *********************************************************************//
// DispIntf:  _ISpeechRecoContextEvents
// Flags:     (4096) Dispatchable
// GUID:      {7B8FCB42-0E9D-4F00-A048-7B04D6179D3D}
// *********************************************************************//
template <class T>
class _ISpeechRecoContextEventsDispT : public TAutoDriver<_ISpeechRecoContextEvents>
{
public:
  _ISpeechRecoContextEventsDispT(){}

  void Attach(LPUNKNOWN punk)
  { m_Dispatch = static_cast<T*>(punk); }

  void            __fastcall StartStream(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/);
  void            __fastcall EndStream(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                       VARIANT_BOOL StreamReleased/*[in]*/);
  void            __fastcall Bookmark(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                      VARIANT BookmarkId/*[in]*/, 
                                      Speechlib_tlb::SpeechBookmarkOptions Options/*[in]*/);
  void            __fastcall SoundStart(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/);
  void            __fastcall SoundEnd(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/);
  void            __fastcall PhraseStart(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/);
  void            __fastcall Recognition(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                         Speechlib_tlb::SpeechRecognitionType RecognitionType/*[in]*/
                                         , Speechlib_tlb::ISpeechRecoResult* Result/*[in]*/);
  void            __fastcall Hypothesis(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                        Speechlib_tlb::ISpeechRecoResult* Result/*[in]*/);
  void            __fastcall PropertyNumberChange(long StreamNumber/*[in]*/, 
                                                  VARIANT StreamPosition/*[in]*/, 
                                                  BSTR PropertyName/*[in]*/, 
                                                  long NewNumberValue/*[in]*/);
  void            __fastcall PropertyStringChange(long StreamNumber/*[in]*/, 
                                                  VARIANT StreamPosition/*[in]*/, 
                                                  BSTR PropertyName/*[in]*/, 
                                                  BSTR NewStringValue/*[in]*/);
  void            __fastcall FalseRecognition(long StreamNumber/*[in]*/, 
                                              VARIANT StreamPosition/*[in]*/, 
                                              Speechlib_tlb::ISpeechRecoResult* Result/*[in]*/);
  void            __fastcall Interference(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/
                                          , Speechlib_tlb::SpeechInterference Interference/*[in]*/);
  void            __fastcall RequestUI(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                       BSTR UIType/*[in]*/);
  void            __fastcall RecognizerStateChange(long StreamNumber/*[in]*/, 
                                                   VARIANT StreamPosition/*[in]*/, 
                                                   Speechlib_tlb::SpeechRecognizerState NewState/*[in]*/);
  void            __fastcall Adaptation(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/);
  void            __fastcall RecognitionForOtherContext(long StreamNumber/*[in]*/, 
                                                        VARIANT StreamPosition/*[in]*/);
  void            __fastcall AudioLevel(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                        long AudioLevel/*[in]*/);
  void            __fastcall EnginePrivate(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/
                                           , VARIANT EngineData/*[in]*/);

};
typedef _ISpeechRecoContextEventsDispT<_ISpeechRecoContextEvents> _ISpeechRecoContextEventsDisp;

typedef TComInterface<ISpeechRecoResult2>  TCOMISpeechRecoResult2;

// *********************************************************************//
// DispIntf:  ISpeechRecoResult2
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {8E0A246D-D3C8-45DE-8657-04290C458C3C}
// *********************************************************************//
template<class T>
class ISpeechRecoResult2DispT : public TAutoDriver<ISpeechRecoResult2>
{
public:
  ISpeechRecoResult2DispT(){}

  ISpeechRecoResult2DispT(ISpeechRecoResult2 *pintf)
  {
    TAutoDriver<ISpeechRecoResult2>::Bind(pintf, false);
  }

  ISpeechRecoResult2DispT(ISpeechRecoResult2Ptr pintf)
  {
    TAutoDriver<ISpeechRecoResult2>::Bind(pintf, true);
  }

  ISpeechRecoResult2DispT& operator=(ISpeechRecoResult2 *pintf)
  {
    TAutoDriver<ISpeechRecoResult2>::Bind(pintf, false);
    return *this;
  }

  ISpeechRecoResult2DispT& operator=(ISpeechRecoResult2Ptr pintf)
  {
    TAutoDriver<ISpeechRecoResult2>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall SetTextFeedback(BSTR Feedback/*[in]*/, 
                                             VARIANT_BOOL WasSuccessful/*[in]*/);
  HRESULT         __fastcall get_RecoContext(Speechlib_tlb::ISpeechRecoContext** RecoContext/*[out,retval]*/);
  Speechlib_tlb::ISpeechRecoContextPtr __fastcall get_RecoContext(void);
  HRESULT         __fastcall get_Times(Speechlib_tlb::ISpeechRecoResultTimes** Times/*[out,retval]*/);
  Speechlib_tlb::ISpeechRecoResultTimesPtr __fastcall get_Times(void);
  HRESULT         __fastcall _set_AudioFormat(Speechlib_tlb::ISpeechAudioFormat* Format/*[in]*/);
  HRESULT         __fastcall get_AudioFormat(Speechlib_tlb::ISpeechAudioFormat** Format/*[out,retval]*/);
  Speechlib_tlb::ISpeechAudioFormatPtr __fastcall get_AudioFormat(void);
  HRESULT         __fastcall get_PhraseInfo(Speechlib_tlb::ISpeechPhraseInfo** PhraseInfo/*[out,retval]*/);
  Speechlib_tlb::ISpeechPhraseInfoPtr __fastcall get_PhraseInfo(void);
  HRESULT         __fastcall Alternates(long RequestCount/*[in]*/, long StartElement/*[in,def,opt]*/
                                        , long Elements/*[in,def,opt]*/, 
                                        Speechlib_tlb::ISpeechPhraseAlternates** Alternates/*[out,retval]*/);
  Speechlib_tlb::ISpeechPhraseAlternates* __fastcall Alternates(long RequestCount/*[in]*/, 
                                                                long StartElement/*[in,def,opt]*/, 
                                                                long Elements/*[in,def,opt]*/);
  HRESULT         __fastcall Audio(long StartElement/*[in,def,opt]*/, long Elements/*[in,def,opt]*/
                                   , Speechlib_tlb::ISpeechMemoryStream** Stream/*[out,retval]*/);
  Speechlib_tlb::ISpeechMemoryStream* __fastcall Audio(long StartElement/*[in,def,opt]*/, 
                                                       long Elements/*[in,def,opt]*/);
  HRESULT         __fastcall SpeakAudio(long StartElement/*[in,def,opt]*/, 
                                        long Elements/*[in,def,opt]*/, 
                                        Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/, 
                                        long* StreamNumber/*[out,retval]*/);
  long            __fastcall SpeakAudio(long StartElement/*[in,def,opt]*/, 
                                        long Elements/*[in,def,opt]*/, 
                                        Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/);
  HRESULT         __fastcall SaveToMemory(VARIANT* ResultBlock/*[out,retval]*/);
  VARIANT         __fastcall SaveToMemory(void);
  HRESULT         __fastcall DiscardResultInfo(Speechlib_tlb::SpeechDiscardType ValueTypes/*[in]*/);


  __property   Speechlib_tlb::ISpeechRecoContextPtr RecoContext = {read = get_RecoContext};
  __property   Speechlib_tlb::ISpeechRecoResultTimesPtr Times = {read = get_Times};
  __property   Speechlib_tlb::ISpeechAudioFormat* AudioFormat = {write = _set_AudioFormat};
  __property   Speechlib_tlb::ISpeechPhraseInfoPtr PhraseInfo = {read = get_PhraseInfo};
};
typedef ISpeechRecoResult2DispT<ISpeechRecoResult2> ISpeechRecoResult2Disp;

// *********************************************************************//
// SmartIntf: TCOMISpeechLexicon
// Interface: ISpeechLexicon
// *********************************************************************//
template <class T /* ISpeechLexicon */ >
class TCOMISpeechLexiconT : public TComInterface<ISpeechLexicon>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMISpeechLexiconT() {}
  TCOMISpeechLexiconT(ISpeechLexicon *intf, bool addRef = false) : TComInterface<ISpeechLexicon>(intf, addRef) {}
  TCOMISpeechLexiconT(const TCOMISpeechLexiconT& src) : TComInterface<ISpeechLexicon>(src) {}
  TCOMISpeechLexiconT& operator=(const TCOMISpeechLexiconT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall get_GenerationId(long* GenerationId/*[out,retval]*/);
  long            __fastcall get_GenerationId(void);
  HRESULT         __fastcall GetWords(Speechlib_tlb::SpeechLexiconType Flags/*[in,def,opt]*/, 
                                      long* GenerationId/*[out,def,opt]*/, 
                                      Speechlib_tlb::ISpeechLexiconWords** Words/*[out,retval]*/);
  Speechlib_tlb::ISpeechLexiconWords* __fastcall GetWords(Speechlib_tlb::SpeechLexiconType Flags/*[in,def,opt]*/, 
                                                          long* GenerationId/*[out,def,opt]*/);
  HRESULT         __fastcall AddPronunciation(BSTR bstrWord/*[in]*/, long LangId/*[in]*/, 
                                              Speechlib_tlb::SpeechPartOfSpeech PartOfSpeech/*[in,def,opt]*/, 
                                              BSTR bstrPronunciation/*[in,def,opt]*/);
  HRESULT         __fastcall AddPronunciationByPhoneIds(BSTR bstrWord/*[in]*/, long LangId/*[in]*/, 
                                                        Speechlib_tlb::SpeechPartOfSpeech PartOfSpeech/*[in,def,opt]*/, 
                                                        VARIANT* PhoneIds/*[in,def,opt]*/= TNoParam());
  HRESULT         __fastcall RemovePronunciation(BSTR bstrWord/*[in]*/, long LangId/*[in]*/, 
                                                 Speechlib_tlb::SpeechPartOfSpeech PartOfSpeech/*[in,def,opt]*/, 
                                                 BSTR bstrPronunciation/*[in,def,opt]*/);
  HRESULT         __fastcall RemovePronunciationByPhoneIds(BSTR bstrWord/*[in]*/, 
                                                           long LangId/*[in]*/, 
                                                           Speechlib_tlb::SpeechPartOfSpeech PartOfSpeech/*[in,def,opt]*/, 
                                                           VARIANT* PhoneIds/*[in,def,opt]*/= TNoParam());
  HRESULT         __fastcall GetPronunciations(BSTR bstrWord/*[in]*/, long LangId/*[in,def,opt]*/, 
                                               Speechlib_tlb::SpeechLexiconType TypeFlags/*[in,def,opt]*/, 
                                               Speechlib_tlb::ISpeechLexiconPronunciations** ppPronunciations/*[out,retval]*/);
  Speechlib_tlb::ISpeechLexiconPronunciations* __fastcall GetPronunciations(BSTR bstrWord/*[in]*/, 
                                                                            long LangId/*[in,def,opt]*/, 
                                                                            Speechlib_tlb::SpeechLexiconType TypeFlags/*[in,def,opt]*/);
  HRESULT         __fastcall GetGenerationChange(long* GenerationId/*[in,out]*/, 
                                                 Speechlib_tlb::ISpeechLexiconWords** ppWords/*[out,retval]*/);
  Speechlib_tlb::ISpeechLexiconWords* __fastcall GetGenerationChange(long* GenerationId/*[in,out]*/);

  __property   long            GenerationId = {read = get_GenerationId};
};
typedef TCOMISpeechLexiconT<ISpeechLexicon> TCOMISpeechLexicon;

// *********************************************************************//
// DispIntf:  ISpeechLexicon
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {3DA7627A-C7AE-4B23-8708-638C50362C25}
// *********************************************************************//
template<class T>
class ISpeechLexiconDispT : public TAutoDriver<ISpeechLexicon>
{
public:
  ISpeechLexiconDispT(){}

  ISpeechLexiconDispT(ISpeechLexicon *pintf)
  {
    TAutoDriver<ISpeechLexicon>::Bind(pintf, false);
  }

  ISpeechLexiconDispT(ISpeechLexiconPtr pintf)
  {
    TAutoDriver<ISpeechLexicon>::Bind(pintf, true);
  }

  ISpeechLexiconDispT& operator=(ISpeechLexicon *pintf)
  {
    TAutoDriver<ISpeechLexicon>::Bind(pintf, false);
    return *this;
  }

  ISpeechLexiconDispT& operator=(ISpeechLexiconPtr pintf)
  {
    TAutoDriver<ISpeechLexicon>::Bind(pintf, true);
    return *this;
  }

  HRESULT BindDefault()
  {
    return OLECHECK(Bind(CLSID_SpLexicon));
  }

  HRESULT BindRunning()
  {
    return BindToActive(CLSID_SpLexicon);
  }

  HRESULT         __fastcall get_GenerationId(long* GenerationId/*[out,retval]*/);
  long            __fastcall get_GenerationId(void);
  HRESULT         __fastcall GetWords(Speechlib_tlb::SpeechLexiconType Flags/*[in,def,opt]*/, 
                                      long* GenerationId/*[out,def,opt]*/, 
                                      Speechlib_tlb::ISpeechLexiconWords** Words/*[out,retval]*/);
  Speechlib_tlb::ISpeechLexiconWords* __fastcall GetWords(Speechlib_tlb::SpeechLexiconType Flags/*[in,def,opt]*/, 
                                                          long* GenerationId/*[out,def,opt]*/);
  HRESULT         __fastcall AddPronunciation(BSTR bstrWord/*[in]*/, long LangId/*[in]*/, 
                                              Speechlib_tlb::SpeechPartOfSpeech PartOfSpeech/*[in,def,opt]*/
                                              , BSTR bstrPronunciation/*[in,def,opt]*/);
  HRESULT         __fastcall AddPronunciationByPhoneIds(BSTR bstrWord/*[in]*/, long LangId/*[in]*/, 
                                                        Speechlib_tlb::SpeechPartOfSpeech PartOfSpeech/*[in,def,opt]*/
                                                        , 
                                                        VARIANT* PhoneIds/*[in,def,opt]*/= TNoParam());
  HRESULT         __fastcall RemovePronunciation(BSTR bstrWord/*[in]*/, long LangId/*[in]*/, 
                                                 Speechlib_tlb::SpeechPartOfSpeech PartOfSpeech/*[in,def,opt]*/
                                                 , BSTR bstrPronunciation/*[in,def,opt]*/);
  HRESULT         __fastcall RemovePronunciationByPhoneIds(BSTR bstrWord/*[in]*/, 
                                                           long LangId/*[in]*/, 
                                                           Speechlib_tlb::SpeechPartOfSpeech PartOfSpeech/*[in,def,opt]*/
                                                           , 
                                                           VARIANT* PhoneIds/*[in,def,opt]*/= TNoParam());
  HRESULT         __fastcall GetPronunciations(BSTR bstrWord/*[in]*/, long LangId/*[in,def,opt]*/, 
                                               Speechlib_tlb::SpeechLexiconType TypeFlags/*[in,def,opt]*/
                                               , 
                                               Speechlib_tlb::ISpeechLexiconPronunciations** ppPronunciations/*[out,retval]*/);
  Speechlib_tlb::ISpeechLexiconPronunciations* __fastcall GetPronunciations(BSTR bstrWord/*[in]*/, 
                                                                            long LangId/*[in,def,opt]*/, 
                                                                            Speechlib_tlb::SpeechLexiconType TypeFlags/*[in,def,opt]*/);
  HRESULT         __fastcall GetGenerationChange(long* GenerationId/*[in,out]*/, 
                                                 Speechlib_tlb::ISpeechLexiconWords** ppWords/*[out,retval]*/);
  Speechlib_tlb::ISpeechLexiconWords* __fastcall GetGenerationChange(long* GenerationId/*[in,out]*/);

  __property   long            GenerationId = {read = get_GenerationId};
};
typedef ISpeechLexiconDispT<ISpeechLexicon> ISpeechLexiconDisp;

typedef TComInterface<ISpeechLexiconWords>  TCOMISpeechLexiconWords;

// *********************************************************************//
// DispIntf:  ISpeechLexiconWords
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {8D199862-415E-47D5-AC4F-FAA608B424E6}
// *********************************************************************//
template<class T>
class ISpeechLexiconWordsDispT : public TAutoDriver<ISpeechLexiconWords>
{
public:
  ISpeechLexiconWordsDispT(){}

  ISpeechLexiconWordsDispT(ISpeechLexiconWords *pintf)
  {
    TAutoDriver<ISpeechLexiconWords>::Bind(pintf, false);
  }

  ISpeechLexiconWordsDispT(ISpeechLexiconWordsPtr pintf)
  {
    TAutoDriver<ISpeechLexiconWords>::Bind(pintf, true);
  }

  ISpeechLexiconWordsDispT& operator=(ISpeechLexiconWords *pintf)
  {
    TAutoDriver<ISpeechLexiconWords>::Bind(pintf, false);
    return *this;
  }

  ISpeechLexiconWordsDispT& operator=(ISpeechLexiconWordsPtr pintf)
  {
    TAutoDriver<ISpeechLexiconWords>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_Count(long* Count/*[out,retval]*/);
  long            __fastcall get_Count(void);
  HRESULT         __fastcall Item(long Index/*[in]*/, 
                                  Speechlib_tlb::ISpeechLexiconWord** Word/*[out,retval]*/);
  Speechlib_tlb::ISpeechLexiconWord* __fastcall Item(long Index/*[in]*/);
  HRESULT         __fastcall get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/);
  LPUNKNOWN       __fastcall get__NewEnum(void);

  __property   long            Count = {read = get_Count};
  __property   LPUNKNOWN       _NewEnum = {read = get__NewEnum};
};
typedef ISpeechLexiconWordsDispT<ISpeechLexiconWords> ISpeechLexiconWordsDisp;

typedef TComInterface<ISpeechLexiconWord>  TCOMISpeechLexiconWord;

// *********************************************************************//
// DispIntf:  ISpeechLexiconWord
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {4E5B933C-C9BE-48ED-8842-1EE51BB1D4FF}
// *********************************************************************//
template<class T>
class ISpeechLexiconWordDispT : public TAutoDriver<ISpeechLexiconWord>
{
public:
  ISpeechLexiconWordDispT(){}

  ISpeechLexiconWordDispT(ISpeechLexiconWord *pintf)
  {
    TAutoDriver<ISpeechLexiconWord>::Bind(pintf, false);
  }

  ISpeechLexiconWordDispT(ISpeechLexiconWordPtr pintf)
  {
    TAutoDriver<ISpeechLexiconWord>::Bind(pintf, true);
  }

  ISpeechLexiconWordDispT& operator=(ISpeechLexiconWord *pintf)
  {
    TAutoDriver<ISpeechLexiconWord>::Bind(pintf, false);
    return *this;
  }

  ISpeechLexiconWordDispT& operator=(ISpeechLexiconWordPtr pintf)
  {
    TAutoDriver<ISpeechLexiconWord>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_LangId(long* LangId/*[out,retval]*/);
  long            __fastcall get_LangId(void);
  HRESULT         __fastcall get_Type(Speechlib_tlb::SpeechWordType* WordType/*[out,retval]*/);
  Speechlib_tlb::SpeechWordType __fastcall get_Type(void);
  HRESULT         __fastcall get_Word(BSTR* Word/*[out,retval]*/);
  BSTR            __fastcall get_Word(void);
  HRESULT         __fastcall get_Pronunciations(Speechlib_tlb::ISpeechLexiconPronunciations** Pronunciations/*[out,retval]*/);
  Speechlib_tlb::ISpeechLexiconPronunciationsPtr __fastcall get_Pronunciations(void);

  __property   long            LangId = {read = get_LangId};
  __property   Speechlib_tlb::SpeechWordType Type = {read = get_Type};
  __property   BSTR            Word = {read = get_Word};
  __property   Speechlib_tlb::ISpeechLexiconPronunciationsPtr Pronunciations = {read = get_Pronunciations};
};
typedef ISpeechLexiconWordDispT<ISpeechLexiconWord> ISpeechLexiconWordDisp;

typedef TComInterface<ISpeechLexiconPronunciations>  TCOMISpeechLexiconPronunciations;

// *********************************************************************//
// DispIntf:  ISpeechLexiconPronunciations
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {72829128-5682-4704-A0D4-3E2BB6F2EAD3}
// *********************************************************************//
template<class T>
class ISpeechLexiconPronunciationsDispT : public TAutoDriver<ISpeechLexiconPronunciations>
{
public:
  ISpeechLexiconPronunciationsDispT(){}

  ISpeechLexiconPronunciationsDispT(ISpeechLexiconPronunciations *pintf)
  {
    TAutoDriver<ISpeechLexiconPronunciations>::Bind(pintf, false);
  }

  ISpeechLexiconPronunciationsDispT(ISpeechLexiconPronunciationsPtr pintf)
  {
    TAutoDriver<ISpeechLexiconPronunciations>::Bind(pintf, true);
  }

  ISpeechLexiconPronunciationsDispT& operator=(ISpeechLexiconPronunciations *pintf)
  {
    TAutoDriver<ISpeechLexiconPronunciations>::Bind(pintf, false);
    return *this;
  }

  ISpeechLexiconPronunciationsDispT& operator=(ISpeechLexiconPronunciationsPtr pintf)
  {
    TAutoDriver<ISpeechLexiconPronunciations>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_Count(long* Count/*[out,retval]*/);
  long            __fastcall get_Count(void);
  HRESULT         __fastcall Item(long Index/*[in]*/, 
                                  Speechlib_tlb::ISpeechLexiconPronunciation** Pronunciation/*[out,retval]*/);
  Speechlib_tlb::ISpeechLexiconPronunciation* __fastcall Item(long Index/*[in]*/);
  HRESULT         __fastcall get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/);
  LPUNKNOWN       __fastcall get__NewEnum(void);

  __property   long            Count = {read = get_Count};
  __property   LPUNKNOWN       _NewEnum = {read = get__NewEnum};
};
typedef ISpeechLexiconPronunciationsDispT<ISpeechLexiconPronunciations> ISpeechLexiconPronunciationsDisp;

typedef TComInterface<ISpeechLexiconPronunciation>  TCOMISpeechLexiconPronunciation;

// *********************************************************************//
// DispIntf:  ISpeechLexiconPronunciation
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {95252C5D-9E43-4F4A-9899-48EE73352F9F}
// *********************************************************************//
template<class T>
class ISpeechLexiconPronunciationDispT : public TAutoDriver<ISpeechLexiconPronunciation>
{
public:
  ISpeechLexiconPronunciationDispT(){}

  ISpeechLexiconPronunciationDispT(ISpeechLexiconPronunciation *pintf)
  {
    TAutoDriver<ISpeechLexiconPronunciation>::Bind(pintf, false);
  }

  ISpeechLexiconPronunciationDispT(ISpeechLexiconPronunciationPtr pintf)
  {
    TAutoDriver<ISpeechLexiconPronunciation>::Bind(pintf, true);
  }

  ISpeechLexiconPronunciationDispT& operator=(ISpeechLexiconPronunciation *pintf)
  {
    TAutoDriver<ISpeechLexiconPronunciation>::Bind(pintf, false);
    return *this;
  }

  ISpeechLexiconPronunciationDispT& operator=(ISpeechLexiconPronunciationPtr pintf)
  {
    TAutoDriver<ISpeechLexiconPronunciation>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_Type(Speechlib_tlb::SpeechLexiconType* LexiconType/*[out,retval]*/);
  Speechlib_tlb::SpeechLexiconType __fastcall get_Type(void);
  HRESULT         __fastcall get_LangId(long* LangId/*[out,retval]*/);
  long            __fastcall get_LangId(void);
  HRESULT         __fastcall get_PartOfSpeech(Speechlib_tlb::SpeechPartOfSpeech* PartOfSpeech/*[out,retval]*/);
  Speechlib_tlb::SpeechPartOfSpeech __fastcall get_PartOfSpeech(void);
  HRESULT         __fastcall get_PhoneIds(VARIANT* PhoneIds/*[out,retval]*/);
  VARIANT         __fastcall get_PhoneIds(void);
  HRESULT         __fastcall get_Symbolic(BSTR* Symbolic/*[out,retval]*/);
  BSTR            __fastcall get_Symbolic(void);

  __property   Speechlib_tlb::SpeechLexiconType Type = {read = get_Type};
  __property   long            LangId = {read = get_LangId};
  __property   Speechlib_tlb::SpeechPartOfSpeech PartOfSpeech = {read = get_PartOfSpeech};
  __property   BSTR            Symbolic = {read = get_Symbolic};
};
typedef ISpeechLexiconPronunciationDispT<ISpeechLexiconPronunciation> ISpeechLexiconPronunciationDisp;

typedef TComInterface<ISpeechXMLRecoResult>  TCOMISpeechXMLRecoResult;

// *********************************************************************//
// DispIntf:  ISpeechXMLRecoResult
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {AAEC54AF-8F85-4924-944D-B79D39D72E19}
// *********************************************************************//
template<class T>
class ISpeechXMLRecoResultDispT : public TAutoDriver<ISpeechXMLRecoResult>
{
public:
  ISpeechXMLRecoResultDispT(){}

  ISpeechXMLRecoResultDispT(ISpeechXMLRecoResult *pintf)
  {
    TAutoDriver<ISpeechXMLRecoResult>::Bind(pintf, false);
  }

  ISpeechXMLRecoResultDispT(ISpeechXMLRecoResultPtr pintf)
  {
    TAutoDriver<ISpeechXMLRecoResult>::Bind(pintf, true);
  }

  ISpeechXMLRecoResultDispT& operator=(ISpeechXMLRecoResult *pintf)
  {
    TAutoDriver<ISpeechXMLRecoResult>::Bind(pintf, false);
    return *this;
  }

  ISpeechXMLRecoResultDispT& operator=(ISpeechXMLRecoResultPtr pintf)
  {
    TAutoDriver<ISpeechXMLRecoResult>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall GetXMLResult(Speechlib_tlb::SPXMLRESULTOPTIONS Options/*[in]*/, 
                                          BSTR* pResult/*[out,retval]*/);
  BSTR            __fastcall GetXMLResult(Speechlib_tlb::SPXMLRESULTOPTIONS Options/*[in]*/);
  HRESULT         __fastcall GetXMLErrorInfo(long* LineNumber/*[out]*/, BSTR* ScriptLine/*[out]*/, 
                                             BSTR* Source/*[out]*/, BSTR* Description/*[out]*/, 
                                             long* ResultCode/*[out]*/, 
                                             VARIANT_BOOL* IsError/*[out,retval]*/);
  VARIANT_BOOL    __fastcall GetXMLErrorInfo(long* LineNumber/*[out]*/, BSTR* ScriptLine/*[out]*/, 
                                             BSTR* Source/*[out]*/, BSTR* Description/*[out]*/, 
                                             long* ResultCode/*[out]*/);
  HRESULT         __fastcall get_RecoContext(Speechlib_tlb::ISpeechRecoContext** RecoContext/*[out,retval]*/);
  Speechlib_tlb::ISpeechRecoContextPtr __fastcall get_RecoContext(void);
  HRESULT         __fastcall get_Times(Speechlib_tlb::ISpeechRecoResultTimes** Times/*[out,retval]*/);
  Speechlib_tlb::ISpeechRecoResultTimesPtr __fastcall get_Times(void);
  HRESULT         __fastcall _set_AudioFormat(Speechlib_tlb::ISpeechAudioFormat* Format/*[in]*/);
  HRESULT         __fastcall get_AudioFormat(Speechlib_tlb::ISpeechAudioFormat** Format/*[out,retval]*/);
  Speechlib_tlb::ISpeechAudioFormatPtr __fastcall get_AudioFormat(void);
  HRESULT         __fastcall get_PhraseInfo(Speechlib_tlb::ISpeechPhraseInfo** PhraseInfo/*[out,retval]*/);
  Speechlib_tlb::ISpeechPhraseInfoPtr __fastcall get_PhraseInfo(void);
  HRESULT         __fastcall Alternates(long RequestCount/*[in]*/, long StartElement/*[in,def,opt]*/
                                        , long Elements/*[in,def,opt]*/, 
                                        Speechlib_tlb::ISpeechPhraseAlternates** Alternates/*[out,retval]*/);
  Speechlib_tlb::ISpeechPhraseAlternates* __fastcall Alternates(long RequestCount/*[in]*/, 
                                                                long StartElement/*[in,def,opt]*/, 
                                                                long Elements/*[in,def,opt]*/);
  HRESULT         __fastcall Audio(long StartElement/*[in,def,opt]*/, long Elements/*[in,def,opt]*/
                                   , Speechlib_tlb::ISpeechMemoryStream** Stream/*[out,retval]*/);
  Speechlib_tlb::ISpeechMemoryStream* __fastcall Audio(long StartElement/*[in,def,opt]*/, 
                                                       long Elements/*[in,def,opt]*/);
  HRESULT         __fastcall SpeakAudio(long StartElement/*[in,def,opt]*/, 
                                        long Elements/*[in,def,opt]*/, 
                                        Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/, 
                                        long* StreamNumber/*[out,retval]*/);
  long            __fastcall SpeakAudio(long StartElement/*[in,def,opt]*/, 
                                        long Elements/*[in,def,opt]*/, 
                                        Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/);
  HRESULT         __fastcall SaveToMemory(VARIANT* ResultBlock/*[out,retval]*/);
  VARIANT         __fastcall SaveToMemory(void);
  HRESULT         __fastcall DiscardResultInfo(Speechlib_tlb::SpeechDiscardType ValueTypes/*[in]*/);


  __property   Speechlib_tlb::ISpeechRecoContextPtr RecoContext = {read = get_RecoContext};
  __property   Speechlib_tlb::ISpeechRecoResultTimesPtr Times = {read = get_Times};
  __property   Speechlib_tlb::ISpeechAudioFormat* AudioFormat = {write = _set_AudioFormat};
  __property   Speechlib_tlb::ISpeechPhraseInfoPtr PhraseInfo = {read = get_PhraseInfo};
};
typedef ISpeechXMLRecoResultDispT<ISpeechXMLRecoResult> ISpeechXMLRecoResultDisp;

typedef TComInterface<ISpeechRecoResultDispatch>  TCOMISpeechRecoResultDispatch;

// *********************************************************************//
// DispIntf:  ISpeechRecoResultDispatch
// Flags:     (4432) Hidden Dual OleAutomation Dispatchable
// GUID:      {6D60EB64-ACED-40A6-BBF3-4E557F71DEE2}
// *********************************************************************//
template<class T>
class ISpeechRecoResultDispatchDispT : public TAutoDriver<ISpeechRecoResultDispatch>
{
public:
  ISpeechRecoResultDispatchDispT(){}

  ISpeechRecoResultDispatchDispT(ISpeechRecoResultDispatch *pintf)
  {
    TAutoDriver<ISpeechRecoResultDispatch>::Bind(pintf, false);
  }

  ISpeechRecoResultDispatchDispT(ISpeechRecoResultDispatchPtr pintf)
  {
    TAutoDriver<ISpeechRecoResultDispatch>::Bind(pintf, true);
  }

  ISpeechRecoResultDispatchDispT& operator=(ISpeechRecoResultDispatch *pintf)
  {
    TAutoDriver<ISpeechRecoResultDispatch>::Bind(pintf, false);
    return *this;
  }

  ISpeechRecoResultDispatchDispT& operator=(ISpeechRecoResultDispatchPtr pintf)
  {
    TAutoDriver<ISpeechRecoResultDispatch>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall get_RecoContext(Speechlib_tlb::ISpeechRecoContext** RecoContext/*[out,retval]*/);
  Speechlib_tlb::ISpeechRecoContextPtr __fastcall get_RecoContext(void);
  HRESULT         __fastcall get_Times(Speechlib_tlb::ISpeechRecoResultTimes** Times/*[out,retval]*/);
  Speechlib_tlb::ISpeechRecoResultTimesPtr __fastcall get_Times(void);
  HRESULT         __fastcall _set_AudioFormat(Speechlib_tlb::ISpeechAudioFormat* Format/*[in]*/);
  HRESULT         __fastcall get_AudioFormat(Speechlib_tlb::ISpeechAudioFormat** Format/*[out,retval]*/);
  Speechlib_tlb::ISpeechAudioFormatPtr __fastcall get_AudioFormat(void);
  HRESULT         __fastcall get_PhraseInfo(Speechlib_tlb::ISpeechPhraseInfo** PhraseInfo/*[out,retval]*/);
  Speechlib_tlb::ISpeechPhraseInfoPtr __fastcall get_PhraseInfo(void);
  HRESULT         __fastcall Alternates(long RequestCount/*[in]*/, long StartElement/*[in,def,opt]*/
                                        , long Elements/*[in,def,opt]*/, 
                                        Speechlib_tlb::ISpeechPhraseAlternates** Alternates/*[out,retval]*/);
  Speechlib_tlb::ISpeechPhraseAlternates* __fastcall Alternates(long RequestCount/*[in]*/, 
                                                                long StartElement/*[in,def,opt]*/, 
                                                                long Elements/*[in,def,opt]*/);
  HRESULT         __fastcall Audio(long StartElement/*[in,def,opt]*/, long Elements/*[in,def,opt]*/
                                   , Speechlib_tlb::ISpeechMemoryStream** Stream/*[out,retval]*/);
  Speechlib_tlb::ISpeechMemoryStream* __fastcall Audio(long StartElement/*[in,def,opt]*/, 
                                                       long Elements/*[in,def,opt]*/);
  HRESULT         __fastcall SpeakAudio(long StartElement/*[in,def,opt]*/, 
                                        long Elements/*[in,def,opt]*/, 
                                        Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/, 
                                        long* StreamNumber/*[out,retval]*/);
  long            __fastcall SpeakAudio(long StartElement/*[in,def,opt]*/, 
                                        long Elements/*[in,def,opt]*/, 
                                        Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/);
  HRESULT         __fastcall SaveToMemory(VARIANT* ResultBlock/*[out,retval]*/);
  VARIANT         __fastcall SaveToMemory(void);
  HRESULT         __fastcall DiscardResultInfo(Speechlib_tlb::SpeechDiscardType ValueTypes/*[in]*/);
  HRESULT         __fastcall GetXMLResult(Speechlib_tlb::SPXMLRESULTOPTIONS Options/*[in]*/, 
                                          BSTR* pResult/*[out,retval]*/);
  BSTR            __fastcall GetXMLResult(Speechlib_tlb::SPXMLRESULTOPTIONS Options/*[in]*/);
  HRESULT         __fastcall GetXMLErrorInfo(long* LineNumber/*[out]*/, BSTR* ScriptLine/*[out]*/, 
                                             BSTR* Source/*[out]*/, BSTR* Description/*[out]*/, 
                                             HRESULT* ResultCode/*[out]*/, 
                                             VARIANT_BOOL* IsError/*[out,retval]*/);
  VARIANT_BOOL    __fastcall GetXMLErrorInfo(long* LineNumber/*[out]*/, BSTR* ScriptLine/*[out]*/, 
                                             BSTR* Source/*[out]*/, BSTR* Description/*[out]*/, 
                                             HRESULT* ResultCode/*[out]*/);
  HRESULT         __fastcall SetTextFeedback(BSTR Feedback/*[in]*/, 
                                             VARIANT_BOOL WasSuccessful/*[in]*/);

  __property   Speechlib_tlb::ISpeechRecoContextPtr RecoContext = {read = get_RecoContext};
  __property   Speechlib_tlb::ISpeechRecoResultTimesPtr Times = {read = get_Times};
  __property   Speechlib_tlb::ISpeechAudioFormat* AudioFormat = {write = _set_AudioFormat};
  __property   Speechlib_tlb::ISpeechPhraseInfoPtr PhraseInfo = {read = get_PhraseInfo};
};
typedef ISpeechRecoResultDispatchDispT<ISpeechRecoResultDispatch> ISpeechRecoResultDispatchDisp;

// *********************************************************************//
// SmartIntf: TCOMISpeechPhraseInfoBuilder
// Interface: ISpeechPhraseInfoBuilder
// *********************************************************************//
template <class T /* ISpeechPhraseInfoBuilder */ >
class TCOMISpeechPhraseInfoBuilderT : public TComInterface<ISpeechPhraseInfoBuilder>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMISpeechPhraseInfoBuilderT() {}
  TCOMISpeechPhraseInfoBuilderT(ISpeechPhraseInfoBuilder *intf, bool addRef = false) : TComInterface<ISpeechPhraseInfoBuilder>(intf, addRef) {}
  TCOMISpeechPhraseInfoBuilderT(const TCOMISpeechPhraseInfoBuilderT& src) : TComInterface<ISpeechPhraseInfoBuilder>(src) {}
  TCOMISpeechPhraseInfoBuilderT& operator=(const TCOMISpeechPhraseInfoBuilderT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall RestorePhraseFromMemory(VARIANT* PhraseInMemory/*[in]*/, 
                                                     Speechlib_tlb::ISpeechPhraseInfo** PhraseInfo/*[out,retval]*/);
  Speechlib_tlb::ISpeechPhraseInfo* __fastcall RestorePhraseFromMemory(VARIANT* PhraseInMemory/*[in]*/);

};
typedef TCOMISpeechPhraseInfoBuilderT<ISpeechPhraseInfoBuilder> TCOMISpeechPhraseInfoBuilder;

// *********************************************************************//
// DispIntf:  ISpeechPhraseInfoBuilder
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {3B151836-DF3A-4E0A-846C-D2ADC9334333}
// *********************************************************************//
template<class T>
class ISpeechPhraseInfoBuilderDispT : public TAutoDriver<ISpeechPhraseInfoBuilder>
{
public:
  ISpeechPhraseInfoBuilderDispT(){}

  ISpeechPhraseInfoBuilderDispT(ISpeechPhraseInfoBuilder *pintf)
  {
    TAutoDriver<ISpeechPhraseInfoBuilder>::Bind(pintf, false);
  }

  ISpeechPhraseInfoBuilderDispT(ISpeechPhraseInfoBuilderPtr pintf)
  {
    TAutoDriver<ISpeechPhraseInfoBuilder>::Bind(pintf, true);
  }

  ISpeechPhraseInfoBuilderDispT& operator=(ISpeechPhraseInfoBuilder *pintf)
  {
    TAutoDriver<ISpeechPhraseInfoBuilder>::Bind(pintf, false);
    return *this;
  }

  ISpeechPhraseInfoBuilderDispT& operator=(ISpeechPhraseInfoBuilderPtr pintf)
  {
    TAutoDriver<ISpeechPhraseInfoBuilder>::Bind(pintf, true);
    return *this;
  }

  HRESULT BindDefault()
  {
    return OLECHECK(Bind(CLSID_SpPhraseInfoBuilder));
  }

  HRESULT BindRunning()
  {
    return BindToActive(CLSID_SpPhraseInfoBuilder);
  }

  HRESULT         __fastcall RestorePhraseFromMemory(VARIANT* PhraseInMemory/*[in]*/, 
                                                     Speechlib_tlb::ISpeechPhraseInfo** PhraseInfo/*[out,retval]*/);
  Speechlib_tlb::ISpeechPhraseInfo* __fastcall RestorePhraseFromMemory(VARIANT* PhraseInMemory/*[in]*/);

};
typedef ISpeechPhraseInfoBuilderDispT<ISpeechPhraseInfoBuilder> ISpeechPhraseInfoBuilderDisp;

// *********************************************************************//
// SmartIntf: TCOMISpeechPhoneConverter
// Interface: ISpeechPhoneConverter
// *********************************************************************//
template <class T /* ISpeechPhoneConverter */ >
class TCOMISpeechPhoneConverterT : public TComInterface<ISpeechPhoneConverter>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMISpeechPhoneConverterT() {}
  TCOMISpeechPhoneConverterT(ISpeechPhoneConverter *intf, bool addRef = false) : TComInterface<ISpeechPhoneConverter>(intf, addRef) {}
  TCOMISpeechPhoneConverterT(const TCOMISpeechPhoneConverterT& src) : TComInterface<ISpeechPhoneConverter>(src) {}
  TCOMISpeechPhoneConverterT& operator=(const TCOMISpeechPhoneConverterT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall get_LanguageId(long* LanguageId/*[out,retval]*/);
  long            __fastcall get_LanguageId(void);
  HRESULT         __fastcall set_LanguageId(long LanguageId/*[in]*/);
  HRESULT         __fastcall PhoneToId(BSTR Phonemes/*[in]*/, VARIANT* IdArray/*[out,retval]*/);
  VARIANT         __fastcall PhoneToId(BSTR Phonemes/*[in]*/);
  HRESULT         __fastcall IdToPhone(VARIANT IdArray/*[in]*/, BSTR* Phonemes/*[out,retval]*/);
  BSTR            __fastcall IdToPhone(VARIANT IdArray/*[in]*/);

  __property   long            LanguageId = {read = get_LanguageId, write = set_LanguageId};
};
typedef TCOMISpeechPhoneConverterT<ISpeechPhoneConverter> TCOMISpeechPhoneConverter;

// *********************************************************************//
// DispIntf:  ISpeechPhoneConverter
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {C3E4F353-433F-43D6-89A1-6A62A7054C3D}
// *********************************************************************//
template<class T>
class ISpeechPhoneConverterDispT : public TAutoDriver<ISpeechPhoneConverter>
{
public:
  ISpeechPhoneConverterDispT(){}

  ISpeechPhoneConverterDispT(ISpeechPhoneConverter *pintf)
  {
    TAutoDriver<ISpeechPhoneConverter>::Bind(pintf, false);
  }

  ISpeechPhoneConverterDispT(ISpeechPhoneConverterPtr pintf)
  {
    TAutoDriver<ISpeechPhoneConverter>::Bind(pintf, true);
  }

  ISpeechPhoneConverterDispT& operator=(ISpeechPhoneConverter *pintf)
  {
    TAutoDriver<ISpeechPhoneConverter>::Bind(pintf, false);
    return *this;
  }

  ISpeechPhoneConverterDispT& operator=(ISpeechPhoneConverterPtr pintf)
  {
    TAutoDriver<ISpeechPhoneConverter>::Bind(pintf, true);
    return *this;
  }

  HRESULT BindDefault()
  {
    return OLECHECK(Bind(CLSID_SpPhoneConverter));
  }

  HRESULT BindRunning()
  {
    return BindToActive(CLSID_SpPhoneConverter);
  }

  HRESULT         __fastcall get_LanguageId(long* LanguageId/*[out,retval]*/);
  long            __fastcall get_LanguageId(void);
  HRESULT         __fastcall set_LanguageId(long LanguageId/*[in]*/);
  HRESULT         __fastcall PhoneToId(BSTR Phonemes/*[in]*/, VARIANT* IdArray/*[out,retval]*/);
  VARIANT         __fastcall PhoneToId(BSTR Phonemes/*[in]*/);
  HRESULT         __fastcall IdToPhone(VARIANT IdArray/*[in]*/, BSTR* Phonemes/*[out,retval]*/);
  BSTR            __fastcall IdToPhone(VARIANT IdArray/*[in]*/);

  __property   long            LanguageId = {read = get_LanguageId, write = set_LanguageId};
};
typedef ISpeechPhoneConverterDispT<ISpeechPhoneConverter> ISpeechPhoneConverterDisp;

typedef TComInterface<ISpNotifySink>  TCOMISpNotifySink;

// *********************************************************************//
// SmartIntf: TCOMISpNotifyTranslator
// Interface: ISpNotifyTranslator
// *********************************************************************//
template <class T /* ISpNotifyTranslator */ >
class TCOMISpNotifyTranslatorT : public TComInterface<ISpNotifyTranslator>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMISpNotifyTranslatorT() {}
  TCOMISpNotifyTranslatorT(ISpNotifyTranslator *intf, bool addRef = false) : TComInterface<ISpNotifyTranslator>(intf, addRef) {}
  TCOMISpNotifyTranslatorT(const TCOMISpNotifyTranslatorT& src) : TComInterface<ISpNotifyTranslator>(src) {}
  TCOMISpNotifyTranslatorT& operator=(const TCOMISpNotifyTranslatorT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall InitWindowMessage(Speechlib_tlb::wireHWND hWnd/*[in]*/, 
                                               unsigned Msg/*[in]*/, 
                                               Speechlib_tlb::UINT_PTR wParam/*[in]*/, 
                                               Speechlib_tlb::LONG_PTR lParam/*[in]*/);
  HRESULT         __fastcall InitCallback(void** pfnCallback/*[in]*/, 
                                          Speechlib_tlb::UINT_PTR wParam/*[in]*/, 
                                          Speechlib_tlb::LONG_PTR lParam/*[in]*/);
  HRESULT         __fastcall InitSpNotifyCallback(void** pSpCallback/*[in]*/, 
                                                  Speechlib_tlb::UINT_PTR wParam/*[in]*/, 
                                                  Speechlib_tlb::LONG_PTR lParam/*[in]*/);
  HRESULT         __fastcall InitWin32Event(void* hEvent/*[in]*/, long fCloseHandleOnRelease/*[in]*/);
  HRESULT         __fastcall Wait(unsigned_long dwMilliseconds/*[in]*/);
  void*           __fastcall GetEventHandle(void);

};
typedef TCOMISpNotifyTranslatorT<ISpNotifyTranslator> TCOMISpNotifyTranslator;

typedef TComInterface<ISpDataKey>  TCOMISpDataKey;

typedef TComInterface<ISpObjectTokenCategory>  TCOMISpObjectTokenCategory;

// *********************************************************************//
// SmartIntf: TCOMIEnumSpObjectTokens
// Interface: IEnumSpObjectTokens
// *********************************************************************//
template <class T /* IEnumSpObjectTokens */ >
class TCOMIEnumSpObjectTokensT : public TComInterface<IEnumSpObjectTokens>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMIEnumSpObjectTokensT() {}
  TCOMIEnumSpObjectTokensT(IEnumSpObjectTokens *intf, bool addRef = false) : TComInterface<IEnumSpObjectTokens>(intf, addRef) {}
  TCOMIEnumSpObjectTokensT(const TCOMIEnumSpObjectTokensT& src) : TComInterface<IEnumSpObjectTokens>(src) {}
  TCOMIEnumSpObjectTokensT& operator=(const TCOMIEnumSpObjectTokensT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall Next(unsigned_long celt/*[in]*/, 
                                  Speechlib_tlb::ISpObjectToken** pelt/*[out]*/, 
                                  unsigned_long* pceltFetched/*[out]*/);
  HRESULT         __fastcall Skip(unsigned_long celt/*[in]*/);
  HRESULT         __fastcall Reset(void);
  HRESULT         __fastcall Clone(Speechlib_tlb::IEnumSpObjectTokens** ppEnum/*[out]*/);
  HRESULT         __fastcall Item(unsigned_long Index/*[in]*/, 
                                  Speechlib_tlb::ISpObjectToken** ppToken/*[out]*/);
  HRESULT         __fastcall GetCount(unsigned_long* pCount/*[out]*/);

};
typedef TCOMIEnumSpObjectTokensT<IEnumSpObjectTokens> TCOMIEnumSpObjectTokens;

typedef TComInterface<ISpObjectToken>  TCOMISpObjectToken;

typedef TComInterface<IServiceProvider>  TCOMIServiceProvider;

// *********************************************************************//
// SmartIntf: TCOMISpResourceManager
// Interface: ISpResourceManager
// *********************************************************************//
template <class T /* ISpResourceManager */ >
class TCOMISpResourceManagerT : public TComInterface<ISpResourceManager>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMISpResourceManagerT() {}
  TCOMISpResourceManagerT(ISpResourceManager *intf, bool addRef = false) : TComInterface<ISpResourceManager>(intf, addRef) {}
  TCOMISpResourceManagerT(const TCOMISpResourceManagerT& src) : TComInterface<ISpResourceManager>(src) {}
  TCOMISpResourceManagerT& operator=(const TCOMISpResourceManagerT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall SetObject(System::TGUID* guidServiceId/*[in]*/, 
                                       LPUNKNOWN punkObject/*[in]*/);
  HRESULT         __fastcall GetObject(System::TGUID* guidServiceId/*[in]*/, 
                                       System::TGUID* ObjectCLSID/*[in]*/, 
                                       System::TGUID* ObjectIID/*[in]*/, 
                                       long fReleaseWhenLastExternalRefReleased/*[in]*/, 
                                       void** ppObject/*[out]*/);

};
typedef TCOMISpResourceManagerT<ISpResourceManager> TCOMISpResourceManager;

typedef TComInterface<ISequentialStream>  TCOMISequentialStream;

typedef TComInterface<IStream>  TCOMIStream;

typedef TComInterface<ISpStreamFormat>  TCOMISpStreamFormat;

// *********************************************************************//
// SmartIntf: TCOMISpStreamFormatConverter
// Interface: ISpStreamFormatConverter
// *********************************************************************//
template <class T /* ISpStreamFormatConverter */ >
class TCOMISpStreamFormatConverterT : public TComInterface<ISpStreamFormatConverter>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMISpStreamFormatConverterT() {}
  TCOMISpStreamFormatConverterT(ISpStreamFormatConverter *intf, bool addRef = false) : TComInterface<ISpStreamFormatConverter>(intf, addRef) {}
  TCOMISpStreamFormatConverterT(const TCOMISpStreamFormatConverterT& src) : TComInterface<ISpStreamFormatConverter>(src) {}
  TCOMISpStreamFormatConverterT& operator=(const TCOMISpStreamFormatConverterT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall SetBaseStream(Speechlib_tlb::ISpStreamFormat* pStream/*[in]*/, 
                                           long fSetFormatToBaseStreamFormat/*[in]*/, 
                                           long fWriteToBaseStream/*[in]*/);
  HRESULT         __fastcall GetBaseStream(Speechlib_tlb::ISpStreamFormat** ppStream/*[out]*/);
  HRESULT         __fastcall SetFormat(System::TGUID* rguidFormatIdOfConvertedStream/*[in]*/, 
                                       Speechlib_tlb::WAVEFORMATEX* pWaveFormatExOfConvertedStream/*[in]*/);
  HRESULT         __fastcall ResetSeekPosition(void);
  HRESULT         __fastcall ScaleConvertedToBaseOffset(unsigned_int64 ullOffsetConvertedStream/*[in]*/, 
                                                        unsigned_int64* pullOffsetBaseStream/*[out]*/);
  HRESULT         __fastcall ScaleBaseToConvertedOffset(unsigned_int64 ullOffsetBaseStream/*[in]*/, 
                                                        unsigned_int64* pullOffsetConvertedStream/*[out]*/);

};
typedef TCOMISpStreamFormatConverterT<ISpStreamFormatConverter> TCOMISpStreamFormatConverter;

typedef TComInterface<ISpNotifySource>  TCOMISpNotifySource;

typedef TComInterface<ISpEventSource>  TCOMISpEventSource;

typedef TComInterface<ISpEventSink>  TCOMISpEventSink;

typedef TComInterface<ISpObjectWithToken>  TCOMISpObjectWithToken;

typedef TComInterface<ISpAudio>  TCOMISpAudio;

typedef TComInterface<ISpMMSysAudio>  TCOMISpMMSysAudio;

// *********************************************************************//
// SmartIntf: TCOMISpStream
// Interface: ISpStream
// *********************************************************************//
template <class T /* ISpStream */ >
class TCOMISpStreamT : public TComInterface<ISpStream>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMISpStreamT() {}
  TCOMISpStreamT(ISpStream *intf, bool addRef = false) : TComInterface<ISpStream>(intf, addRef) {}
  TCOMISpStreamT(const TCOMISpStreamT& src) : TComInterface<ISpStream>(src) {}
  TCOMISpStreamT& operator=(const TCOMISpStreamT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall SetBaseStream(Speechlib_tlb::IStream* pStream/*[in]*/, 
                                           System::TGUID* rguidFormat/*[in]*/, 
                                           Speechlib_tlb::WAVEFORMATEX* pWaveFormatEx/*[in]*/);
  HRESULT         __fastcall GetBaseStream(Speechlib_tlb::IStream** ppStream/*[out]*/);
  HRESULT         __fastcall BindToFile(LPWSTR pszFileName/*[in]*/, 
                                        Speechlib_tlb::SPFILEMODE eMode/*[in]*/, 
                                        System::TGUID* pFormatId/*[in]*/, 
                                        Speechlib_tlb::WAVEFORMATEX* pWaveFormatEx, 
                                        unsigned_int64 ullEventInterest/*[in]*/);
  HRESULT         __fastcall Close(void);

};
typedef TCOMISpStreamT<ISpStream> TCOMISpStream;

typedef TComInterface<ISpVoice>  TCOMISpVoice;

typedef TComInterface<ISpPhoneticAlphabetSelection>  TCOMISpPhoneticAlphabetSelection;

typedef TComInterface<ISpRecoContext>  TCOMISpRecoContext;

typedef TComInterface<ISpRecoContext2>  TCOMISpRecoContext2;

typedef TComInterface<ISpProperties>  TCOMISpProperties;

typedef TComInterface<ISpRecognizer>  TCOMISpRecognizer;

typedef TComInterface<ISpPhrase>  TCOMISpPhrase;

typedef TComInterface<ISpGrammarBuilder>  TCOMISpGrammarBuilder;

typedef TComInterface<ISpRecoGrammar>  TCOMISpRecoGrammar;

typedef TComInterface<ISpRecoResult>  TCOMISpRecoResult;

typedef TComInterface<ISpPhraseAlt>  TCOMISpPhraseAlt;

typedef TComInterface<ISpRecognizer2>  TCOMISpRecognizer2;

typedef TComInterface<ISpRecognizer3>  TCOMISpRecognizer3;

typedef TComInterface<ISpSerializeState>  TCOMISpSerializeState;

typedef TComInterface<ISpRecoCategory>  TCOMISpRecoCategory;

// *********************************************************************//
// SmartIntf: TCOMISpLexicon
// Interface: ISpLexicon
// *********************************************************************//
template <class T /* ISpLexicon */ >
class TCOMISpLexiconT : public TComInterface<ISpLexicon>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMISpLexiconT() {}
  TCOMISpLexiconT(ISpLexicon *intf, bool addRef = false) : TComInterface<ISpLexicon>(intf, addRef) {}
  TCOMISpLexiconT(const TCOMISpLexiconT& src) : TComInterface<ISpLexicon>(src) {}
  TCOMISpLexiconT& operator=(const TCOMISpLexiconT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall GetPronunciations(LPWSTR pszWord/*[in]*/, unsigned_short LangId/*[in]*/, 
                                               unsigned_long dwFlags/*[in]*/, 
                                               Speechlib_tlb::SPWORDPRONUNCIATIONLIST* pWordPronunciationList/*[in,out]*/);
  HRESULT         __fastcall AddPronunciation(LPWSTR pszWord/*[in]*/, unsigned_short LangId/*[in]*/, 
                                              Speechlib_tlb::SPPARTOFSPEECH ePartOfSpeech/*[in]*/, 
                                              LPWSTR pszPronunciation/*[in]*/);
  HRESULT         __fastcall RemovePronunciation(LPWSTR pszWord/*[in]*/, 
                                                 unsigned_short LangId/*[in]*/, 
                                                 Speechlib_tlb::SPPARTOFSPEECH ePartOfSpeech/*[in]*/, 
                                                 LPWSTR pszPronunciation/*[in]*/);
  HRESULT         __fastcall GetGeneration(unsigned_long* pdwGeneration/*[out]*/);
  HRESULT         __fastcall GetGenerationChange(unsigned_long dwFlags/*[in]*/, 
                                                 unsigned_long* pdwGeneration/*[in,out]*/, 
                                                 Speechlib_tlb::SPWORDLIST* pWordList/*[in,out]*/);
  HRESULT         __fastcall GetWords(unsigned_long dwFlags/*[in]*/, 
                                      unsigned_long* pdwGeneration/*[in,out]*/, 
                                      unsigned_long* pdwCookie/*[in,out]*/, 
                                      Speechlib_tlb::SPWORDLIST* pWordList/*[in,out]*/);

};
typedef TCOMISpLexiconT<ISpLexicon> TCOMISpLexicon;

// *********************************************************************//
// SmartIntf: TCOMISpShortcut
// Interface: ISpShortcut
// *********************************************************************//
template <class T /* ISpShortcut */ >
class TCOMISpShortcutT : public TComInterface<ISpShortcut>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMISpShortcutT() {}
  TCOMISpShortcutT(ISpShortcut *intf, bool addRef = false) : TComInterface<ISpShortcut>(intf, addRef) {}
  TCOMISpShortcutT(const TCOMISpShortcutT& src) : TComInterface<ISpShortcut>(src) {}
  TCOMISpShortcutT& operator=(const TCOMISpShortcutT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall AddShortcut(LPWSTR pszDisplay/*[in]*/, unsigned_short LangId/*[in]*/, 
                                         LPWSTR pszSpoken/*[in]*/, 
                                         Speechlib_tlb::SPSHORTCUTTYPE shType/*[in]*/);
  HRESULT         __fastcall RemoveShortcut(LPWSTR pszDisplay/*[in]*/, unsigned_short LangId/*[in]*/, 
                                            LPWSTR pszSpoken/*[in]*/, 
                                            Speechlib_tlb::SPSHORTCUTTYPE shType/*[in]*/);
  HRESULT         __fastcall GetShortcuts(unsigned_short LangId/*[in]*/, 
                                          Speechlib_tlb::SPSHORTCUTPAIRLIST* pShortcutpairList/*[in,out]*/);
  HRESULT         __fastcall GetGeneration(unsigned_long* pdwGeneration/*[out]*/);
  HRESULT         __fastcall GetWordsFromGenerationChange(unsigned_long* pdwGeneration/*[in,out]*/, 
                                                          Speechlib_tlb::SPWORDLIST* pWordList/*[in,out]*/);
  HRESULT         __fastcall GetWords(unsigned_long* pdwGeneration/*[in,out]*/, 
                                      unsigned_long* pdwCookie/*[in,out]*/, 
                                      Speechlib_tlb::SPWORDLIST* pWordList/*[in,out]*/);
  HRESULT         __fastcall GetShortcutsForGeneration(unsigned_long* pdwGeneration/*[in,out]*/, 
                                                       unsigned_long* pdwCookie/*[in,out]*/, 
                                                       Speechlib_tlb::SPSHORTCUTPAIRLIST* pShortcutpairList/*[in,out]*/);
  HRESULT         __fastcall GetGenerationChange(unsigned_long* pdwGeneration/*[in,out]*/, 
                                                 Speechlib_tlb::SPSHORTCUTPAIRLIST* pShortcutpairList/*[in,out]*/);

};
typedef TCOMISpShortcutT<ISpShortcut> TCOMISpShortcut;

// *********************************************************************//
// SmartIntf: TCOMISpPhoneConverter
// Interface: ISpPhoneConverter
// *********************************************************************//
template <class T /* ISpPhoneConverter */ >
class TCOMISpPhoneConverterT : public TComInterface<ISpPhoneConverter>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMISpPhoneConverterT() {}
  TCOMISpPhoneConverterT(ISpPhoneConverter *intf, bool addRef = false) : TComInterface<ISpPhoneConverter>(intf, addRef) {}
  TCOMISpPhoneConverterT(const TCOMISpPhoneConverterT& src) : TComInterface<ISpPhoneConverter>(src) {}
  TCOMISpPhoneConverterT& operator=(const TCOMISpPhoneConverterT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall PhoneToId(LPWSTR pszPhone/*[in]*/, unsigned_short* pId/*[out]*/);
  HRESULT         __fastcall IdToPhone(LPWSTR pId/*[in]*/, unsigned_short* pszPhone/*[out]*/);

};
typedef TCOMISpPhoneConverterT<ISpPhoneConverter> TCOMISpPhoneConverter;

// *********************************************************************//
// SmartIntf: TCOMISpPhoneticAlphabetConverter
// Interface: ISpPhoneticAlphabetConverter
// *********************************************************************//
template <class T /* ISpPhoneticAlphabetConverter */ >
class TCOMISpPhoneticAlphabetConverterT : public TComInterface<ISpPhoneticAlphabetConverter>, public TComInterfaceBase<IUnknown>
{
public:
  TCOMISpPhoneticAlphabetConverterT() {}
  TCOMISpPhoneticAlphabetConverterT(ISpPhoneticAlphabetConverter *intf, bool addRef = false) : TComInterface<ISpPhoneticAlphabetConverter>(intf, addRef) {}
  TCOMISpPhoneticAlphabetConverterT(const TCOMISpPhoneticAlphabetConverterT& src) : TComInterface<ISpPhoneticAlphabetConverter>(src) {}
  TCOMISpPhoneticAlphabetConverterT& operator=(const TCOMISpPhoneticAlphabetConverterT& src) { Bind(src, true); return *this;}

  HRESULT         __fastcall GetLangId(unsigned_short* pLangID/*[out]*/);
  HRESULT         __fastcall SetLangId(unsigned_short LangId/*[in]*/);
  HRESULT         __fastcall SAPI2UPS(unsigned_short* pszSAPIId/*[in]*/, 
                                      unsigned_short* pszUPSId/*[out]*/, 
                                      unsigned_long cMaxLength/*[in]*/);
  HRESULT         __fastcall UPS2SAPI(unsigned_short* pszUPSId/*[in]*/, 
                                      unsigned_short* pszSAPIId/*[out]*/, 
                                      unsigned_long cMaxLength/*[in]*/);
  HRESULT         __fastcall GetMaxConvertLength(unsigned_long cSrcLength/*[in]*/, 
                                                 long bSAPI2UPS/*[in]*/, 
                                                 unsigned_long* pcMaxDestLength/*[out]*/);

};
typedef TCOMISpPhoneticAlphabetConverterT<ISpPhoneticAlphabetConverter> TCOMISpPhoneticAlphabetConverter;

typedef TComInterface<ISpXMLRecoResult>  TCOMISpXMLRecoResult;

typedef TComInterface<ISpRecoGrammar2>  TCOMISpRecoGrammar2;

typedef TComInterface<ISpeechResourceLoader>  TCOMISpeechResourceLoader;

// *********************************************************************//
// DispIntf:  ISpeechResourceLoader
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {B9AC5783-FCD0-4B21-B119-B4F8DA8FD2C3}
// *********************************************************************//
template<class T>
class ISpeechResourceLoaderDispT : public TAutoDriver<ISpeechResourceLoader>
{
public:
  ISpeechResourceLoaderDispT(){}

  ISpeechResourceLoaderDispT(ISpeechResourceLoader *pintf)
  {
    TAutoDriver<ISpeechResourceLoader>::Bind(pintf, false);
  }

  ISpeechResourceLoaderDispT(ISpeechResourceLoaderPtr pintf)
  {
    TAutoDriver<ISpeechResourceLoader>::Bind(pintf, true);
  }

  ISpeechResourceLoaderDispT& operator=(ISpeechResourceLoader *pintf)
  {
    TAutoDriver<ISpeechResourceLoader>::Bind(pintf, false);
    return *this;
  }

  ISpeechResourceLoaderDispT& operator=(ISpeechResourceLoaderPtr pintf)
  {
    TAutoDriver<ISpeechResourceLoader>::Bind(pintf, true);
    return *this;
  }

  HRESULT         __fastcall LoadResource(BSTR bstrResourceUri/*[in]*/, 
                                          VARIANT_BOOL fAlwaysReload/*[in]*/, 
                                          LPUNKNOWN* pStream/*[out]*/, BSTR* pbstrMIMEType/*[out]*/
                                          , VARIANT_BOOL* pfModified/*[out]*/, 
                                          BSTR* pbstrRedirectUrl/*[out]*/);
  HRESULT         __fastcall GetLocalCopy(BSTR bstrResourceUri/*[in]*/, 
                                          BSTR* pbstrLocalPath/*[out]*/, 
                                          BSTR* pbstrMIMEType/*[out]*/, 
                                          BSTR* pbstrRedirectUrl/*[out]*/);
  HRESULT         __fastcall ReleaseLocalCopy(BSTR pbstrLocalPath/*[in]*/);

};
typedef ISpeechResourceLoaderDispT<ISpeechResourceLoader> ISpeechResourceLoaderDisp;

typedef TComInterface<IInternetSecurityManager>  TCOMIInternetSecurityManager;

typedef TComInterface<IInternetSecurityMgrSite>  TCOMIInternetSecurityMgrSite;

typedef TComInterface<IEnumString>  TCOMIEnumString;

// *********************************************************************//
// DispIntf:  ISpeechDataKey
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {CE17C09B-4EFA-44D5-A4C9-59D9585AB0CD}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechDataKeyDispT<T>::SetBinaryValue(BSTR ValueName/*[in]*/, VARIANT Value/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("SetBinaryValue"), DISPID(1));
  TAutoArgs<2> _args;
  _args[1] = ValueName /*[VT_BSTR:0]*/;
  _args[2] = Value /*[VT_VARIANT:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechDataKeyDispT<T>::GetBinaryValue(BSTR ValueName/*[in]*/, VARIANT* Value/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetBinaryValue"), DISPID(2));
  TAutoArgs<1> _args;
  _args[1] = ValueName /*[VT_BSTR:0]*/;
  return OutRetValSetterPtr(Value /*[VT_VARIANT:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechDataKeyDispT<T>::GetBinaryValue(BSTR ValueName/*[in]*/)
{
  VARIANT Value;
  this->GetBinaryValue(ValueName, (VARIANT*)&Value);
  return Value;
}

template <class T> HRESULT __fastcall
ISpeechDataKeyDispT<T>::SetStringValue(BSTR ValueName/*[in]*/, BSTR Value/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("SetStringValue"), DISPID(3));
  TAutoArgs<2> _args;
  _args[1] = ValueName /*[VT_BSTR:0]*/;
  _args[2] = Value /*[VT_BSTR:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechDataKeyDispT<T>::GetStringValue(BSTR ValueName/*[in]*/, BSTR* Value/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetStringValue"), DISPID(4));
  TAutoArgs<1> _args;
  _args[1] = ValueName /*[VT_BSTR:0]*/;
  return OutRetValSetterPtr(Value /*[VT_BSTR:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechDataKeyDispT<T>::GetStringValue(BSTR ValueName/*[in]*/)
{
  BSTR Value;
  this->GetStringValue(ValueName, (BSTR*)&Value);
  return Value;
}

template <class T> HRESULT __fastcall
ISpeechDataKeyDispT<T>::SetLongValue(BSTR ValueName/*[in]*/, long Value/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("SetLongValue"), DISPID(5));
  TAutoArgs<2> _args;
  _args[1] = ValueName /*[VT_BSTR:0]*/;
  _args[2] = Value /*[VT_I4:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechDataKeyDispT<T>::GetLongValue(BSTR ValueName/*[in]*/, long* Value/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetLongValue"), DISPID(6));
  TAutoArgs<1> _args;
  _args[1] = ValueName /*[VT_BSTR:0]*/;
  return OutRetValSetterPtr(Value /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
ISpeechDataKeyDispT<T>::GetLongValue(BSTR ValueName/*[in]*/)
{
  long Value;
  this->GetLongValue(ValueName, (long*)&Value);
  return Value;
}

template <class T> HRESULT __fastcall
ISpeechDataKeyDispT<T>::OpenKey(BSTR SubKeyName/*[in]*/, 
                                Speechlib_tlb::ISpeechDataKey** SubKey/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("OpenKey"), DISPID(7));
  TAutoArgs<1> _args;
  _args[1] = SubKeyName /*[VT_BSTR:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechDataKey**)SubKey /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechDataKey* __fastcall
ISpeechDataKeyDispT<T>::OpenKey(BSTR SubKeyName/*[in]*/)
{
  Speechlib_tlb::ISpeechDataKey* SubKey;
  this->OpenKey(SubKeyName, (Speechlib_tlb::ISpeechDataKey**)&SubKey);
  return SubKey;
}

template <class T> HRESULT __fastcall
ISpeechDataKeyDispT<T>::CreateKey(BSTR SubKeyName/*[in]*/, 
                                  Speechlib_tlb::ISpeechDataKey** SubKey/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("CreateKey"), DISPID(8));
  TAutoArgs<1> _args;
  _args[1] = SubKeyName /*[VT_BSTR:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechDataKey**)SubKey /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechDataKey* __fastcall
ISpeechDataKeyDispT<T>::CreateKey(BSTR SubKeyName/*[in]*/)
{
  Speechlib_tlb::ISpeechDataKey* SubKey;
  this->CreateKey(SubKeyName, (Speechlib_tlb::ISpeechDataKey**)&SubKey);
  return SubKey;
}

template <class T> HRESULT __fastcall
ISpeechDataKeyDispT<T>::DeleteKey(BSTR SubKeyName/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("DeleteKey"), DISPID(9));
  TAutoArgs<1> _args;
  _args[1] = SubKeyName /*[VT_BSTR:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechDataKeyDispT<T>::DeleteValue(BSTR ValueName/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("DeleteValue"), DISPID(10));
  TAutoArgs<1> _args;
  _args[1] = ValueName /*[VT_BSTR:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechDataKeyDispT<T>::EnumKeys(long Index/*[in]*/, BSTR* SubKeyName/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("EnumKeys"), DISPID(11));
  TAutoArgs<1> _args;
  _args[1] = Index /*[VT_I4:0]*/;
  return OutRetValSetterPtr(SubKeyName /*[VT_BSTR:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechDataKeyDispT<T>::EnumKeys(long Index/*[in]*/)
{
  BSTR SubKeyName;
  this->EnumKeys(Index, (BSTR*)&SubKeyName);
  return SubKeyName;
}

template <class T> HRESULT __fastcall
ISpeechDataKeyDispT<T>::EnumValues(long Index/*[in]*/, BSTR* ValueName/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("EnumValues"), DISPID(12));
  TAutoArgs<1> _args;
  _args[1] = Index /*[VT_I4:0]*/;
  return OutRetValSetterPtr(ValueName /*[VT_BSTR:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechDataKeyDispT<T>::EnumValues(long Index/*[in]*/)
{
  BSTR ValueName;
  this->EnumValues(Index, (BSTR*)&ValueName);
  return ValueName;
}

// *********************************************************************//
// SmartIntf: TCOMISpeechObjectToken
// Interface: ISpeechObjectToken
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMISpeechObjectTokenT<T>::get_Id(BSTR* ObjectId/*[out,retval]*/)
{
  return (*this)->get_Id(ObjectId);
}

template <class T> BSTR __fastcall
TCOMISpeechObjectTokenT<T>::get_Id(void)
{
  BSTR ObjectId = 0;
  OLECHECK(this->get_Id((BSTR*)&ObjectId));
  return ObjectId;
}

template <class T> HRESULT __fastcall
TCOMISpeechObjectTokenT<T>::get_DataKey(Speechlib_tlb::ISpeechDataKey** DataKey/*[out,retval]*/)
{
  return (*this)->get_DataKey(DataKey);
}

template <class T> Speechlib_tlb::ISpeechDataKeyPtr __fastcall
TCOMISpeechObjectTokenT<T>::get_DataKey(void)
{
  Speechlib_tlb::ISpeechDataKeyPtr DataKey;
  OLECHECK(this->get_DataKey((Speechlib_tlb::ISpeechDataKeyPtr*)&DataKey));
  return DataKey;
}

template <class T> HRESULT __fastcall
TCOMISpeechObjectTokenT<T>::get_Category(Speechlib_tlb::ISpeechObjectTokenCategory** Category/*[out,retval]*/)
{
  return (*this)->get_Category(Category);
}

template <class T> Speechlib_tlb::ISpeechObjectTokenCategoryPtr __fastcall
TCOMISpeechObjectTokenT<T>::get_Category(void)
{
  Speechlib_tlb::ISpeechObjectTokenCategoryPtr Category;
  OLECHECK(this->get_Category((Speechlib_tlb::ISpeechObjectTokenCategoryPtr*)&Category));
  return Category;
}

template <class T> HRESULT __fastcall
TCOMISpeechObjectTokenT<T>::GetDescription(long Locale/*[in,def,opt]*/, 
                                           BSTR* Description/*[out,retval]*/)
{
  return (*this)->GetDescription(Locale, Description);
}

template <class T> BSTR __fastcall
TCOMISpeechObjectTokenT<T>::GetDescription(long Locale/*[in,def,opt]*/)
{
  BSTR Description = 0;
  OLECHECK(this->GetDescription(Locale/*[in,def,opt]*/, (BSTR*)&Description));
  return Description;
}

template <class T> HRESULT __fastcall
TCOMISpeechObjectTokenT<T>::SetId(BSTR Id/*[in]*/, BSTR CategoryID/*[in,def,opt]*/, 
                                  VARIANT_BOOL CreateIfNotExist/*[in,def,opt]*/)
{
  return (*this)->SetId(Id, CategoryID, CreateIfNotExist);
}

template <class T> HRESULT __fastcall
TCOMISpeechObjectTokenT<T>::GetAttribute(BSTR AttributeName/*[in]*/, 
                                         BSTR* AttributeValue/*[out,retval]*/)
{
  return (*this)->GetAttribute(AttributeName, AttributeValue);
}

template <class T> BSTR __fastcall
TCOMISpeechObjectTokenT<T>::GetAttribute(BSTR AttributeName/*[in]*/)
{
  BSTR AttributeValue = 0;
  OLECHECK(this->GetAttribute(AttributeName/*[in]*/, (BSTR*)&AttributeValue));
  return AttributeValue;
}

template <class T> HRESULT __fastcall
TCOMISpeechObjectTokenT<T>::CreateInstance(LPUNKNOWN pUnkOuter/*[in,def,opt]*/, 
                                           Speechlib_tlb::SpeechTokenContext ClsContext/*[in,def,opt]*/, 
                                           LPUNKNOWN* Object/*[out,retval]*/)
{
  return (*this)->CreateInstance(pUnkOuter, ClsContext, Object);
}

template <class T> LPUNKNOWN __fastcall
TCOMISpeechObjectTokenT<T>::CreateInstance(LPUNKNOWN pUnkOuter/*[in,def,opt]*/, 
                                           Speechlib_tlb::SpeechTokenContext ClsContext/*[in,def,opt]*/)
{
  LPUNKNOWN Object;
  OLECHECK(this->CreateInstance(pUnkOuter/*[in,def,opt]*/, ClsContext/*[in,def,opt]*/, (LPUNKNOWN*)&Object));
  return Object;
}

template <class T> HRESULT __fastcall
TCOMISpeechObjectTokenT<T>::Remove(BSTR ObjectStorageCLSID/*[in]*/)
{
  return (*this)->Remove(ObjectStorageCLSID);
}

template <class T> HRESULT __fastcall
TCOMISpeechObjectTokenT<T>::GetStorageFileName(BSTR ObjectStorageCLSID/*[in]*/, BSTR KeyName/*[in]*/, 
                                               BSTR FileName/*[in]*/, 
                                               Speechlib_tlb::SpeechTokenShellFolder Folder/*[in]*/, 
                                               BSTR* FilePath/*[out,retval]*/)
{
  return (*this)->GetStorageFileName(ObjectStorageCLSID, KeyName, FileName, Folder, FilePath);
}

template <class T> BSTR __fastcall
TCOMISpeechObjectTokenT<T>::GetStorageFileName(BSTR ObjectStorageCLSID/*[in]*/, BSTR KeyName/*[in]*/, 
                                               BSTR FileName/*[in]*/, 
                                               Speechlib_tlb::SpeechTokenShellFolder Folder/*[in]*/)
{
  BSTR FilePath = 0;
  OLECHECK(this->GetStorageFileName(ObjectStorageCLSID/*[in]*/, KeyName/*[in]*/, FileName/*[in]*/, 
                                    Folder/*[in]*/, (BSTR*)&FilePath));
  return FilePath;
}

template <class T> HRESULT __fastcall
TCOMISpeechObjectTokenT<T>::RemoveStorageFileName(BSTR ObjectStorageCLSID/*[in]*/, 
                                                  BSTR KeyName/*[in]*/, 
                                                  VARIANT_BOOL DeleteFile/*[in]*/)
{
  return (*this)->RemoveStorageFileName(ObjectStorageCLSID, KeyName, DeleteFile);
}

template <class T> HRESULT __fastcall
TCOMISpeechObjectTokenT<T>::IsUISupported(BSTR TypeOfUI/*[in]*/, VARIANT* ExtraData/*[in,def,opt]*/, 
                                          LPUNKNOWN Object/*[in,def,opt]*/, 
                                          VARIANT_BOOL* Supported/*[out,retval]*/)
{
  return (*this)->IsUISupported(TypeOfUI, ExtraData, Object, Supported);
}

template <class T> VARIANT_BOOL __fastcall
TCOMISpeechObjectTokenT<T>::IsUISupported(BSTR TypeOfUI/*[in]*/, VARIANT* ExtraData/*[in,def,opt]*/, 
                                          LPUNKNOWN Object/*[in,def,opt]*/)
{
  VARIANT_BOOL Supported;
  OLECHECK(this->IsUISupported(TypeOfUI/*[in]*/, ExtraData/*[in,def,opt]*/, Object/*[in,def,opt]*/, (VARIANT_BOOL*)&Supported));
  return Supported;
}

template <class T> HRESULT __fastcall
TCOMISpeechObjectTokenT<T>::DisplayUI(long hWnd/*[in]*/, BSTR Title/*[in]*/, BSTR TypeOfUI/*[in]*/, 
                                      VARIANT* ExtraData/*[in,def,opt]*/, 
                                      LPUNKNOWN Object/*[in,def,opt]*/)
{
  return (*this)->DisplayUI(hWnd, Title, TypeOfUI, ExtraData, Object);
}

template <class T> HRESULT __fastcall
TCOMISpeechObjectTokenT<T>::MatchesAttributes(BSTR Attributes/*[in]*/, 
                                              VARIANT_BOOL* Matches/*[out,retval]*/)
{
  return (*this)->MatchesAttributes(Attributes, Matches);
}

template <class T> VARIANT_BOOL __fastcall
TCOMISpeechObjectTokenT<T>::MatchesAttributes(BSTR Attributes/*[in]*/)
{
  VARIANT_BOOL Matches;
  OLECHECK(this->MatchesAttributes(Attributes/*[in]*/, (VARIANT_BOOL*)&Matches));
  return Matches;
}

// *********************************************************************//
// DispIntf:  ISpeechObjectToken
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {C74A3ADC-B727-4500-A84A-B526721C8B8C}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechObjectTokenDispT<T>::get_Id(BSTR* ObjectId/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Id"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(ObjectId /*[VT_BSTR:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechObjectTokenDispT<T>::get_Id(void)
{
  BSTR ObjectId;
  this->get_Id((BSTR*)&ObjectId);
  return ObjectId;
}

template <class T> HRESULT __fastcall
ISpeechObjectTokenDispT<T>::get_DataKey(Speechlib_tlb::ISpeechDataKey** DataKey/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("DataKey"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechDataKey**)DataKey /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechDataKeyPtr __fastcall
ISpeechObjectTokenDispT<T>::get_DataKey(void)
{
  Speechlib_tlb::ISpeechDataKeyPtr DataKey;
  this->get_DataKey(&DataKey);
  return DataKey;
}

template <class T> HRESULT __fastcall
ISpeechObjectTokenDispT<T>::get_Category(Speechlib_tlb::ISpeechObjectTokenCategory** Category/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Category"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechObjectTokenCategory**)Category /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechObjectTokenCategoryPtr __fastcall
ISpeechObjectTokenDispT<T>::get_Category(void)
{
  Speechlib_tlb::ISpeechObjectTokenCategoryPtr Category;
  this->get_Category(&Category);
  return Category;
}

template <class T> HRESULT __fastcall
ISpeechObjectTokenDispT<T>::GetDescription(long Locale/*[in,def,opt]*/, 
                                           BSTR* Description/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetDescription"), DISPID(4));
  TAutoArgs<1> _args;
  _args[1] = Locale /*[VT_I4:0]*/;
  return OutRetValSetterPtr(Description /*[VT_BSTR:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechObjectTokenDispT<T>::GetDescription(long Locale/*[in,def,opt]*/)
{
  BSTR Description;
  this->GetDescription(Locale, (BSTR*)&Description);
  return Description;
}

template <class T> HRESULT __fastcall
ISpeechObjectTokenDispT<T>::SetId(BSTR Id/*[in]*/, BSTR CategoryID/*[in,def,opt]*/, 
                                  VARIANT_BOOL CreateIfNotExist/*[in,def,opt]*/)
{
  _TDispID _dispid(*this, OLETEXT("SetId"), DISPID(5));
  TAutoArgs<3> _args;
  _args[1] = Id /*[VT_BSTR:0]*/;
  _args[2] = CategoryID /*[VT_BSTR:0]*/;
  _args[3] = CreateIfNotExist /*[VT_BOOL:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechObjectTokenDispT<T>::GetAttribute(BSTR AttributeName/*[in]*/, 
                                         BSTR* AttributeValue/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetAttribute"), DISPID(6));
  TAutoArgs<1> _args;
  _args[1] = AttributeName /*[VT_BSTR:0]*/;
  return OutRetValSetterPtr(AttributeValue /*[VT_BSTR:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechObjectTokenDispT<T>::GetAttribute(BSTR AttributeName/*[in]*/)
{
  BSTR AttributeValue;
  this->GetAttribute(AttributeName, (BSTR*)&AttributeValue);
  return AttributeValue;
}

template <class T> HRESULT __fastcall
ISpeechObjectTokenDispT<T>::CreateInstance(LPUNKNOWN pUnkOuter/*[in,def,opt]*/, 
                                           Speechlib_tlb::SpeechTokenContext ClsContext/*[in,def,opt]*/
                                           , LPUNKNOWN* Object/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("CreateInstance"), DISPID(7));
  TAutoArgs<2> _args;
  _args[1] = pUnkOuter /*[VT_UNKNOWN:0]*/;
  _args[2] = (int)ClsContext /*[VT_USERDEFINED:0]*/;
  return OutRetValSetterPtr(Object /*[VT_UNKNOWN:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> LPUNKNOWN __fastcall
ISpeechObjectTokenDispT<T>::CreateInstance(LPUNKNOWN pUnkOuter/*[in,def,opt]*/, 
                                           Speechlib_tlb::SpeechTokenContext ClsContext/*[in,def,opt]*/)
{
  LPUNKNOWN Object;
  this->CreateInstance(pUnkOuter, ClsContext, (LPUNKNOWN*)&Object);
  return Object;
}

template <class T> HRESULT __fastcall
ISpeechObjectTokenDispT<T>::Remove(BSTR ObjectStorageCLSID/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Remove"), DISPID(8));
  TAutoArgs<1> _args;
  _args[1] = ObjectStorageCLSID /*[VT_BSTR:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechObjectTokenDispT<T>::GetStorageFileName(BSTR ObjectStorageCLSID/*[in]*/, BSTR KeyName/*[in]*/
                                               , BSTR FileName/*[in]*/, 
                                               Speechlib_tlb::SpeechTokenShellFolder Folder/*[in]*/
                                               , BSTR* FilePath/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetStorageFileName"), DISPID(9));
  TAutoArgs<4> _args;
  _args[1] = ObjectStorageCLSID /*[VT_BSTR:0]*/;
  _args[2] = KeyName /*[VT_BSTR:0]*/;
  _args[3] = FileName /*[VT_BSTR:0]*/;
  _args[4] = (int)Folder /*[VT_USERDEFINED:0]*/;
  return OutRetValSetterPtr(FilePath /*[VT_BSTR:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechObjectTokenDispT<T>::GetStorageFileName(BSTR ObjectStorageCLSID/*[in]*/, BSTR KeyName/*[in]*/, 
                                               BSTR FileName/*[in]*/, 
                                               Speechlib_tlb::SpeechTokenShellFolder Folder/*[in]*/)
{
  BSTR FilePath;
  this->GetStorageFileName(ObjectStorageCLSID, KeyName, FileName, Folder, (BSTR*)&FilePath);
  return FilePath;
}

template <class T> HRESULT __fastcall
ISpeechObjectTokenDispT<T>::RemoveStorageFileName(BSTR ObjectStorageCLSID/*[in]*/, 
                                                  BSTR KeyName/*[in]*/, 
                                                  VARIANT_BOOL DeleteFile/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("RemoveStorageFileName"), DISPID(10));
  TAutoArgs<3> _args;
  _args[1] = ObjectStorageCLSID /*[VT_BSTR:0]*/;
  _args[2] = KeyName /*[VT_BSTR:0]*/;
  _args[3] = DeleteFile /*[VT_BOOL:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechObjectTokenDispT<T>::IsUISupported(BSTR TypeOfUI/*[in]*/, VARIANT* ExtraData/*[in,def,opt]*/
                                          , LPUNKNOWN Object/*[in,def,opt]*/, 
                                          VARIANT_BOOL* Supported/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("IsUISupported"), DISPID(11));
  TAutoArgs<3> _args;
  _args[1] = TypeOfUI /*[VT_BSTR:0]*/;
  _args[2] = ExtraData /*[VT_VARIANT:1]*/;
  _args[3] = Object /*[VT_UNKNOWN:0]*/;
  return OutRetValSetterPtr(Supported /*[VT_BOOL:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
ISpeechObjectTokenDispT<T>::IsUISupported(BSTR TypeOfUI/*[in]*/, VARIANT* ExtraData/*[in,def,opt]*/, 
                                          LPUNKNOWN Object/*[in,def,opt]*/)
{
  VARIANT_BOOL Supported;
  this->IsUISupported(TypeOfUI, ExtraData, Object, (VARIANT_BOOL*)&Supported);
  return Supported;
}

template <class T> HRESULT __fastcall
ISpeechObjectTokenDispT<T>::DisplayUI(long hWnd/*[in]*/, BSTR Title/*[in]*/, BSTR TypeOfUI/*[in]*/, 
                                      VARIANT* ExtraData/*[in,def,opt]*/, 
                                      LPUNKNOWN Object/*[in,def,opt]*/)
{
  _TDispID _dispid(*this, OLETEXT("DisplayUI"), DISPID(12));
  TAutoArgs<5> _args;
  _args[1] = hWnd /*[VT_I4:0]*/;
  _args[2] = Title /*[VT_BSTR:0]*/;
  _args[3] = TypeOfUI /*[VT_BSTR:0]*/;
  _args[4] = ExtraData /*[VT_VARIANT:1]*/;
  _args[5] = Object /*[VT_UNKNOWN:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechObjectTokenDispT<T>::MatchesAttributes(BSTR Attributes/*[in]*/, 
                                              VARIANT_BOOL* Matches/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("MatchesAttributes"), DISPID(13));
  TAutoArgs<1> _args;
  _args[1] = Attributes /*[VT_BSTR:0]*/;
  return OutRetValSetterPtr(Matches /*[VT_BOOL:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
ISpeechObjectTokenDispT<T>::MatchesAttributes(BSTR Attributes/*[in]*/)
{
  VARIANT_BOOL Matches;
  this->MatchesAttributes(Attributes, (VARIANT_BOOL*)&Matches);
  return Matches;
}

// *********************************************************************//
// SmartIntf: TCOMISpeechObjectTokenCategory
// Interface: ISpeechObjectTokenCategory
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMISpeechObjectTokenCategoryT<T>::get_Id(BSTR* Id/*[out,retval]*/)
{
  return (*this)->get_Id(Id);
}

template <class T> BSTR __fastcall
TCOMISpeechObjectTokenCategoryT<T>::get_Id(void)
{
  BSTR Id = 0;
  OLECHECK(this->get_Id((BSTR*)&Id));
  return Id;
}

template <class T> HRESULT __fastcall
TCOMISpeechObjectTokenCategoryT<T>::set_Default(BSTR TokenId/*[in]*/)
{
  return (*this)->set_Default(TokenId);
}

template <class T> HRESULT __fastcall
TCOMISpeechObjectTokenCategoryT<T>::get_Default(BSTR* TokenId/*[out,retval]*/)
{
  return (*this)->get_Default(TokenId);
}

template <class T> BSTR __fastcall
TCOMISpeechObjectTokenCategoryT<T>::get_Default(void)
{
  BSTR TokenId = 0;
  OLECHECK(this->get_Default((BSTR*)&TokenId));
  return TokenId;
}

template <class T> HRESULT __fastcall
TCOMISpeechObjectTokenCategoryT<T>::SetId(BSTR Id/*[in]*/, 
                                          VARIANT_BOOL CreateIfNotExist/*[in,def,opt]*/)
{
  return (*this)->SetId(Id, CreateIfNotExist);
}

template <class T> HRESULT __fastcall
TCOMISpeechObjectTokenCategoryT<T>::GetDataKey(Speechlib_tlb::SpeechDataKeyLocation Location/*[in,def,opt]*/, 
                                               Speechlib_tlb::ISpeechDataKey** DataKey/*[out,retval]*/)
{
  return (*this)->GetDataKey(Location, DataKey);
}

template <class T> Speechlib_tlb::ISpeechDataKey* __fastcall
TCOMISpeechObjectTokenCategoryT<T>::GetDataKey(Speechlib_tlb::SpeechDataKeyLocation Location/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechDataKey* DataKey;
  OLECHECK(this->GetDataKey(Location/*[in,def,opt]*/, (Speechlib_tlb::ISpeechDataKey**)&DataKey));
  return DataKey;
}

template <class T> HRESULT __fastcall
TCOMISpeechObjectTokenCategoryT<T>::EnumerateTokens(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                    BSTR OptionalAttributes/*[in,def,opt]*/, 
                                                    Speechlib_tlb::ISpeechObjectTokens** Tokens/*[out,retval]*/)
{
  return (*this)->EnumerateTokens(RequiredAttributes, OptionalAttributes, Tokens);
}

template <class T> Speechlib_tlb::ISpeechObjectTokens* __fastcall
TCOMISpeechObjectTokenCategoryT<T>::EnumerateTokens(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                    BSTR OptionalAttributes/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechObjectTokens* Tokens;
  OLECHECK(this->EnumerateTokens(RequiredAttributes/*[in,def,opt]*/, 
                                 OptionalAttributes/*[in,def,opt]*/, (Speechlib_tlb::ISpeechObjectTokens**)&Tokens));
  return Tokens;
}

// *********************************************************************//
// DispIntf:  ISpeechObjectTokenCategory
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {CA7EAC50-2D01-4145-86D4-5AE7D70F4469}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechObjectTokenCategoryDispT<T>::get_Id(BSTR* Id/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Id"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Id /*[VT_BSTR:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechObjectTokenCategoryDispT<T>::get_Id(void)
{
  BSTR Id;
  this->get_Id((BSTR*)&Id);
  return Id;
}

template <class T> HRESULT __fastcall
ISpeechObjectTokenCategoryDispT<T>::set_Default(BSTR TokenId/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Default"), DISPID(2));
  TAutoArgs<1> _args;
  _args[1] = TokenId /*[VT_BSTR:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechObjectTokenCategoryDispT<T>::get_Default(BSTR* TokenId/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Default"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(TokenId /*[VT_BSTR:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechObjectTokenCategoryDispT<T>::get_Default(void)
{
  BSTR TokenId;
  this->get_Default((BSTR*)&TokenId);
  return TokenId;
}

template <class T> HRESULT __fastcall
ISpeechObjectTokenCategoryDispT<T>::SetId(BSTR Id/*[in]*/, 
                                          VARIANT_BOOL CreateIfNotExist/*[in,def,opt]*/)
{
  _TDispID _dispid(*this, OLETEXT("SetId"), DISPID(3));
  TAutoArgs<2> _args;
  _args[1] = Id /*[VT_BSTR:0]*/;
  _args[2] = CreateIfNotExist /*[VT_BOOL:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechObjectTokenCategoryDispT<T>::GetDataKey(Speechlib_tlb::SpeechDataKeyLocation Location/*[in,def,opt]*/
                                               , 
                                               Speechlib_tlb::ISpeechDataKey** DataKey/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetDataKey"), DISPID(4));
  TAutoArgs<1> _args;
  _args[1] = (int)Location /*[VT_USERDEFINED:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechDataKey**)DataKey /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechDataKey* __fastcall
ISpeechObjectTokenCategoryDispT<T>::GetDataKey(Speechlib_tlb::SpeechDataKeyLocation Location/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechDataKey* DataKey;
  this->GetDataKey(Location, (Speechlib_tlb::ISpeechDataKey**)&DataKey);
  return DataKey;
}

template <class T> HRESULT __fastcall
ISpeechObjectTokenCategoryDispT<T>::EnumerateTokens(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                    BSTR OptionalAttributes/*[in,def,opt]*/, 
                                                    Speechlib_tlb::ISpeechObjectTokens** Tokens/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("EnumerateTokens"), DISPID(5));
  TAutoArgs<2> _args;
  _args[1] = RequiredAttributes /*[VT_BSTR:0]*/;
  _args[2] = OptionalAttributes /*[VT_BSTR:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechObjectTokens**)Tokens /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechObjectTokens* __fastcall
ISpeechObjectTokenCategoryDispT<T>::EnumerateTokens(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                                    BSTR OptionalAttributes/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechObjectTokens* Tokens;
  this->EnumerateTokens(RequiredAttributes, OptionalAttributes, (Speechlib_tlb::ISpeechObjectTokens**)&Tokens);
  return Tokens;
}

// *********************************************************************//
// DispIntf:  ISpeechObjectTokens
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {9285B776-2E7B-4BC0-B53E-580EB6FA967F}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechObjectTokensDispT<T>::get_Count(long* Count/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Count"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Count /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechObjectTokensDispT<T>::get_Count(void)
{
  long Count;
  this->get_Count((long*)&Count);
  return Count;
}

template <class T> HRESULT __fastcall
ISpeechObjectTokensDispT<T>::Item(long Index/*[in]*/, 
                                  Speechlib_tlb::ISpeechObjectToken** Token/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Item"), DISPID(0));
  TAutoArgs<1> _args;
  _args[1] = Index /*[VT_I4:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechObjectToken**)Token /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechObjectToken* __fastcall
ISpeechObjectTokensDispT<T>::Item(long Index/*[in]*/)
{
  Speechlib_tlb::ISpeechObjectToken* Token;
  this->Item(Index, (Speechlib_tlb::ISpeechObjectToken**)&Token);
  return Token;
}

template <class T> HRESULT __fastcall
ISpeechObjectTokensDispT<T>::get__NewEnum(LPUNKNOWN* ppEnumVARIANT/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("_NewEnum"), DISPID(-4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(ppEnumVARIANT /*[VT_UNKNOWN:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> LPUNKNOWN __fastcall
ISpeechObjectTokensDispT<T>::get__NewEnum(void)
{
  LPUNKNOWN ppEnumVARIANT;
  this->get__NewEnum((LPUNKNOWN*)&ppEnumVARIANT);
  return ppEnumVARIANT;
}

// *********************************************************************//
// DispIntf:  ISpeechAudioBufferInfo
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {11B103D8-1142-4EDF-A093-82FB3915F8CC}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechAudioBufferInfoDispT<T>::get_MinNotification(long* MinNotification/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("MinNotification"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(MinNotification /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechAudioBufferInfoDispT<T>::get_MinNotification(void)
{
  long MinNotification;
  this->get_MinNotification((long*)&MinNotification);
  return MinNotification;
}

template <class T> HRESULT __fastcall
ISpeechAudioBufferInfoDispT<T>::set_MinNotification(long MinNotification/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("MinNotification"), DISPID(1));
  TAutoArgs<1> _args;
  _args[1] = MinNotification /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechAudioBufferInfoDispT<T>::get_BufferSize(long* BufferSize/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("BufferSize"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(BufferSize /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechAudioBufferInfoDispT<T>::get_BufferSize(void)
{
  long BufferSize;
  this->get_BufferSize((long*)&BufferSize);
  return BufferSize;
}

template <class T> HRESULT __fastcall
ISpeechAudioBufferInfoDispT<T>::set_BufferSize(long BufferSize/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("BufferSize"), DISPID(2));
  TAutoArgs<1> _args;
  _args[1] = BufferSize /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechAudioBufferInfoDispT<T>::get_EventBias(long* EventBias/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("EventBias"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(EventBias /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechAudioBufferInfoDispT<T>::get_EventBias(void)
{
  long EventBias;
  this->get_EventBias((long*)&EventBias);
  return EventBias;
}

template <class T> HRESULT __fastcall
ISpeechAudioBufferInfoDispT<T>::set_EventBias(long EventBias/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("EventBias"), DISPID(3));
  TAutoArgs<1> _args;
  _args[1] = EventBias /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

// *********************************************************************//
// DispIntf:  ISpeechAudioStatus
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {C62D9C91-7458-47F6-862D-1EF86FB0B278}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechAudioStatusDispT<T>::get_FreeBufferSpace(long* FreeBufferSpace/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("FreeBufferSpace"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(FreeBufferSpace /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechAudioStatusDispT<T>::get_FreeBufferSpace(void)
{
  long FreeBufferSpace;
  this->get_FreeBufferSpace((long*)&FreeBufferSpace);
  return FreeBufferSpace;
}

template <class T> HRESULT __fastcall
ISpeechAudioStatusDispT<T>::get_NonBlockingIO(long* NonBlockingIO/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("NonBlockingIO"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(NonBlockingIO /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechAudioStatusDispT<T>::get_NonBlockingIO(void)
{
  long NonBlockingIO;
  this->get_NonBlockingIO((long*)&NonBlockingIO);
  return NonBlockingIO;
}

template <class T> HRESULT __fastcall
ISpeechAudioStatusDispT<T>::get_State(Speechlib_tlb::SpeechAudioState* State/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("State"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)State /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechAudioState __fastcall
ISpeechAudioStatusDispT<T>::get_State(void)
{
  Speechlib_tlb::SpeechAudioState State;
  this->get_State((Speechlib_tlb::SpeechAudioState*)&State);
  return State;
}

template <class T> HRESULT __fastcall
ISpeechAudioStatusDispT<T>::get_CurrentSeekPosition(VARIANT* CurrentSeekPosition/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("CurrentSeekPosition"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(CurrentSeekPosition /*[VT_VARIANT:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechAudioStatusDispT<T>::get_CurrentSeekPosition(void)
{
  VARIANT CurrentSeekPosition;
  this->get_CurrentSeekPosition((VARIANT*)&CurrentSeekPosition);
  return CurrentSeekPosition;
}

template <class T> HRESULT __fastcall
ISpeechAudioStatusDispT<T>::get_CurrentDevicePosition(VARIANT* CurrentDevicePosition/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("CurrentDevicePosition"), DISPID(5));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(CurrentDevicePosition /*[VT_VARIANT:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechAudioStatusDispT<T>::get_CurrentDevicePosition(void)
{
  VARIANT CurrentDevicePosition;
  this->get_CurrentDevicePosition((VARIANT*)&CurrentDevicePosition);
  return CurrentDevicePosition;
}

// *********************************************************************//
// SmartIntf: TCOMISpeechAudioFormat
// Interface: ISpeechAudioFormat
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMISpeechAudioFormatT<T>::get_Type(Speechlib_tlb::SpeechAudioFormatType* AudioFormat/*[out,retval]*/)
{
  return (*this)->get_Type(AudioFormat);
}

template <class T> Speechlib_tlb::SpeechAudioFormatType __fastcall
TCOMISpeechAudioFormatT<T>::get_Type(void)
{
  Speechlib_tlb::SpeechAudioFormatType AudioFormat;
  OLECHECK(this->get_Type((Speechlib_tlb::SpeechAudioFormatType*)&AudioFormat));
  return AudioFormat;
}

template <class T> HRESULT __fastcall
TCOMISpeechAudioFormatT<T>::set_Type(Speechlib_tlb::SpeechAudioFormatType AudioFormat/*[in]*/)
{
  return (*this)->set_Type(AudioFormat);
}

template <class T> HRESULT __fastcall
TCOMISpeechAudioFormatT<T>::get_Guid(BSTR* Guid/*[out,retval]*/)
{
  return (*this)->get_Guid(Guid);
}

template <class T> BSTR __fastcall
TCOMISpeechAudioFormatT<T>::get_Guid(void)
{
  BSTR Guid = 0;
  OLECHECK(this->get_Guid((BSTR*)&Guid));
  return Guid;
}

template <class T> HRESULT __fastcall
TCOMISpeechAudioFormatT<T>::set_Guid(BSTR Guid/*[in]*/)
{
  return (*this)->set_Guid(Guid);
}

template <class T> HRESULT __fastcall
TCOMISpeechAudioFormatT<T>::GetWaveFormatEx(Speechlib_tlb::ISpeechWaveFormatEx** SpeechWaveFormatEx/*[out,retval]*/)
{
  return (*this)->GetWaveFormatEx(SpeechWaveFormatEx);
}

template <class T> Speechlib_tlb::ISpeechWaveFormatEx* __fastcall
TCOMISpeechAudioFormatT<T>::GetWaveFormatEx(void)
{
  Speechlib_tlb::ISpeechWaveFormatEx* SpeechWaveFormatEx;
  OLECHECK(this->GetWaveFormatEx((Speechlib_tlb::ISpeechWaveFormatEx**)&SpeechWaveFormatEx));
  return SpeechWaveFormatEx;
}

template <class T> HRESULT __fastcall
TCOMISpeechAudioFormatT<T>::SetWaveFormatEx(Speechlib_tlb::ISpeechWaveFormatEx* SpeechWaveFormatEx/*[in]*/)
{
  return (*this)->SetWaveFormatEx(SpeechWaveFormatEx);
}

// *********************************************************************//
// DispIntf:  ISpeechAudioFormat
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {E6E9C590-3E18-40E3-8299-061F98BDE7C7}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechAudioFormatDispT<T>::get_Type(Speechlib_tlb::SpeechAudioFormatType* AudioFormat/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Type"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)AudioFormat /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechAudioFormatType __fastcall
ISpeechAudioFormatDispT<T>::get_Type(void)
{
  Speechlib_tlb::SpeechAudioFormatType AudioFormat;
  this->get_Type((Speechlib_tlb::SpeechAudioFormatType*)&AudioFormat);
  return AudioFormat;
}

template <class T> HRESULT __fastcall
ISpeechAudioFormatDispT<T>::set_Type(Speechlib_tlb::SpeechAudioFormatType AudioFormat/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Type"), DISPID(1));
  TAutoArgs<1> _args;
  _args[1] = (int)AudioFormat /*[VT_USERDEFINED:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechAudioFormatDispT<T>::get_Guid(BSTR* Guid/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Guid"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Guid /*[VT_BSTR:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechAudioFormatDispT<T>::get_Guid(void)
{
  BSTR Guid;
  this->get_Guid((BSTR*)&Guid);
  return Guid;
}

template <class T> HRESULT __fastcall
ISpeechAudioFormatDispT<T>::set_Guid(BSTR Guid/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Guid"), DISPID(2));
  TAutoArgs<1> _args;
  _args[1] = Guid /*[VT_BSTR:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechAudioFormatDispT<T>::GetWaveFormatEx(Speechlib_tlb::ISpeechWaveFormatEx** SpeechWaveFormatEx/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetWaveFormatEx"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechWaveFormatEx**)SpeechWaveFormatEx /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechWaveFormatEx* __fastcall
ISpeechAudioFormatDispT<T>::GetWaveFormatEx(void)
{
  Speechlib_tlb::ISpeechWaveFormatEx* SpeechWaveFormatEx;
  this->GetWaveFormatEx((Speechlib_tlb::ISpeechWaveFormatEx**)&SpeechWaveFormatEx);
  return SpeechWaveFormatEx;
}

template <class T> HRESULT __fastcall
ISpeechAudioFormatDispT<T>::SetWaveFormatEx(Speechlib_tlb::ISpeechWaveFormatEx* SpeechWaveFormatEx/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("SetWaveFormatEx"), DISPID(4));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechWaveFormatEx*)SpeechWaveFormatEx /*[VT_USERDEFINED:1]*/;
  return OleFunction(_dispid, _args);
}

// *********************************************************************//
// SmartIntf: TCOMISpeechWaveFormatEx
// Interface: ISpeechWaveFormatEx
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMISpeechWaveFormatExT<T>::get_FormatTag(short* FormatTag/*[out,retval]*/)
{
  return (*this)->get_FormatTag(FormatTag);
}

template <class T> short __fastcall
TCOMISpeechWaveFormatExT<T>::get_FormatTag(void)
{
  short FormatTag;
  OLECHECK(this->get_FormatTag((short*)&FormatTag));
  return FormatTag;
}

template <class T> HRESULT __fastcall
TCOMISpeechWaveFormatExT<T>::set_FormatTag(short FormatTag/*[in]*/)
{
  return (*this)->set_FormatTag(FormatTag);
}

template <class T> HRESULT __fastcall
TCOMISpeechWaveFormatExT<T>::get_Channels(short* Channels/*[out,retval]*/)
{
  return (*this)->get_Channels(Channels);
}

template <class T> short __fastcall
TCOMISpeechWaveFormatExT<T>::get_Channels(void)
{
  short Channels;
  OLECHECK(this->get_Channels((short*)&Channels));
  return Channels;
}

template <class T> HRESULT __fastcall
TCOMISpeechWaveFormatExT<T>::set_Channels(short Channels/*[in]*/)
{
  return (*this)->set_Channels(Channels);
}

template <class T> HRESULT __fastcall
TCOMISpeechWaveFormatExT<T>::get_SamplesPerSec(long* SamplesPerSec/*[out,retval]*/)
{
  return (*this)->get_SamplesPerSec(SamplesPerSec);
}

template <class T> long __fastcall
TCOMISpeechWaveFormatExT<T>::get_SamplesPerSec(void)
{
  long SamplesPerSec;
  OLECHECK(this->get_SamplesPerSec((long*)&SamplesPerSec));
  return SamplesPerSec;
}

template <class T> HRESULT __fastcall
TCOMISpeechWaveFormatExT<T>::set_SamplesPerSec(long SamplesPerSec/*[in]*/)
{
  return (*this)->set_SamplesPerSec(SamplesPerSec);
}

template <class T> HRESULT __fastcall
TCOMISpeechWaveFormatExT<T>::get_AvgBytesPerSec(long* AvgBytesPerSec/*[out,retval]*/)
{
  return (*this)->get_AvgBytesPerSec(AvgBytesPerSec);
}

template <class T> long __fastcall
TCOMISpeechWaveFormatExT<T>::get_AvgBytesPerSec(void)
{
  long AvgBytesPerSec;
  OLECHECK(this->get_AvgBytesPerSec((long*)&AvgBytesPerSec));
  return AvgBytesPerSec;
}

template <class T> HRESULT __fastcall
TCOMISpeechWaveFormatExT<T>::set_AvgBytesPerSec(long AvgBytesPerSec/*[in]*/)
{
  return (*this)->set_AvgBytesPerSec(AvgBytesPerSec);
}

template <class T> HRESULT __fastcall
TCOMISpeechWaveFormatExT<T>::get_BlockAlign(short* BlockAlign/*[out,retval]*/)
{
  return (*this)->get_BlockAlign(BlockAlign);
}

template <class T> short __fastcall
TCOMISpeechWaveFormatExT<T>::get_BlockAlign(void)
{
  short BlockAlign;
  OLECHECK(this->get_BlockAlign((short*)&BlockAlign));
  return BlockAlign;
}

template <class T> HRESULT __fastcall
TCOMISpeechWaveFormatExT<T>::set_BlockAlign(short BlockAlign/*[in]*/)
{
  return (*this)->set_BlockAlign(BlockAlign);
}

template <class T> HRESULT __fastcall
TCOMISpeechWaveFormatExT<T>::get_BitsPerSample(short* BitsPerSample/*[out,retval]*/)
{
  return (*this)->get_BitsPerSample(BitsPerSample);
}

template <class T> short __fastcall
TCOMISpeechWaveFormatExT<T>::get_BitsPerSample(void)
{
  short BitsPerSample;
  OLECHECK(this->get_BitsPerSample((short*)&BitsPerSample));
  return BitsPerSample;
}

template <class T> HRESULT __fastcall
TCOMISpeechWaveFormatExT<T>::set_BitsPerSample(short BitsPerSample/*[in]*/)
{
  return (*this)->set_BitsPerSample(BitsPerSample);
}

template <class T> HRESULT __fastcall
TCOMISpeechWaveFormatExT<T>::get_ExtraData(VARIANT* ExtraData/*[out,retval]*/)
{
  return (*this)->get_ExtraData(ExtraData);
}

template <class T> VARIANT __fastcall
TCOMISpeechWaveFormatExT<T>::get_ExtraData(void)
{
  VARIANT ExtraData;
  OLECHECK(this->get_ExtraData((VARIANT*)&ExtraData));
  return ExtraData;
}

template <class T> HRESULT __fastcall
TCOMISpeechWaveFormatExT<T>::set_ExtraData(VARIANT ExtraData/*[in]*/)
{
  return (*this)->set_ExtraData(ExtraData);
}

// *********************************************************************//
// DispIntf:  ISpeechWaveFormatEx
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {7A1EF0D5-1581-4741-88E4-209A49F11A10}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechWaveFormatExDispT<T>::get_FormatTag(short* FormatTag/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("FormatTag"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(FormatTag /*[VT_I2:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> short __fastcall
ISpeechWaveFormatExDispT<T>::get_FormatTag(void)
{
  short FormatTag;
  this->get_FormatTag((short*)&FormatTag);
  return FormatTag;
}

template <class T> HRESULT __fastcall
ISpeechWaveFormatExDispT<T>::set_FormatTag(short FormatTag/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("FormatTag"), DISPID(1));
  TAutoArgs<1> _args;
  _args[1] = FormatTag /*[VT_I2:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechWaveFormatExDispT<T>::get_Channels(short* Channels/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Channels"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Channels /*[VT_I2:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> short __fastcall
ISpeechWaveFormatExDispT<T>::get_Channels(void)
{
  short Channels;
  this->get_Channels((short*)&Channels);
  return Channels;
}

template <class T> HRESULT __fastcall
ISpeechWaveFormatExDispT<T>::set_Channels(short Channels/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Channels"), DISPID(2));
  TAutoArgs<1> _args;
  _args[1] = Channels /*[VT_I2:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechWaveFormatExDispT<T>::get_SamplesPerSec(long* SamplesPerSec/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("SamplesPerSec"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(SamplesPerSec /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechWaveFormatExDispT<T>::get_SamplesPerSec(void)
{
  long SamplesPerSec;
  this->get_SamplesPerSec((long*)&SamplesPerSec);
  return SamplesPerSec;
}

template <class T> HRESULT __fastcall
ISpeechWaveFormatExDispT<T>::set_SamplesPerSec(long SamplesPerSec/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("SamplesPerSec"), DISPID(3));
  TAutoArgs<1> _args;
  _args[1] = SamplesPerSec /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechWaveFormatExDispT<T>::get_AvgBytesPerSec(long* AvgBytesPerSec/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("AvgBytesPerSec"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(AvgBytesPerSec /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechWaveFormatExDispT<T>::get_AvgBytesPerSec(void)
{
  long AvgBytesPerSec;
  this->get_AvgBytesPerSec((long*)&AvgBytesPerSec);
  return AvgBytesPerSec;
}

template <class T> HRESULT __fastcall
ISpeechWaveFormatExDispT<T>::set_AvgBytesPerSec(long AvgBytesPerSec/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("AvgBytesPerSec"), DISPID(4));
  TAutoArgs<1> _args;
  _args[1] = AvgBytesPerSec /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechWaveFormatExDispT<T>::get_BlockAlign(short* BlockAlign/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("BlockAlign"), DISPID(5));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(BlockAlign /*[VT_I2:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> short __fastcall
ISpeechWaveFormatExDispT<T>::get_BlockAlign(void)
{
  short BlockAlign;
  this->get_BlockAlign((short*)&BlockAlign);
  return BlockAlign;
}

template <class T> HRESULT __fastcall
ISpeechWaveFormatExDispT<T>::set_BlockAlign(short BlockAlign/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("BlockAlign"), DISPID(5));
  TAutoArgs<1> _args;
  _args[1] = BlockAlign /*[VT_I2:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechWaveFormatExDispT<T>::get_BitsPerSample(short* BitsPerSample/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("BitsPerSample"), DISPID(6));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(BitsPerSample /*[VT_I2:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> short __fastcall
ISpeechWaveFormatExDispT<T>::get_BitsPerSample(void)
{
  short BitsPerSample;
  this->get_BitsPerSample((short*)&BitsPerSample);
  return BitsPerSample;
}

template <class T> HRESULT __fastcall
ISpeechWaveFormatExDispT<T>::set_BitsPerSample(short BitsPerSample/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("BitsPerSample"), DISPID(6));
  TAutoArgs<1> _args;
  _args[1] = BitsPerSample /*[VT_I2:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechWaveFormatExDispT<T>::get_ExtraData(VARIANT* ExtraData/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("ExtraData"), DISPID(7));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(ExtraData /*[VT_VARIANT:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechWaveFormatExDispT<T>::get_ExtraData(void)
{
  VARIANT ExtraData;
  this->get_ExtraData((VARIANT*)&ExtraData);
  return ExtraData;
}

template <class T> HRESULT __fastcall
ISpeechWaveFormatExDispT<T>::set_ExtraData(VARIANT ExtraData/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("ExtraData"), DISPID(7));
  TAutoArgs<1> _args;
  _args[1] = ExtraData /*[VT_VARIANT:0]*/;
  return OlePropertyPut(_dispid, _args);
}

// *********************************************************************//
// DispIntf:  ISpeechBaseStream
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {6450336F-7D49-4CED-8097-49D6DEE37294}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechBaseStreamDispT<T>::get_Format(Speechlib_tlb::ISpeechAudioFormat** AudioFormat/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Format"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechAudioFormat**)AudioFormat /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechAudioFormatPtr __fastcall
ISpeechBaseStreamDispT<T>::get_Format(void)
{
  Speechlib_tlb::ISpeechAudioFormatPtr AudioFormat;
  this->get_Format(&AudioFormat);
  return AudioFormat;
}

template <class T> HRESULT __fastcall
ISpeechBaseStreamDispT<T>::_set_Format(Speechlib_tlb::ISpeechAudioFormat* AudioFormat/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Format"), DISPID(1));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechAudioFormat*)AudioFormat /*[VT_USERDEFINED:1]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechBaseStreamDispT<T>::Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/, 
                                long* BytesRead/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Read"), DISPID(2));
  TAutoArgs<2> _args;
  _args[1] = Buffer /*[VT_VARIANT:1]*/;
  _args[2] = NumberOfBytes /*[VT_I4:0]*/;
  return OutRetValSetterPtr(BytesRead /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
ISpeechBaseStreamDispT<T>::Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/)
{
  long BytesRead;
  this->Read(Buffer, NumberOfBytes, (long*)&BytesRead);
  return BytesRead;
}

template <class T> HRESULT __fastcall
ISpeechBaseStreamDispT<T>::Write(VARIANT Buffer/*[in]*/, long* BytesWritten/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Write"), DISPID(3));
  TAutoArgs<1> _args;
  _args[1] = Buffer /*[VT_VARIANT:0]*/;
  return OutRetValSetterPtr(BytesWritten /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
ISpeechBaseStreamDispT<T>::Write(VARIANT Buffer/*[in]*/)
{
  long BytesWritten;
  this->Write(Buffer, (long*)&BytesWritten);
  return BytesWritten;
}

template <class T> HRESULT __fastcall
ISpeechBaseStreamDispT<T>::Seek(VARIANT Position/*[in]*/, 
                                Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/, 
                                VARIANT* NewPosition/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Seek"), DISPID(4));
  TAutoArgs<2> _args;
  _args[1] = Position /*[VT_VARIANT:0]*/;
  _args[2] = (int)Origin /*[VT_USERDEFINED:0]*/;
  return OutRetValSetterPtr(NewPosition /*[VT_VARIANT:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechBaseStreamDispT<T>::Seek(VARIANT Position/*[in]*/, 
                                Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/)
{
  VARIANT NewPosition;
  this->Seek(Position, Origin, (VARIANT*)&NewPosition);
  return NewPosition;
}

// *********************************************************************//
// SmartIntf: TCOMISpeechFileStream
// Interface: ISpeechFileStream
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMISpeechFileStreamT<T>::Open(BSTR FileName/*[in]*/, 
                                Speechlib_tlb::SpeechStreamFileMode FileMode/*[in,def,opt]*/, 
                                VARIANT_BOOL DoEvents/*[in,def,opt]*/)
{
  return (*this)->Open(FileName, FileMode, DoEvents);
}

template <class T> HRESULT __fastcall
TCOMISpeechFileStreamT<T>::Close(void)
{
  return (*this)->Close();
}

// *********************************************************************//
// DispIntf:  ISpeechFileStream
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {AF67F125-AB39-4E93-B4A2-CC2E66E182A7}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechFileStreamDispT<T>::Open(BSTR FileName/*[in]*/, 
                                Speechlib_tlb::SpeechStreamFileMode FileMode/*[in,def,opt]*/, 
                                VARIANT_BOOL DoEvents/*[in,def,opt]*/)
{
  _TDispID _dispid(*this, OLETEXT("Open"), DISPID(100));
  TAutoArgs<3> _args;
  _args[1] = FileName /*[VT_BSTR:0]*/;
  _args[2] = (int)FileMode /*[VT_USERDEFINED:0]*/;
  _args[3] = DoEvents /*[VT_BOOL:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechFileStreamDispT<T>::Close()
{
  _TDispID _dispid(*this, OLETEXT("Close"), DISPID(101));
  return OleFunction(_dispid);
}

template <class T> HRESULT __fastcall
ISpeechFileStreamDispT<T>::get_Format(Speechlib_tlb::ISpeechAudioFormat** AudioFormat/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Format"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechAudioFormat**)AudioFormat /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechAudioFormatPtr __fastcall
ISpeechFileStreamDispT<T>::get_Format(void)
{
  Speechlib_tlb::ISpeechAudioFormatPtr AudioFormat;
  this->get_Format(&AudioFormat);
  return AudioFormat;
}

template <class T> HRESULT __fastcall
ISpeechFileStreamDispT<T>::_set_Format(Speechlib_tlb::ISpeechAudioFormat* AudioFormat/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Format"), DISPID(1));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechAudioFormat*)AudioFormat /*[VT_USERDEFINED:1]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechFileStreamDispT<T>::Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/, 
                                long* BytesRead/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Read"), DISPID(2));
  TAutoArgs<2> _args;
  _args[1] = Buffer /*[VT_VARIANT:1]*/;
  _args[2] = NumberOfBytes /*[VT_I4:0]*/;
  return OutRetValSetterPtr(BytesRead /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
ISpeechFileStreamDispT<T>::Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/)
{
  long BytesRead;
  this->Read(Buffer, NumberOfBytes, (long*)&BytesRead);
  return BytesRead;
}

template <class T> HRESULT __fastcall
ISpeechFileStreamDispT<T>::Write(VARIANT Buffer/*[in]*/, long* BytesWritten/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Write"), DISPID(3));
  TAutoArgs<1> _args;
  _args[1] = Buffer /*[VT_VARIANT:0]*/;
  return OutRetValSetterPtr(BytesWritten /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
ISpeechFileStreamDispT<T>::Write(VARIANT Buffer/*[in]*/)
{
  long BytesWritten;
  this->Write(Buffer, (long*)&BytesWritten);
  return BytesWritten;
}

template <class T> HRESULT __fastcall
ISpeechFileStreamDispT<T>::Seek(VARIANT Position/*[in]*/, 
                                Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/, 
                                VARIANT* NewPosition/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Seek"), DISPID(4));
  TAutoArgs<2> _args;
  _args[1] = Position /*[VT_VARIANT:0]*/;
  _args[2] = (int)Origin /*[VT_USERDEFINED:0]*/;
  return OutRetValSetterPtr(NewPosition /*[VT_VARIANT:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechFileStreamDispT<T>::Seek(VARIANT Position/*[in]*/, 
                                Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/)
{
  VARIANT NewPosition;
  this->Seek(Position, Origin, (VARIANT*)&NewPosition);
  return NewPosition;
}

// *********************************************************************//
// SmartIntf: TCOMISpeechMemoryStream
// Interface: ISpeechMemoryStream
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMISpeechMemoryStreamT<T>::SetData(VARIANT Data/*[in]*/)
{
  return (*this)->SetData(Data);
}

template <class T> HRESULT __fastcall
TCOMISpeechMemoryStreamT<T>::GetData(VARIANT* pData/*[out,retval]*/)
{
  return (*this)->GetData(pData);
}

template <class T> VARIANT __fastcall
TCOMISpeechMemoryStreamT<T>::GetData(void)
{
  VARIANT pData;
  OLECHECK(this->GetData((VARIANT*)&pData));
  return pData;
}

// *********************************************************************//
// DispIntf:  ISpeechMemoryStream
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {EEB14B68-808B-4ABE-A5EA-B51DA7588008}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechMemoryStreamDispT<T>::SetData(VARIANT Data/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("SetData"), DISPID(100));
  TAutoArgs<1> _args;
  _args[1] = Data /*[VT_VARIANT:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechMemoryStreamDispT<T>::GetData(VARIANT* pData/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetData"), DISPID(101));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pData /*[VT_VARIANT:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechMemoryStreamDispT<T>::GetData(void)
{
  VARIANT pData;
  this->GetData((VARIANT*)&pData);
  return pData;
}

template <class T> HRESULT __fastcall
ISpeechMemoryStreamDispT<T>::get_Format(Speechlib_tlb::ISpeechAudioFormat** AudioFormat/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Format"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechAudioFormat**)AudioFormat /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechAudioFormatPtr __fastcall
ISpeechMemoryStreamDispT<T>::get_Format(void)
{
  Speechlib_tlb::ISpeechAudioFormatPtr AudioFormat;
  this->get_Format(&AudioFormat);
  return AudioFormat;
}

template <class T> HRESULT __fastcall
ISpeechMemoryStreamDispT<T>::_set_Format(Speechlib_tlb::ISpeechAudioFormat* AudioFormat/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Format"), DISPID(1));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechAudioFormat*)AudioFormat /*[VT_USERDEFINED:1]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechMemoryStreamDispT<T>::Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/, 
                                  long* BytesRead/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Read"), DISPID(2));
  TAutoArgs<2> _args;
  _args[1] = Buffer /*[VT_VARIANT:1]*/;
  _args[2] = NumberOfBytes /*[VT_I4:0]*/;
  return OutRetValSetterPtr(BytesRead /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
ISpeechMemoryStreamDispT<T>::Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/)
{
  long BytesRead;
  this->Read(Buffer, NumberOfBytes, (long*)&BytesRead);
  return BytesRead;
}

template <class T> HRESULT __fastcall
ISpeechMemoryStreamDispT<T>::Write(VARIANT Buffer/*[in]*/, long* BytesWritten/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Write"), DISPID(3));
  TAutoArgs<1> _args;
  _args[1] = Buffer /*[VT_VARIANT:0]*/;
  return OutRetValSetterPtr(BytesWritten /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
ISpeechMemoryStreamDispT<T>::Write(VARIANT Buffer/*[in]*/)
{
  long BytesWritten;
  this->Write(Buffer, (long*)&BytesWritten);
  return BytesWritten;
}

template <class T> HRESULT __fastcall
ISpeechMemoryStreamDispT<T>::Seek(VARIANT Position/*[in]*/, 
                                  Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/
                                  , VARIANT* NewPosition/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Seek"), DISPID(4));
  TAutoArgs<2> _args;
  _args[1] = Position /*[VT_VARIANT:0]*/;
  _args[2] = (int)Origin /*[VT_USERDEFINED:0]*/;
  return OutRetValSetterPtr(NewPosition /*[VT_VARIANT:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechMemoryStreamDispT<T>::Seek(VARIANT Position/*[in]*/, 
                                  Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/)
{
  VARIANT NewPosition;
  this->Seek(Position, Origin, (VARIANT*)&NewPosition);
  return NewPosition;
}

// *********************************************************************//
// SmartIntf: TCOMISpeechCustomStream
// Interface: ISpeechCustomStream
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMISpeechCustomStreamT<T>::get_BaseStream(LPUNKNOWN* ppUnkStream/*[out,retval]*/)
{
  return (*this)->get_BaseStream(ppUnkStream);
}

template <class T> LPUNKNOWN __fastcall
TCOMISpeechCustomStreamT<T>::get_BaseStream(void)
{
  LPUNKNOWN ppUnkStream;
  OLECHECK(this->get_BaseStream((LPUNKNOWN*)&ppUnkStream));
  return ppUnkStream;
}

template <class T> HRESULT __fastcall
TCOMISpeechCustomStreamT<T>::_set_BaseStream(LPUNKNOWN ppUnkStream/*[in]*/)
{
  return (*this)->_set_BaseStream(ppUnkStream);
}

// *********************************************************************//
// DispIntf:  ISpeechCustomStream
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {1A9E9F4F-104F-4DB8-A115-EFD7FD0C97AE}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechCustomStreamDispT<T>::get_BaseStream(LPUNKNOWN* ppUnkStream/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("BaseStream"), DISPID(100));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(ppUnkStream /*[VT_UNKNOWN:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> LPUNKNOWN __fastcall
ISpeechCustomStreamDispT<T>::get_BaseStream(void)
{
  LPUNKNOWN ppUnkStream;
  this->get_BaseStream((LPUNKNOWN*)&ppUnkStream);
  return ppUnkStream;
}

template <class T> HRESULT __fastcall
ISpeechCustomStreamDispT<T>::_set_BaseStream(LPUNKNOWN ppUnkStream/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("BaseStream"), DISPID(100));
  TAutoArgs<1> _args;
  _args[1] = ppUnkStream /*[VT_UNKNOWN:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechCustomStreamDispT<T>::get_Format(Speechlib_tlb::ISpeechAudioFormat** AudioFormat/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Format"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechAudioFormat**)AudioFormat /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechAudioFormatPtr __fastcall
ISpeechCustomStreamDispT<T>::get_Format(void)
{
  Speechlib_tlb::ISpeechAudioFormatPtr AudioFormat;
  this->get_Format(&AudioFormat);
  return AudioFormat;
}

template <class T> HRESULT __fastcall
ISpeechCustomStreamDispT<T>::_set_Format(Speechlib_tlb::ISpeechAudioFormat* AudioFormat/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Format"), DISPID(1));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechAudioFormat*)AudioFormat /*[VT_USERDEFINED:1]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechCustomStreamDispT<T>::Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/, 
                                  long* BytesRead/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Read"), DISPID(2));
  TAutoArgs<2> _args;
  _args[1] = Buffer /*[VT_VARIANT:1]*/;
  _args[2] = NumberOfBytes /*[VT_I4:0]*/;
  return OutRetValSetterPtr(BytesRead /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
ISpeechCustomStreamDispT<T>::Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/)
{
  long BytesRead;
  this->Read(Buffer, NumberOfBytes, (long*)&BytesRead);
  return BytesRead;
}

template <class T> HRESULT __fastcall
ISpeechCustomStreamDispT<T>::Write(VARIANT Buffer/*[in]*/, long* BytesWritten/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Write"), DISPID(3));
  TAutoArgs<1> _args;
  _args[1] = Buffer /*[VT_VARIANT:0]*/;
  return OutRetValSetterPtr(BytesWritten /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
ISpeechCustomStreamDispT<T>::Write(VARIANT Buffer/*[in]*/)
{
  long BytesWritten;
  this->Write(Buffer, (long*)&BytesWritten);
  return BytesWritten;
}

template <class T> HRESULT __fastcall
ISpeechCustomStreamDispT<T>::Seek(VARIANT Position/*[in]*/, 
                                  Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/
                                  , VARIANT* NewPosition/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Seek"), DISPID(4));
  TAutoArgs<2> _args;
  _args[1] = Position /*[VT_VARIANT:0]*/;
  _args[2] = (int)Origin /*[VT_USERDEFINED:0]*/;
  return OutRetValSetterPtr(NewPosition /*[VT_VARIANT:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechCustomStreamDispT<T>::Seek(VARIANT Position/*[in]*/, 
                                  Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/)
{
  VARIANT NewPosition;
  this->Seek(Position, Origin, (VARIANT*)&NewPosition);
  return NewPosition;
}

// *********************************************************************//
// DispIntf:  ISpeechAudio
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {CFF8E175-019E-11D3-A08E-00C04F8EF9B5}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechAudioDispT<T>::get_Status(Speechlib_tlb::ISpeechAudioStatus** Status/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Status"), DISPID(200));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechAudioStatus**)Status /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechAudioStatusPtr __fastcall
ISpeechAudioDispT<T>::get_Status(void)
{
  Speechlib_tlb::ISpeechAudioStatusPtr Status;
  this->get_Status(&Status);
  return Status;
}

template <class T> HRESULT __fastcall
ISpeechAudioDispT<T>::get_BufferInfo(Speechlib_tlb::ISpeechAudioBufferInfo** BufferInfo/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("BufferInfo"), DISPID(201));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechAudioBufferInfo**)BufferInfo /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechAudioBufferInfoPtr __fastcall
ISpeechAudioDispT<T>::get_BufferInfo(void)
{
  Speechlib_tlb::ISpeechAudioBufferInfoPtr BufferInfo;
  this->get_BufferInfo(&BufferInfo);
  return BufferInfo;
}

template <class T> HRESULT __fastcall
ISpeechAudioDispT<T>::get_DefaultFormat(Speechlib_tlb::ISpeechAudioFormat** StreamFormat/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("DefaultFormat"), DISPID(202));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechAudioFormat**)StreamFormat /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechAudioFormatPtr __fastcall
ISpeechAudioDispT<T>::get_DefaultFormat(void)
{
  Speechlib_tlb::ISpeechAudioFormatPtr StreamFormat;
  this->get_DefaultFormat(&StreamFormat);
  return StreamFormat;
}

template <class T> HRESULT __fastcall
ISpeechAudioDispT<T>::get_Volume(long* Volume/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Volume"), DISPID(203));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Volume /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechAudioDispT<T>::get_Volume(void)
{
  long Volume;
  this->get_Volume((long*)&Volume);
  return Volume;
}

template <class T> HRESULT __fastcall
ISpeechAudioDispT<T>::set_Volume(long Volume/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Volume"), DISPID(203));
  TAutoArgs<1> _args;
  _args[1] = Volume /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechAudioDispT<T>::get_BufferNotifySize(long* BufferNotifySize/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("BufferNotifySize"), DISPID(204));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(BufferNotifySize /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechAudioDispT<T>::get_BufferNotifySize(void)
{
  long BufferNotifySize;
  this->get_BufferNotifySize((long*)&BufferNotifySize);
  return BufferNotifySize;
}

template <class T> HRESULT __fastcall
ISpeechAudioDispT<T>::set_BufferNotifySize(long BufferNotifySize/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("BufferNotifySize"), DISPID(204));
  TAutoArgs<1> _args;
  _args[1] = BufferNotifySize /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechAudioDispT<T>::get_EventHandle(long* EventHandle/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("EventHandle"), DISPID(205));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(EventHandle /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechAudioDispT<T>::get_EventHandle(void)
{
  long EventHandle;
  this->get_EventHandle((long*)&EventHandle);
  return EventHandle;
}

template <class T> HRESULT __fastcall
ISpeechAudioDispT<T>::SetState(Speechlib_tlb::SpeechAudioState State/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("SetState"), DISPID(206));
  TAutoArgs<1> _args;
  _args[1] = (int)State /*[VT_USERDEFINED:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechAudioDispT<T>::get_Format(Speechlib_tlb::ISpeechAudioFormat** AudioFormat/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Format"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechAudioFormat**)AudioFormat /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechAudioFormatPtr __fastcall
ISpeechAudioDispT<T>::get_Format(void)
{
  Speechlib_tlb::ISpeechAudioFormatPtr AudioFormat;
  this->get_Format(&AudioFormat);
  return AudioFormat;
}

template <class T> HRESULT __fastcall
ISpeechAudioDispT<T>::_set_Format(Speechlib_tlb::ISpeechAudioFormat* AudioFormat/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Format"), DISPID(1));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechAudioFormat*)AudioFormat /*[VT_USERDEFINED:1]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechAudioDispT<T>::Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/, 
                           long* BytesRead/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Read"), DISPID(2));
  TAutoArgs<2> _args;
  _args[1] = Buffer /*[VT_VARIANT:1]*/;
  _args[2] = NumberOfBytes /*[VT_I4:0]*/;
  return OutRetValSetterPtr(BytesRead /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
ISpeechAudioDispT<T>::Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/)
{
  long BytesRead;
  this->Read(Buffer, NumberOfBytes, (long*)&BytesRead);
  return BytesRead;
}

template <class T> HRESULT __fastcall
ISpeechAudioDispT<T>::Write(VARIANT Buffer/*[in]*/, long* BytesWritten/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Write"), DISPID(3));
  TAutoArgs<1> _args;
  _args[1] = Buffer /*[VT_VARIANT:0]*/;
  return OutRetValSetterPtr(BytesWritten /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
ISpeechAudioDispT<T>::Write(VARIANT Buffer/*[in]*/)
{
  long BytesWritten;
  this->Write(Buffer, (long*)&BytesWritten);
  return BytesWritten;
}

template <class T> HRESULT __fastcall
ISpeechAudioDispT<T>::Seek(VARIANT Position/*[in]*/, 
                           Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/, 
                           VARIANT* NewPosition/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Seek"), DISPID(4));
  TAutoArgs<2> _args;
  _args[1] = Position /*[VT_VARIANT:0]*/;
  _args[2] = (int)Origin /*[VT_USERDEFINED:0]*/;
  return OutRetValSetterPtr(NewPosition /*[VT_VARIANT:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechAudioDispT<T>::Seek(VARIANT Position/*[in]*/, 
                           Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/)
{
  VARIANT NewPosition;
  this->Seek(Position, Origin, (VARIANT*)&NewPosition);
  return NewPosition;
}

// *********************************************************************//
// SmartIntf: TCOMISpeechMMSysAudio
// Interface: ISpeechMMSysAudio
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMISpeechMMSysAudioT<T>::get_DeviceId(long* DeviceId/*[out,retval]*/)
{
  return (*this)->get_DeviceId(DeviceId);
}

template <class T> long __fastcall
TCOMISpeechMMSysAudioT<T>::get_DeviceId(void)
{
  long DeviceId;
  OLECHECK(this->get_DeviceId((long*)&DeviceId));
  return DeviceId;
}

template <class T> HRESULT __fastcall
TCOMISpeechMMSysAudioT<T>::set_DeviceId(long DeviceId/*[in]*/)
{
  return (*this)->set_DeviceId(DeviceId);
}

template <class T> HRESULT __fastcall
TCOMISpeechMMSysAudioT<T>::get_LineId(long* LineId/*[out,retval]*/)
{
  return (*this)->get_LineId(LineId);
}

template <class T> long __fastcall
TCOMISpeechMMSysAudioT<T>::get_LineId(void)
{
  long LineId;
  OLECHECK(this->get_LineId((long*)&LineId));
  return LineId;
}

template <class T> HRESULT __fastcall
TCOMISpeechMMSysAudioT<T>::set_LineId(long LineId/*[in]*/)
{
  return (*this)->set_LineId(LineId);
}

template <class T> HRESULT __fastcall
TCOMISpeechMMSysAudioT<T>::get_MMHandle(long* Handle/*[out,retval]*/)
{
  return (*this)->get_MMHandle(Handle);
}

template <class T> long __fastcall
TCOMISpeechMMSysAudioT<T>::get_MMHandle(void)
{
  long Handle;
  OLECHECK(this->get_MMHandle((long*)&Handle));
  return Handle;
}

// *********************************************************************//
// DispIntf:  ISpeechMMSysAudio
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {3C76AF6D-1FD7-4831-81D1-3B71D5A13C44}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechMMSysAudioDispT<T>::get_DeviceId(long* DeviceId/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("DeviceId"), DISPID(300));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(DeviceId /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechMMSysAudioDispT<T>::get_DeviceId(void)
{
  long DeviceId;
  this->get_DeviceId((long*)&DeviceId);
  return DeviceId;
}

template <class T> HRESULT __fastcall
ISpeechMMSysAudioDispT<T>::set_DeviceId(long DeviceId/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("DeviceId"), DISPID(300));
  TAutoArgs<1> _args;
  _args[1] = DeviceId /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechMMSysAudioDispT<T>::get_LineId(long* LineId/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("LineId"), DISPID(301));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(LineId /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechMMSysAudioDispT<T>::get_LineId(void)
{
  long LineId;
  this->get_LineId((long*)&LineId);
  return LineId;
}

template <class T> HRESULT __fastcall
ISpeechMMSysAudioDispT<T>::set_LineId(long LineId/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("LineId"), DISPID(301));
  TAutoArgs<1> _args;
  _args[1] = LineId /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechMMSysAudioDispT<T>::get_MMHandle(long* Handle/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("MMHandle"), DISPID(302));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Handle /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechMMSysAudioDispT<T>::get_MMHandle(void)
{
  long Handle;
  this->get_MMHandle((long*)&Handle);
  return Handle;
}

template <class T> HRESULT __fastcall
ISpeechMMSysAudioDispT<T>::get_Status(Speechlib_tlb::ISpeechAudioStatus** Status/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Status"), DISPID(200));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechAudioStatus**)Status /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechAudioStatusPtr __fastcall
ISpeechMMSysAudioDispT<T>::get_Status(void)
{
  Speechlib_tlb::ISpeechAudioStatusPtr Status;
  this->get_Status(&Status);
  return Status;
}

template <class T> HRESULT __fastcall
ISpeechMMSysAudioDispT<T>::get_BufferInfo(Speechlib_tlb::ISpeechAudioBufferInfo** BufferInfo/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("BufferInfo"), DISPID(201));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechAudioBufferInfo**)BufferInfo /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechAudioBufferInfoPtr __fastcall
ISpeechMMSysAudioDispT<T>::get_BufferInfo(void)
{
  Speechlib_tlb::ISpeechAudioBufferInfoPtr BufferInfo;
  this->get_BufferInfo(&BufferInfo);
  return BufferInfo;
}

template <class T> HRESULT __fastcall
ISpeechMMSysAudioDispT<T>::get_DefaultFormat(Speechlib_tlb::ISpeechAudioFormat** StreamFormat/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("DefaultFormat"), DISPID(202));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechAudioFormat**)StreamFormat /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechAudioFormatPtr __fastcall
ISpeechMMSysAudioDispT<T>::get_DefaultFormat(void)
{
  Speechlib_tlb::ISpeechAudioFormatPtr StreamFormat;
  this->get_DefaultFormat(&StreamFormat);
  return StreamFormat;
}

template <class T> HRESULT __fastcall
ISpeechMMSysAudioDispT<T>::get_Volume(long* Volume/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Volume"), DISPID(203));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Volume /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechMMSysAudioDispT<T>::get_Volume(void)
{
  long Volume;
  this->get_Volume((long*)&Volume);
  return Volume;
}

template <class T> HRESULT __fastcall
ISpeechMMSysAudioDispT<T>::set_Volume(long Volume/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Volume"), DISPID(203));
  TAutoArgs<1> _args;
  _args[1] = Volume /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechMMSysAudioDispT<T>::get_BufferNotifySize(long* BufferNotifySize/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("BufferNotifySize"), DISPID(204));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(BufferNotifySize /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechMMSysAudioDispT<T>::get_BufferNotifySize(void)
{
  long BufferNotifySize;
  this->get_BufferNotifySize((long*)&BufferNotifySize);
  return BufferNotifySize;
}

template <class T> HRESULT __fastcall
ISpeechMMSysAudioDispT<T>::set_BufferNotifySize(long BufferNotifySize/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("BufferNotifySize"), DISPID(204));
  TAutoArgs<1> _args;
  _args[1] = BufferNotifySize /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechMMSysAudioDispT<T>::get_EventHandle(long* EventHandle/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("EventHandle"), DISPID(205));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(EventHandle /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechMMSysAudioDispT<T>::get_EventHandle(void)
{
  long EventHandle;
  this->get_EventHandle((long*)&EventHandle);
  return EventHandle;
}

template <class T> HRESULT __fastcall
ISpeechMMSysAudioDispT<T>::SetState(Speechlib_tlb::SpeechAudioState State/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("SetState"), DISPID(206));
  TAutoArgs<1> _args;
  _args[1] = (int)State /*[VT_USERDEFINED:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechMMSysAudioDispT<T>::get_Format(Speechlib_tlb::ISpeechAudioFormat** AudioFormat/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Format"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechAudioFormat**)AudioFormat /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechAudioFormatPtr __fastcall
ISpeechMMSysAudioDispT<T>::get_Format(void)
{
  Speechlib_tlb::ISpeechAudioFormatPtr AudioFormat;
  this->get_Format(&AudioFormat);
  return AudioFormat;
}

template <class T> HRESULT __fastcall
ISpeechMMSysAudioDispT<T>::_set_Format(Speechlib_tlb::ISpeechAudioFormat* AudioFormat/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Format"), DISPID(1));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechAudioFormat*)AudioFormat /*[VT_USERDEFINED:1]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechMMSysAudioDispT<T>::Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/, 
                                long* BytesRead/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Read"), DISPID(2));
  TAutoArgs<2> _args;
  _args[1] = Buffer /*[VT_VARIANT:1]*/;
  _args[2] = NumberOfBytes /*[VT_I4:0]*/;
  return OutRetValSetterPtr(BytesRead /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
ISpeechMMSysAudioDispT<T>::Read(VARIANT* Buffer/*[out]*/, long NumberOfBytes/*[in]*/)
{
  long BytesRead;
  this->Read(Buffer, NumberOfBytes, (long*)&BytesRead);
  return BytesRead;
}

template <class T> HRESULT __fastcall
ISpeechMMSysAudioDispT<T>::Write(VARIANT Buffer/*[in]*/, long* BytesWritten/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Write"), DISPID(3));
  TAutoArgs<1> _args;
  _args[1] = Buffer /*[VT_VARIANT:0]*/;
  return OutRetValSetterPtr(BytesWritten /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
ISpeechMMSysAudioDispT<T>::Write(VARIANT Buffer/*[in]*/)
{
  long BytesWritten;
  this->Write(Buffer, (long*)&BytesWritten);
  return BytesWritten;
}

template <class T> HRESULT __fastcall
ISpeechMMSysAudioDispT<T>::Seek(VARIANT Position/*[in]*/, 
                                Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/, 
                                VARIANT* NewPosition/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Seek"), DISPID(4));
  TAutoArgs<2> _args;
  _args[1] = Position /*[VT_VARIANT:0]*/;
  _args[2] = (int)Origin /*[VT_USERDEFINED:0]*/;
  return OutRetValSetterPtr(NewPosition /*[VT_VARIANT:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechMMSysAudioDispT<T>::Seek(VARIANT Position/*[in]*/, 
                                Speechlib_tlb::SpeechStreamSeekPositionType Origin/*[in,def,opt]*/)
{
  VARIANT NewPosition;
  this->Seek(Position, Origin, (VARIANT*)&NewPosition);
  return NewPosition;
}

// *********************************************************************//
// SmartIntf: TCOMISpeechVoice
// Interface: ISpeechVoice
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::get_Status(Speechlib_tlb::ISpeechVoiceStatus** Status/*[out,retval]*/)
{
  return (*this)->get_Status(Status);
}

template <class T> Speechlib_tlb::ISpeechVoiceStatusPtr __fastcall
TCOMISpeechVoiceT<T>::get_Status(void)
{
  Speechlib_tlb::ISpeechVoiceStatusPtr Status;
  OLECHECK(this->get_Status((Speechlib_tlb::ISpeechVoiceStatusPtr*)&Status));
  return Status;
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::get_Voice(Speechlib_tlb::ISpeechObjectToken** Voice/*[out,retval]*/)
{
  return (*this)->get_Voice(Voice);
}

template <class T> Speechlib_tlb::ISpeechObjectTokenPtr __fastcall
TCOMISpeechVoiceT<T>::get_Voice(void)
{
  Speechlib_tlb::ISpeechObjectTokenPtr Voice;
  OLECHECK(this->get_Voice((Speechlib_tlb::ISpeechObjectTokenPtr*)&Voice));
  return Voice;
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::_set_Voice(Speechlib_tlb::ISpeechObjectToken* Voice/*[in]*/)
{
  return (*this)->_set_Voice(Voice);
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::get_AudioOutput(Speechlib_tlb::ISpeechObjectToken** AudioOutput/*[out,retval]*/)
{
  return (*this)->get_AudioOutput(AudioOutput);
}

template <class T> Speechlib_tlb::ISpeechObjectTokenPtr __fastcall
TCOMISpeechVoiceT<T>::get_AudioOutput(void)
{
  Speechlib_tlb::ISpeechObjectTokenPtr AudioOutput;
  OLECHECK(this->get_AudioOutput((Speechlib_tlb::ISpeechObjectTokenPtr*)&AudioOutput));
  return AudioOutput;
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::_set_AudioOutput(Speechlib_tlb::ISpeechObjectToken* AudioOutput/*[in]*/)
{
  return (*this)->_set_AudioOutput(AudioOutput);
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::get_AudioOutputStream(Speechlib_tlb::ISpeechBaseStream** AudioOutputStream/*[out,retval]*/)
{
  return (*this)->get_AudioOutputStream(AudioOutputStream);
}

template <class T> Speechlib_tlb::ISpeechBaseStreamPtr __fastcall
TCOMISpeechVoiceT<T>::get_AudioOutputStream(void)
{
  Speechlib_tlb::ISpeechBaseStreamPtr AudioOutputStream;
  OLECHECK(this->get_AudioOutputStream((Speechlib_tlb::ISpeechBaseStreamPtr*)&AudioOutputStream));
  return AudioOutputStream;
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::_set_AudioOutputStream(Speechlib_tlb::ISpeechBaseStream* AudioOutputStream/*[in]*/)
{
  return (*this)->_set_AudioOutputStream(AudioOutputStream);
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::get_Rate(long* Rate/*[out,retval]*/)
{
  return (*this)->get_Rate(Rate);
}

template <class T> long __fastcall
TCOMISpeechVoiceT<T>::get_Rate(void)
{
  long Rate;
  OLECHECK(this->get_Rate((long*)&Rate));
  return Rate;
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::set_Rate(long Rate/*[in]*/)
{
  return (*this)->set_Rate(Rate);
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::get_Volume(long* Volume/*[out,retval]*/)
{
  return (*this)->get_Volume(Volume);
}

template <class T> long __fastcall
TCOMISpeechVoiceT<T>::get_Volume(void)
{
  long Volume;
  OLECHECK(this->get_Volume((long*)&Volume));
  return Volume;
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::set_Volume(long Volume/*[in]*/)
{
  return (*this)->set_Volume(Volume);
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::set_AllowAudioOutputFormatChangesOnNextSet(VARIANT_BOOL Allow/*[in]*/)
{
  return (*this)->set_AllowAudioOutputFormatChangesOnNextSet(Allow);
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::get_AllowAudioOutputFormatChangesOnNextSet(VARIANT_BOOL* Allow/*[out,retval]*/)
{
  return (*this)->get_AllowAudioOutputFormatChangesOnNextSet(Allow);
}

template <class T> VARIANT_BOOL __fastcall
TCOMISpeechVoiceT<T>::get_AllowAudioOutputFormatChangesOnNextSet(void)
{
  VARIANT_BOOL Allow;
  OLECHECK(this->get_AllowAudioOutputFormatChangesOnNextSet((VARIANT_BOOL*)&Allow));
  return Allow;
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::get_EventInterests(Speechlib_tlb::SpeechVoiceEvents* EventInterestFlags/*[out,retval]*/)
{
  return (*this)->get_EventInterests(EventInterestFlags);
}

template <class T> Speechlib_tlb::SpeechVoiceEvents __fastcall
TCOMISpeechVoiceT<T>::get_EventInterests(void)
{
  Speechlib_tlb::SpeechVoiceEvents EventInterestFlags;
  OLECHECK(this->get_EventInterests((Speechlib_tlb::SpeechVoiceEvents*)&EventInterestFlags));
  return EventInterestFlags;
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::set_EventInterests(Speechlib_tlb::SpeechVoiceEvents EventInterestFlags/*[in]*/)
{
  return (*this)->set_EventInterests(EventInterestFlags);
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::set_Priority(Speechlib_tlb::SpeechVoicePriority Priority/*[in]*/)
{
  return (*this)->set_Priority(Priority);
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::get_Priority(Speechlib_tlb::SpeechVoicePriority* Priority/*[out,retval]*/)
{
  return (*this)->get_Priority(Priority);
}

template <class T> Speechlib_tlb::SpeechVoicePriority __fastcall
TCOMISpeechVoiceT<T>::get_Priority(void)
{
  Speechlib_tlb::SpeechVoicePriority Priority;
  OLECHECK(this->get_Priority((Speechlib_tlb::SpeechVoicePriority*)&Priority));
  return Priority;
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::set_AlertBoundary(Speechlib_tlb::SpeechVoiceEvents Boundary/*[in]*/)
{
  return (*this)->set_AlertBoundary(Boundary);
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::get_AlertBoundary(Speechlib_tlb::SpeechVoiceEvents* Boundary/*[out,retval]*/)
{
  return (*this)->get_AlertBoundary(Boundary);
}

template <class T> Speechlib_tlb::SpeechVoiceEvents __fastcall
TCOMISpeechVoiceT<T>::get_AlertBoundary(void)
{
  Speechlib_tlb::SpeechVoiceEvents Boundary;
  OLECHECK(this->get_AlertBoundary((Speechlib_tlb::SpeechVoiceEvents*)&Boundary));
  return Boundary;
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::set_SynchronousSpeakTimeout(long msTimeout/*[in]*/)
{
  return (*this)->set_SynchronousSpeakTimeout(msTimeout);
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::get_SynchronousSpeakTimeout(long* msTimeout/*[out,retval]*/)
{
  return (*this)->get_SynchronousSpeakTimeout(msTimeout);
}

template <class T> long __fastcall
TCOMISpeechVoiceT<T>::get_SynchronousSpeakTimeout(void)
{
  long msTimeout;
  OLECHECK(this->get_SynchronousSpeakTimeout((long*)&msTimeout));
  return msTimeout;
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::Speak(BSTR Text/*[in]*/, 
                            Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/, 
                            long* StreamNumber/*[out,retval]*/)
{
  return (*this)->Speak(Text, Flags, StreamNumber);
}

template <class T> long __fastcall
TCOMISpeechVoiceT<T>::Speak(BSTR Text/*[in]*/, 
                            Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/)
{
  long StreamNumber;
  OLECHECK(this->Speak(Text/*[in]*/, Flags/*[in,def,opt]*/, (long*)&StreamNumber));
  return StreamNumber;
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::SpeakStream(Speechlib_tlb::ISpeechBaseStream* Stream/*[in]*/, 
                                  Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/, 
                                  long* StreamNumber/*[out,retval]*/)
{
  return (*this)->SpeakStream(Stream, Flags, StreamNumber);
}

template <class T> long __fastcall
TCOMISpeechVoiceT<T>::SpeakStream(Speechlib_tlb::ISpeechBaseStream* Stream/*[in]*/, 
                                  Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/)
{
  long StreamNumber;
  OLECHECK(this->SpeakStream(Stream/*[in]*/, Flags/*[in,def,opt]*/, (long*)&StreamNumber));
  return StreamNumber;
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::Pause(void)
{
  return (*this)->Pause();
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::Resume(void)
{
  return (*this)->Resume();
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::Skip(BSTR Type/*[in]*/, long NumItems/*[in]*/, 
                           long* NumSkipped/*[out,retval]*/)
{
  return (*this)->Skip(Type, NumItems, NumSkipped);
}

template <class T> long __fastcall
TCOMISpeechVoiceT<T>::Skip(BSTR Type/*[in]*/, long NumItems/*[in]*/)
{
  long NumSkipped;
  OLECHECK(this->Skip(Type/*[in]*/, NumItems/*[in]*/, (long*)&NumSkipped));
  return NumSkipped;
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::GetVoices(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                BSTR OptionalAttributes/*[in,def,opt]*/, 
                                Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/)
{
  return (*this)->GetVoices(RequiredAttributes, OptionalAttributes, ObjectTokens);
}

template <class T> Speechlib_tlb::ISpeechObjectTokens* __fastcall
TCOMISpeechVoiceT<T>::GetVoices(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                BSTR OptionalAttributes/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechObjectTokens* ObjectTokens;
  OLECHECK(this->GetVoices(RequiredAttributes/*[in,def,opt]*/, OptionalAttributes/*[in,def,opt]*/, (Speechlib_tlb::ISpeechObjectTokens**)&ObjectTokens));
  return ObjectTokens;
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::GetAudioOutputs(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                      BSTR OptionalAttributes/*[in,def,opt]*/, 
                                      Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/)
{
  return (*this)->GetAudioOutputs(RequiredAttributes, OptionalAttributes, ObjectTokens);
}

template <class T> Speechlib_tlb::ISpeechObjectTokens* __fastcall
TCOMISpeechVoiceT<T>::GetAudioOutputs(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                      BSTR OptionalAttributes/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechObjectTokens* ObjectTokens;
  OLECHECK(this->GetAudioOutputs(RequiredAttributes/*[in,def,opt]*/, 
                                 OptionalAttributes/*[in,def,opt]*/, (Speechlib_tlb::ISpeechObjectTokens**)&ObjectTokens));
  return ObjectTokens;
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::WaitUntilDone(long msTimeout/*[in]*/, VARIANT_BOOL* Done/*[out,retval]*/)
{
  return (*this)->WaitUntilDone(msTimeout, Done);
}

template <class T> VARIANT_BOOL __fastcall
TCOMISpeechVoiceT<T>::WaitUntilDone(long msTimeout/*[in]*/)
{
  VARIANT_BOOL Done;
  OLECHECK(this->WaitUntilDone(msTimeout/*[in]*/, (VARIANT_BOOL*)&Done));
  return Done;
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::SpeakCompleteEvent(long* Handle/*[out,retval]*/)
{
  return (*this)->SpeakCompleteEvent(Handle);
}

template <class T> long __fastcall
TCOMISpeechVoiceT<T>::SpeakCompleteEvent(void)
{
  long Handle;
  OLECHECK(this->SpeakCompleteEvent((long*)&Handle));
  return Handle;
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::IsUISupported(BSTR TypeOfUI/*[in]*/, VARIANT* ExtraData/*[in,def,opt]*/, 
                                    VARIANT_BOOL* Supported/*[out,retval]*/)
{
  return (*this)->IsUISupported(TypeOfUI, ExtraData, Supported);
}

template <class T> VARIANT_BOOL __fastcall
TCOMISpeechVoiceT<T>::IsUISupported(BSTR TypeOfUI/*[in]*/, VARIANT* ExtraData/*[in,def,opt]*/)
{
  VARIANT_BOOL Supported;
  OLECHECK(this->IsUISupported(TypeOfUI/*[in]*/, ExtraData/*[in,def,opt]*/, (VARIANT_BOOL*)&Supported));
  return Supported;
}

template <class T> HRESULT __fastcall
TCOMISpeechVoiceT<T>::DisplayUI(long hWndParent/*[in]*/, BSTR Title/*[in]*/, BSTR TypeOfUI/*[in]*/, 
                                VARIANT* ExtraData/*[in,def,opt]*/)
{
  return (*this)->DisplayUI(hWndParent, Title, TypeOfUI, ExtraData);
}

// *********************************************************************//
// DispIntf:  ISpeechVoice
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {269316D8-57BD-11D2-9EEE-00C04F797396}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::get_Status(Speechlib_tlb::ISpeechVoiceStatus** Status/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Status"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechVoiceStatus**)Status /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechVoiceStatusPtr __fastcall
ISpeechVoiceDispT<T>::get_Status(void)
{
  Speechlib_tlb::ISpeechVoiceStatusPtr Status;
  this->get_Status(&Status);
  return Status;
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::get_Voice(Speechlib_tlb::ISpeechObjectToken** Voice/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Voice"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechObjectToken**)Voice /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechObjectTokenPtr __fastcall
ISpeechVoiceDispT<T>::get_Voice(void)
{
  Speechlib_tlb::ISpeechObjectTokenPtr Voice;
  this->get_Voice(&Voice);
  return Voice;
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::_set_Voice(Speechlib_tlb::ISpeechObjectToken* Voice/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Voice"), DISPID(2));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechObjectToken*)Voice /*[VT_USERDEFINED:1]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::get_AudioOutput(Speechlib_tlb::ISpeechObjectToken** AudioOutput/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioOutput"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechObjectToken**)AudioOutput /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechObjectTokenPtr __fastcall
ISpeechVoiceDispT<T>::get_AudioOutput(void)
{
  Speechlib_tlb::ISpeechObjectTokenPtr AudioOutput;
  this->get_AudioOutput(&AudioOutput);
  return AudioOutput;
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::_set_AudioOutput(Speechlib_tlb::ISpeechObjectToken* AudioOutput/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioOutput"), DISPID(3));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechObjectToken*)AudioOutput /*[VT_USERDEFINED:1]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::get_AudioOutputStream(Speechlib_tlb::ISpeechBaseStream** AudioOutputStream/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioOutputStream"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechBaseStream**)AudioOutputStream /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechBaseStreamPtr __fastcall
ISpeechVoiceDispT<T>::get_AudioOutputStream(void)
{
  Speechlib_tlb::ISpeechBaseStreamPtr AudioOutputStream;
  this->get_AudioOutputStream(&AudioOutputStream);
  return AudioOutputStream;
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::_set_AudioOutputStream(Speechlib_tlb::ISpeechBaseStream* AudioOutputStream/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioOutputStream"), DISPID(4));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechBaseStream*)AudioOutputStream /*[VT_USERDEFINED:1]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::get_Rate(long* Rate/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Rate"), DISPID(5));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Rate /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechVoiceDispT<T>::get_Rate(void)
{
  long Rate;
  this->get_Rate((long*)&Rate);
  return Rate;
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::set_Rate(long Rate/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Rate"), DISPID(5));
  TAutoArgs<1> _args;
  _args[1] = Rate /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::get_Volume(long* Volume/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Volume"), DISPID(6));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Volume /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechVoiceDispT<T>::get_Volume(void)
{
  long Volume;
  this->get_Volume((long*)&Volume);
  return Volume;
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::set_Volume(long Volume/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Volume"), DISPID(6));
  TAutoArgs<1> _args;
  _args[1] = Volume /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::set_AllowAudioOutputFormatChangesOnNextSet(VARIANT_BOOL Allow/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("AllowAudioOutputFormatChangesOnNextSet"), DISPID(7));
  TAutoArgs<1> _args;
  _args[1] = Allow /*[VT_BOOL:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::get_AllowAudioOutputFormatChangesOnNextSet(VARIANT_BOOL* Allow/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("AllowAudioOutputFormatChangesOnNextSet"), DISPID(7));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Allow /*[VT_BOOL:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
ISpeechVoiceDispT<T>::get_AllowAudioOutputFormatChangesOnNextSet(void)
{
  VARIANT_BOOL Allow;
  this->get_AllowAudioOutputFormatChangesOnNextSet((VARIANT_BOOL*)&Allow);
  return Allow;
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::get_EventInterests(Speechlib_tlb::SpeechVoiceEvents* EventInterestFlags/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("EventInterests"), DISPID(8));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)EventInterestFlags /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechVoiceEvents __fastcall
ISpeechVoiceDispT<T>::get_EventInterests(void)
{
  Speechlib_tlb::SpeechVoiceEvents EventInterestFlags;
  this->get_EventInterests((Speechlib_tlb::SpeechVoiceEvents*)&EventInterestFlags);
  return EventInterestFlags;
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::set_EventInterests(Speechlib_tlb::SpeechVoiceEvents EventInterestFlags/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("EventInterests"), DISPID(8));
  TAutoArgs<1> _args;
  _args[1] = (int)EventInterestFlags /*[VT_USERDEFINED:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::set_Priority(Speechlib_tlb::SpeechVoicePriority Priority/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Priority"), DISPID(9));
  TAutoArgs<1> _args;
  _args[1] = (int)Priority /*[VT_USERDEFINED:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::get_Priority(Speechlib_tlb::SpeechVoicePriority* Priority/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Priority"), DISPID(9));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)Priority /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechVoicePriority __fastcall
ISpeechVoiceDispT<T>::get_Priority(void)
{
  Speechlib_tlb::SpeechVoicePriority Priority;
  this->get_Priority((Speechlib_tlb::SpeechVoicePriority*)&Priority);
  return Priority;
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::set_AlertBoundary(Speechlib_tlb::SpeechVoiceEvents Boundary/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("AlertBoundary"), DISPID(10));
  TAutoArgs<1> _args;
  _args[1] = (int)Boundary /*[VT_USERDEFINED:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::get_AlertBoundary(Speechlib_tlb::SpeechVoiceEvents* Boundary/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("AlertBoundary"), DISPID(10));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)Boundary /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechVoiceEvents __fastcall
ISpeechVoiceDispT<T>::get_AlertBoundary(void)
{
  Speechlib_tlb::SpeechVoiceEvents Boundary;
  this->get_AlertBoundary((Speechlib_tlb::SpeechVoiceEvents*)&Boundary);
  return Boundary;
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::set_SynchronousSpeakTimeout(long msTimeout/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("SynchronousSpeakTimeout"), DISPID(11));
  TAutoArgs<1> _args;
  _args[1] = msTimeout /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::get_SynchronousSpeakTimeout(long* msTimeout/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("SynchronousSpeakTimeout"), DISPID(11));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(msTimeout /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechVoiceDispT<T>::get_SynchronousSpeakTimeout(void)
{
  long msTimeout;
  this->get_SynchronousSpeakTimeout((long*)&msTimeout);
  return msTimeout;
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::Speak(BSTR Text/*[in]*/, 
                            Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/, 
                            long* StreamNumber/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Speak"), DISPID(12));
  TAutoArgs<2> _args;
  _args[1] = Text /*[VT_BSTR:0]*/;
  _args[2] = (int)Flags /*[VT_USERDEFINED:0]*/;
  return OutRetValSetterPtr(StreamNumber /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
ISpeechVoiceDispT<T>::Speak(BSTR Text/*[in]*/, 
                            Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/)
{
  long StreamNumber;
  this->Speak(Text, Flags, (long*)&StreamNumber);
  return StreamNumber;
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::SpeakStream(Speechlib_tlb::ISpeechBaseStream* Stream/*[in]*/, 
                                  Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/, 
                                  long* StreamNumber/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("SpeakStream"), DISPID(13));
  TAutoArgs<2> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechBaseStream*)Stream /*[VT_USERDEFINED:1]*/;
  _args[2] = (int)Flags /*[VT_USERDEFINED:0]*/;
  return OutRetValSetterPtr(StreamNumber /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
ISpeechVoiceDispT<T>::SpeakStream(Speechlib_tlb::ISpeechBaseStream* Stream/*[in]*/, 
                                  Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/)
{
  long StreamNumber;
  this->SpeakStream(Stream, Flags, (long*)&StreamNumber);
  return StreamNumber;
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::Pause()
{
  _TDispID _dispid(*this, OLETEXT("Pause"), DISPID(14));
  return OleFunction(_dispid);
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::Resume()
{
  _TDispID _dispid(*this, OLETEXT("Resume"), DISPID(15));
  return OleFunction(_dispid);
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::Skip(BSTR Type/*[in]*/, long NumItems/*[in]*/, 
                           long* NumSkipped/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Skip"), DISPID(16));
  TAutoArgs<2> _args;
  _args[1] = Type /*[VT_BSTR:0]*/;
  _args[2] = NumItems /*[VT_I4:0]*/;
  return OutRetValSetterPtr(NumSkipped /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
ISpeechVoiceDispT<T>::Skip(BSTR Type/*[in]*/, long NumItems/*[in]*/)
{
  long NumSkipped;
  this->Skip(Type, NumItems, (long*)&NumSkipped);
  return NumSkipped;
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::GetVoices(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                BSTR OptionalAttributes/*[in,def,opt]*/, 
                                Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetVoices"), DISPID(17));
  TAutoArgs<2> _args;
  _args[1] = RequiredAttributes /*[VT_BSTR:0]*/;
  _args[2] = OptionalAttributes /*[VT_BSTR:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechObjectTokens**)ObjectTokens /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechObjectTokens* __fastcall
ISpeechVoiceDispT<T>::GetVoices(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                BSTR OptionalAttributes/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechObjectTokens* ObjectTokens;
  this->GetVoices(RequiredAttributes, OptionalAttributes, (Speechlib_tlb::ISpeechObjectTokens**)&ObjectTokens);
  return ObjectTokens;
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::GetAudioOutputs(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                      BSTR OptionalAttributes/*[in,def,opt]*/, 
                                      Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetAudioOutputs"), DISPID(18));
  TAutoArgs<2> _args;
  _args[1] = RequiredAttributes /*[VT_BSTR:0]*/;
  _args[2] = OptionalAttributes /*[VT_BSTR:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechObjectTokens**)ObjectTokens /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechObjectTokens* __fastcall
ISpeechVoiceDispT<T>::GetAudioOutputs(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                      BSTR OptionalAttributes/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechObjectTokens* ObjectTokens;
  this->GetAudioOutputs(RequiredAttributes, OptionalAttributes, (Speechlib_tlb::ISpeechObjectTokens**)&ObjectTokens);
  return ObjectTokens;
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::WaitUntilDone(long msTimeout/*[in]*/, VARIANT_BOOL* Done/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("WaitUntilDone"), DISPID(19));
  TAutoArgs<1> _args;
  _args[1] = msTimeout /*[VT_I4:0]*/;
  return OutRetValSetterPtr(Done /*[VT_BOOL:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
ISpeechVoiceDispT<T>::WaitUntilDone(long msTimeout/*[in]*/)
{
  VARIANT_BOOL Done;
  this->WaitUntilDone(msTimeout, (VARIANT_BOOL*)&Done);
  return Done;
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::SpeakCompleteEvent(long* Handle/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("SpeakCompleteEvent"), DISPID(20));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Handle /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
ISpeechVoiceDispT<T>::SpeakCompleteEvent(void)
{
  long Handle;
  this->SpeakCompleteEvent((long*)&Handle);
  return Handle;
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::IsUISupported(BSTR TypeOfUI/*[in]*/, VARIANT* ExtraData/*[in,def,opt]*/, 
                                    VARIANT_BOOL* Supported/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("IsUISupported"), DISPID(21));
  TAutoArgs<2> _args;
  _args[1] = TypeOfUI /*[VT_BSTR:0]*/;
  _args[2] = ExtraData /*[VT_VARIANT:1]*/;
  return OutRetValSetterPtr(Supported /*[VT_BOOL:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
ISpeechVoiceDispT<T>::IsUISupported(BSTR TypeOfUI/*[in]*/, VARIANT* ExtraData/*[in,def,opt]*/)
{
  VARIANT_BOOL Supported;
  this->IsUISupported(TypeOfUI, ExtraData, (VARIANT_BOOL*)&Supported);
  return Supported;
}

template <class T> HRESULT __fastcall
ISpeechVoiceDispT<T>::DisplayUI(long hWndParent/*[in]*/, BSTR Title/*[in]*/, BSTR TypeOfUI/*[in]*/, 
                                VARIANT* ExtraData/*[in,def,opt]*/)
{
  _TDispID _dispid(*this, OLETEXT("DisplayUI"), DISPID(22));
  TAutoArgs<4> _args;
  _args[1] = hWndParent /*[VT_I4:0]*/;
  _args[2] = Title /*[VT_BSTR:0]*/;
  _args[3] = TypeOfUI /*[VT_BSTR:0]*/;
  _args[4] = ExtraData /*[VT_VARIANT:1]*/;
  return OleFunction(_dispid, _args);
}

// *********************************************************************//
// DispIntf:  ISpeechVoiceStatus
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {8BE47B07-57F6-11D2-9EEE-00C04F797396}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechVoiceStatusDispT<T>::get_CurrentStreamNumber(long* StreamNumber/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("CurrentStreamNumber"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(StreamNumber /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechVoiceStatusDispT<T>::get_CurrentStreamNumber(void)
{
  long StreamNumber;
  this->get_CurrentStreamNumber((long*)&StreamNumber);
  return StreamNumber;
}

template <class T> HRESULT __fastcall
ISpeechVoiceStatusDispT<T>::get_LastStreamNumberQueued(long* StreamNumber/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("LastStreamNumberQueued"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(StreamNumber /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechVoiceStatusDispT<T>::get_LastStreamNumberQueued(void)
{
  long StreamNumber;
  this->get_LastStreamNumberQueued((long*)&StreamNumber);
  return StreamNumber;
}

template <class T> HRESULT __fastcall
ISpeechVoiceStatusDispT<T>::get_LastHResult(long* HResult/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("LastHResult"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(HResult /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechVoiceStatusDispT<T>::get_LastHResult(void)
{
  long HResult;
  this->get_LastHResult((long*)&HResult);
  return HResult;
}

template <class T> HRESULT __fastcall
ISpeechVoiceStatusDispT<T>::get_RunningState(Speechlib_tlb::SpeechRunState* State/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RunningState"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)State /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechRunState __fastcall
ISpeechVoiceStatusDispT<T>::get_RunningState(void)
{
  Speechlib_tlb::SpeechRunState State;
  this->get_RunningState((Speechlib_tlb::SpeechRunState*)&State);
  return State;
}

template <class T> HRESULT __fastcall
ISpeechVoiceStatusDispT<T>::get_InputWordPosition(long* Position/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("InputWordPosition"), DISPID(5));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Position /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechVoiceStatusDispT<T>::get_InputWordPosition(void)
{
  long Position;
  this->get_InputWordPosition((long*)&Position);
  return Position;
}

template <class T> HRESULT __fastcall
ISpeechVoiceStatusDispT<T>::get_InputWordLength(long* Length/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("InputWordLength"), DISPID(6));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Length /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechVoiceStatusDispT<T>::get_InputWordLength(void)
{
  long Length;
  this->get_InputWordLength((long*)&Length);
  return Length;
}

template <class T> HRESULT __fastcall
ISpeechVoiceStatusDispT<T>::get_InputSentencePosition(long* Position/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("InputSentencePosition"), DISPID(7));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Position /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechVoiceStatusDispT<T>::get_InputSentencePosition(void)
{
  long Position;
  this->get_InputSentencePosition((long*)&Position);
  return Position;
}

template <class T> HRESULT __fastcall
ISpeechVoiceStatusDispT<T>::get_InputSentenceLength(long* Length/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("InputSentenceLength"), DISPID(8));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Length /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechVoiceStatusDispT<T>::get_InputSentenceLength(void)
{
  long Length;
  this->get_InputSentenceLength((long*)&Length);
  return Length;
}

template <class T> HRESULT __fastcall
ISpeechVoiceStatusDispT<T>::get_LastBookmark(BSTR* Bookmark/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("LastBookmark"), DISPID(9));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Bookmark /*[VT_BSTR:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechVoiceStatusDispT<T>::get_LastBookmark(void)
{
  BSTR Bookmark;
  this->get_LastBookmark((BSTR*)&Bookmark);
  return Bookmark;
}

template <class T> HRESULT __fastcall
ISpeechVoiceStatusDispT<T>::get_LastBookmarkId(long* BookmarkId/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("LastBookmarkId"), DISPID(10));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(BookmarkId /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechVoiceStatusDispT<T>::get_LastBookmarkId(void)
{
  long BookmarkId;
  this->get_LastBookmarkId((long*)&BookmarkId);
  return BookmarkId;
}

template <class T> HRESULT __fastcall
ISpeechVoiceStatusDispT<T>::get_PhonemeId(short* PhoneId/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("PhonemeId"), DISPID(11));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(PhoneId /*[VT_I2:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> short __fastcall
ISpeechVoiceStatusDispT<T>::get_PhonemeId(void)
{
  short PhoneId;
  this->get_PhonemeId((short*)&PhoneId);
  return PhoneId;
}

template <class T> HRESULT __fastcall
ISpeechVoiceStatusDispT<T>::get_VisemeId(short* VisemeId/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("VisemeId"), DISPID(12));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(VisemeId /*[VT_I2:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> short __fastcall
ISpeechVoiceStatusDispT<T>::get_VisemeId(void)
{
  short VisemeId;
  this->get_VisemeId((short*)&VisemeId);
  return VisemeId;
}

// *********************************************************************//
// DispIntf:  _ISpeechVoiceEvents
// Flags:     (4096) Dispatchable
// GUID:      {A372ACD1-3BEF-4BBD-8FFB-CB3E2B416AF8}
// *********************************************************************//
template <class T> void __fastcall
_ISpeechVoiceEventsDispT<T>::StartStream(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/)
{
  _TDispID _dispid(/* StartStream */ DISPID(1));
  TAutoArgs<2> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechVoiceEventsDispT<T>::EndStream(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/)
{
  _TDispID _dispid(/* EndStream */ DISPID(2));
  TAutoArgs<2> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechVoiceEventsDispT<T>::VoiceChange(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                         Speechlib_tlb::ISpeechObjectToken* VoiceObjectToken/*[in]*/)
{
  _TDispID _dispid(/* VoiceChange */ DISPID(3));
  TAutoArgs<3> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  _args[3] = (LPDISPATCH)(Speechlib_tlb::ISpeechObjectToken*)VoiceObjectToken /*[VT_USERDEFINED:1]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechVoiceEventsDispT<T>::Bookmark(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                      BSTR Bookmark/*[in]*/, long BookmarkId/*[in]*/)
{
  _TDispID _dispid(/* Bookmark */ DISPID(4));
  TAutoArgs<4> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  _args[3] = Bookmark /*[VT_BSTR:0]*/;
  _args[4] = BookmarkId /*[VT_I4:0]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechVoiceEventsDispT<T>::Word(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                  long CharacterPosition/*[in]*/, long Length/*[in]*/)
{
  _TDispID _dispid(/* Word */ DISPID(5));
  TAutoArgs<4> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  _args[3] = CharacterPosition /*[VT_I4:0]*/;
  _args[4] = Length /*[VT_I4:0]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechVoiceEventsDispT<T>::Sentence(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                      long CharacterPosition/*[in]*/, long Length/*[in]*/)
{
  _TDispID _dispid(/* Sentence */ DISPID(7));
  TAutoArgs<4> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  _args[3] = CharacterPosition /*[VT_I4:0]*/;
  _args[4] = Length /*[VT_I4:0]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechVoiceEventsDispT<T>::Phoneme(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                     long Duration/*[in]*/, short NextPhoneId/*[in]*/, 
                                     Speechlib_tlb::SpeechVisemeFeature Feature/*[in]*/, 
                                     short CurrentPhoneId/*[in]*/)
{
  _TDispID _dispid(/* Phoneme */ DISPID(6));
  TAutoArgs<6> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  _args[3] = Duration /*[VT_I4:0]*/;
  _args[4] = NextPhoneId /*[VT_I2:0]*/;
  _args[5] = (int)Feature /*[VT_USERDEFINED:0]*/;
  _args[6] = CurrentPhoneId /*[VT_I2:0]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechVoiceEventsDispT<T>::Viseme(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                    long Duration/*[in]*/, 
                                    Speechlib_tlb::SpeechVisemeType NextVisemeId/*[in]*/, 
                                    Speechlib_tlb::SpeechVisemeFeature Feature/*[in]*/, 
                                    Speechlib_tlb::SpeechVisemeType CurrentVisemeId/*[in]*/)
{
  _TDispID _dispid(/* Viseme */ DISPID(8));
  TAutoArgs<6> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  _args[3] = Duration /*[VT_I4:0]*/;
  _args[4] = (int)NextVisemeId /*[VT_USERDEFINED:0]*/;
  _args[5] = (int)Feature /*[VT_USERDEFINED:0]*/;
  _args[6] = (int)CurrentVisemeId /*[VT_USERDEFINED:0]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechVoiceEventsDispT<T>::AudioLevel(long StreamNumber/*[in]*/, VARIANT StreamPosition/*[in]*/, 
                                        long AudioLevel/*[in]*/)
{
  _TDispID _dispid(/* AudioLevel */ DISPID(9));
  TAutoArgs<3> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  _args[3] = AudioLevel /*[VT_I4:0]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechVoiceEventsDispT<T>::EnginePrivate(long StreamNumber/*[in]*/, long StreamPosition/*[in]*/, 
                                           VARIANT EngineData/*[in]*/)
{
  _TDispID _dispid(/* EnginePrivate */ DISPID(10));
  TAutoArgs<3> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_I4:0]*/;
  _args[3] = EngineData /*[VT_VARIANT:0]*/;
  OleProcedure(_dispid, _args);
}

// *********************************************************************//
// SmartIntf: TCOMISpeechRecognizer
// Interface: ISpeechRecognizer
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::_set_Recognizer(Speechlib_tlb::ISpeechObjectToken* Recognizer/*[in]*/)
{
  return (*this)->_set_Recognizer(Recognizer);
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::get_Recognizer(Speechlib_tlb::ISpeechObjectToken** Recognizer/*[out,retval]*/)
{
  return (*this)->get_Recognizer(Recognizer);
}

template <class T> Speechlib_tlb::ISpeechObjectTokenPtr __fastcall
TCOMISpeechRecognizerT<T>::get_Recognizer(void)
{
  Speechlib_tlb::ISpeechObjectTokenPtr Recognizer;
  OLECHECK(this->get_Recognizer((Speechlib_tlb::ISpeechObjectTokenPtr*)&Recognizer));
  return Recognizer;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::set_AllowAudioInputFormatChangesOnNextSet(VARIANT_BOOL Allow/*[in]*/)
{
  return (*this)->set_AllowAudioInputFormatChangesOnNextSet(Allow);
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::get_AllowAudioInputFormatChangesOnNextSet(VARIANT_BOOL* Allow/*[out,retval]*/)
{
  return (*this)->get_AllowAudioInputFormatChangesOnNextSet(Allow);
}

template <class T> VARIANT_BOOL __fastcall
TCOMISpeechRecognizerT<T>::get_AllowAudioInputFormatChangesOnNextSet(void)
{
  VARIANT_BOOL Allow;
  OLECHECK(this->get_AllowAudioInputFormatChangesOnNextSet((VARIANT_BOOL*)&Allow));
  return Allow;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::_set_AudioInput(Speechlib_tlb::ISpeechObjectToken* AudioInput/*[in,def,opt]*/)
{
  return (*this)->_set_AudioInput(AudioInput);
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::get_AudioInput(Speechlib_tlb::ISpeechObjectToken** AudioInput/*[out,retval]*/)
{
  return (*this)->get_AudioInput(AudioInput);
}

template <class T> Speechlib_tlb::ISpeechObjectTokenPtr __fastcall
TCOMISpeechRecognizerT<T>::get_AudioInput(void)
{
  Speechlib_tlb::ISpeechObjectTokenPtr AudioInput;
  OLECHECK(this->get_AudioInput((Speechlib_tlb::ISpeechObjectTokenPtr*)&AudioInput));
  return AudioInput;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::_set_AudioInputStream(Speechlib_tlb::ISpeechBaseStream* AudioInputStream/*[in,def,opt]*/)
{
  return (*this)->_set_AudioInputStream(AudioInputStream);
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::get_AudioInputStream(Speechlib_tlb::ISpeechBaseStream** AudioInputStream/*[out,retval]*/)
{
  return (*this)->get_AudioInputStream(AudioInputStream);
}

template <class T> Speechlib_tlb::ISpeechBaseStreamPtr __fastcall
TCOMISpeechRecognizerT<T>::get_AudioInputStream(void)
{
  Speechlib_tlb::ISpeechBaseStreamPtr AudioInputStream;
  OLECHECK(this->get_AudioInputStream((Speechlib_tlb::ISpeechBaseStreamPtr*)&AudioInputStream));
  return AudioInputStream;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::get_IsShared(VARIANT_BOOL* Shared/*[out,retval]*/)
{
  return (*this)->get_IsShared(Shared);
}

template <class T> VARIANT_BOOL __fastcall
TCOMISpeechRecognizerT<T>::get_IsShared(void)
{
  VARIANT_BOOL Shared;
  OLECHECK(this->get_IsShared((VARIANT_BOOL*)&Shared));
  return Shared;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::set_State(Speechlib_tlb::SpeechRecognizerState State/*[in]*/)
{
  return (*this)->set_State(State);
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::get_State(Speechlib_tlb::SpeechRecognizerState* State/*[out,retval]*/)
{
  return (*this)->get_State(State);
}

template <class T> Speechlib_tlb::SpeechRecognizerState __fastcall
TCOMISpeechRecognizerT<T>::get_State(void)
{
  Speechlib_tlb::SpeechRecognizerState State;
  OLECHECK(this->get_State((Speechlib_tlb::SpeechRecognizerState*)&State));
  return State;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::get_Status(Speechlib_tlb::ISpeechRecognizerStatus** Status/*[out,retval]*/)
{
  return (*this)->get_Status(Status);
}

template <class T> Speechlib_tlb::ISpeechRecognizerStatusPtr __fastcall
TCOMISpeechRecognizerT<T>::get_Status(void)
{
  Speechlib_tlb::ISpeechRecognizerStatusPtr Status;
  OLECHECK(this->get_Status((Speechlib_tlb::ISpeechRecognizerStatusPtr*)&Status));
  return Status;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::_set_Profile(Speechlib_tlb::ISpeechObjectToken* Profile/*[in,def,opt]*/)
{
  return (*this)->_set_Profile(Profile);
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::get_Profile(Speechlib_tlb::ISpeechObjectToken** Profile/*[out,retval]*/)
{
  return (*this)->get_Profile(Profile);
}

template <class T> Speechlib_tlb::ISpeechObjectTokenPtr __fastcall
TCOMISpeechRecognizerT<T>::get_Profile(void)
{
  Speechlib_tlb::ISpeechObjectTokenPtr Profile;
  OLECHECK(this->get_Profile((Speechlib_tlb::ISpeechObjectTokenPtr*)&Profile));
  return Profile;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::EmulateRecognition(VARIANT TextElements/*[in]*/, 
                                              VARIANT* ElementDisplayAttributes/*[in,def,opt]*/, 
                                              long LanguageId/*[in,def,opt]*/)
{
  return (*this)->EmulateRecognition(TextElements, ElementDisplayAttributes, LanguageId);
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::CreateRecoContext(Speechlib_tlb::ISpeechRecoContext** NewContext/*[out,retval]*/)
{
  return (*this)->CreateRecoContext(NewContext);
}

template <class T> Speechlib_tlb::ISpeechRecoContext* __fastcall
TCOMISpeechRecognizerT<T>::CreateRecoContext(void)
{
  Speechlib_tlb::ISpeechRecoContext* NewContext;
  OLECHECK(this->CreateRecoContext((Speechlib_tlb::ISpeechRecoContext**)&NewContext));
  return NewContext;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::GetFormat(Speechlib_tlb::SpeechFormatType Type/*[in]*/, 
                                     Speechlib_tlb::ISpeechAudioFormat** Format/*[out,retval]*/)
{
  return (*this)->GetFormat(Type, Format);
}

template <class T> Speechlib_tlb::ISpeechAudioFormat* __fastcall
TCOMISpeechRecognizerT<T>::GetFormat(Speechlib_tlb::SpeechFormatType Type/*[in]*/)
{
  Speechlib_tlb::ISpeechAudioFormat* Format;
  OLECHECK(this->GetFormat(Type/*[in]*/, (Speechlib_tlb::ISpeechAudioFormat**)&Format));
  return Format;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::SetPropertyNumber(BSTR Name/*[in]*/, long Value/*[in]*/, 
                                             VARIANT_BOOL* Supported/*[out,retval]*/)
{
  return (*this)->SetPropertyNumber(Name, Value, Supported);
}

template <class T> VARIANT_BOOL __fastcall
TCOMISpeechRecognizerT<T>::SetPropertyNumber(BSTR Name/*[in]*/, long Value/*[in]*/)
{
  VARIANT_BOOL Supported;
  OLECHECK(this->SetPropertyNumber(Name/*[in]*/, Value/*[in]*/, (VARIANT_BOOL*)&Supported));
  return Supported;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::GetPropertyNumber(BSTR Name/*[in]*/, long* Value/*[in,out]*/, 
                                             VARIANT_BOOL* Supported/*[out,retval]*/)
{
  return (*this)->GetPropertyNumber(Name, Value, Supported);
}

template <class T> VARIANT_BOOL __fastcall
TCOMISpeechRecognizerT<T>::GetPropertyNumber(BSTR Name/*[in]*/, long* Value/*[in,out]*/)
{
  VARIANT_BOOL Supported;
  OLECHECK(this->GetPropertyNumber(Name/*[in]*/, Value/*[in,out]*/, (VARIANT_BOOL*)&Supported));
  return Supported;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::SetPropertyString(BSTR Name/*[in]*/, BSTR Value/*[in]*/, 
                                             VARIANT_BOOL* Supported/*[out,retval]*/)
{
  return (*this)->SetPropertyString(Name, Value, Supported);
}

template <class T> VARIANT_BOOL __fastcall
TCOMISpeechRecognizerT<T>::SetPropertyString(BSTR Name/*[in]*/, BSTR Value/*[in]*/)
{
  VARIANT_BOOL Supported;
  OLECHECK(this->SetPropertyString(Name/*[in]*/, Value/*[in]*/, (VARIANT_BOOL*)&Supported));
  return Supported;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::GetPropertyString(BSTR Name/*[in]*/, BSTR* Value/*[in,out]*/, 
                                             VARIANT_BOOL* Supported/*[out,retval]*/)
{
  return (*this)->GetPropertyString(Name, Value, Supported);
}

template <class T> VARIANT_BOOL __fastcall
TCOMISpeechRecognizerT<T>::GetPropertyString(BSTR Name/*[in]*/, BSTR* Value/*[in,out]*/)
{
  VARIANT_BOOL Supported;
  OLECHECK(this->GetPropertyString(Name/*[in]*/, Value/*[in,out]*/, (VARIANT_BOOL*)&Supported));
  return Supported;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::IsUISupported(BSTR TypeOfUI/*[in]*/, VARIANT* ExtraData/*[in,def,opt]*/, 
                                         VARIANT_BOOL* Supported/*[out,retval]*/)
{
  return (*this)->IsUISupported(TypeOfUI, ExtraData, Supported);
}

template <class T> VARIANT_BOOL __fastcall
TCOMISpeechRecognizerT<T>::IsUISupported(BSTR TypeOfUI/*[in]*/, VARIANT* ExtraData/*[in,def,opt]*/)
{
  VARIANT_BOOL Supported;
  OLECHECK(this->IsUISupported(TypeOfUI/*[in]*/, ExtraData/*[in,def,opt]*/, (VARIANT_BOOL*)&Supported));
  return Supported;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::DisplayUI(long hWndParent/*[in]*/, BSTR Title/*[in]*/, 
                                     BSTR TypeOfUI/*[in]*/, VARIANT* ExtraData/*[in,def,opt]*/)
{
  return (*this)->DisplayUI(hWndParent, Title, TypeOfUI, ExtraData);
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::GetRecognizers(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                          BSTR OptionalAttributes/*[in,def,opt]*/, 
                                          Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/)
{
  return (*this)->GetRecognizers(RequiredAttributes, OptionalAttributes, ObjectTokens);
}

template <class T> Speechlib_tlb::ISpeechObjectTokens* __fastcall
TCOMISpeechRecognizerT<T>::GetRecognizers(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                          BSTR OptionalAttributes/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechObjectTokens* ObjectTokens;
  OLECHECK(this->GetRecognizers(RequiredAttributes/*[in,def,opt]*/, 
                                OptionalAttributes/*[in,def,opt]*/, (Speechlib_tlb::ISpeechObjectTokens**)&ObjectTokens));
  return ObjectTokens;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::GetAudioInputs(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                          BSTR OptionalAttributes/*[in,def,opt]*/, 
                                          Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/)
{
  return (*this)->GetAudioInputs(RequiredAttributes, OptionalAttributes, ObjectTokens);
}

template <class T> Speechlib_tlb::ISpeechObjectTokens* __fastcall
TCOMISpeechRecognizerT<T>::GetAudioInputs(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                          BSTR OptionalAttributes/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechObjectTokens* ObjectTokens;
  OLECHECK(this->GetAudioInputs(RequiredAttributes/*[in,def,opt]*/, 
                                OptionalAttributes/*[in,def,opt]*/, (Speechlib_tlb::ISpeechObjectTokens**)&ObjectTokens));
  return ObjectTokens;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecognizerT<T>::GetProfiles(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                       BSTR OptionalAttributes/*[in,def,opt]*/, 
                                       Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/)
{
  return (*this)->GetProfiles(RequiredAttributes, OptionalAttributes, ObjectTokens);
}

template <class T> Speechlib_tlb::ISpeechObjectTokens* __fastcall
TCOMISpeechRecognizerT<T>::GetProfiles(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                       BSTR OptionalAttributes/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechObjectTokens* ObjectTokens;
  OLECHECK(this->GetProfiles(RequiredAttributes/*[in,def,opt]*/, OptionalAttributes/*[in,def,opt]*/, (Speechlib_tlb::ISpeechObjectTokens**)&ObjectTokens));
  return ObjectTokens;
}

// *********************************************************************//
// DispIntf:  ISpeechRecognizer
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {2D5F1C0C-BD75-4B08-9478-3B11FEA2586C}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::_set_Recognizer(Speechlib_tlb::ISpeechObjectToken* Recognizer/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Recognizer"), DISPID(1));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechObjectToken*)Recognizer /*[VT_USERDEFINED:1]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::get_Recognizer(Speechlib_tlb::ISpeechObjectToken** Recognizer/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Recognizer"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechObjectToken**)Recognizer /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechObjectTokenPtr __fastcall
ISpeechRecognizerDispT<T>::get_Recognizer(void)
{
  Speechlib_tlb::ISpeechObjectTokenPtr Recognizer;
  this->get_Recognizer(&Recognizer);
  return Recognizer;
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::set_AllowAudioInputFormatChangesOnNextSet(VARIANT_BOOL Allow/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("AllowAudioInputFormatChangesOnNextSet"), DISPID(2));
  TAutoArgs<1> _args;
  _args[1] = Allow /*[VT_BOOL:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::get_AllowAudioInputFormatChangesOnNextSet(VARIANT_BOOL* Allow/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("AllowAudioInputFormatChangesOnNextSet"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Allow /*[VT_BOOL:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
ISpeechRecognizerDispT<T>::get_AllowAudioInputFormatChangesOnNextSet(void)
{
  VARIANT_BOOL Allow;
  this->get_AllowAudioInputFormatChangesOnNextSet((VARIANT_BOOL*)&Allow);
  return Allow;
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::_set_AudioInput(Speechlib_tlb::ISpeechObjectToken* AudioInput/*[in,def,opt]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioInput"), DISPID(3));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechObjectToken*)AudioInput /*[VT_USERDEFINED:1]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::get_AudioInput(Speechlib_tlb::ISpeechObjectToken** AudioInput/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioInput"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechObjectToken**)AudioInput /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechObjectTokenPtr __fastcall
ISpeechRecognizerDispT<T>::get_AudioInput(void)
{
  Speechlib_tlb::ISpeechObjectTokenPtr AudioInput;
  this->get_AudioInput(&AudioInput);
  return AudioInput;
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::_set_AudioInputStream(Speechlib_tlb::ISpeechBaseStream* AudioInputStream/*[in,def,opt]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioInputStream"), DISPID(4));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechBaseStream*)AudioInputStream /*[VT_USERDEFINED:1]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::get_AudioInputStream(Speechlib_tlb::ISpeechBaseStream** AudioInputStream/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioInputStream"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechBaseStream**)AudioInputStream /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechBaseStreamPtr __fastcall
ISpeechRecognizerDispT<T>::get_AudioInputStream(void)
{
  Speechlib_tlb::ISpeechBaseStreamPtr AudioInputStream;
  this->get_AudioInputStream(&AudioInputStream);
  return AudioInputStream;
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::get_IsShared(VARIANT_BOOL* Shared/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("IsShared"), DISPID(5));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Shared /*[VT_BOOL:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
ISpeechRecognizerDispT<T>::get_IsShared(void)
{
  VARIANT_BOOL Shared;
  this->get_IsShared((VARIANT_BOOL*)&Shared);
  return Shared;
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::set_State(Speechlib_tlb::SpeechRecognizerState State/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("State"), DISPID(6));
  TAutoArgs<1> _args;
  _args[1] = (int)State /*[VT_USERDEFINED:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::get_State(Speechlib_tlb::SpeechRecognizerState* State/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("State"), DISPID(6));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)State /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechRecognizerState __fastcall
ISpeechRecognizerDispT<T>::get_State(void)
{
  Speechlib_tlb::SpeechRecognizerState State;
  this->get_State((Speechlib_tlb::SpeechRecognizerState*)&State);
  return State;
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::get_Status(Speechlib_tlb::ISpeechRecognizerStatus** Status/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Status"), DISPID(7));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechRecognizerStatus**)Status /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechRecognizerStatusPtr __fastcall
ISpeechRecognizerDispT<T>::get_Status(void)
{
  Speechlib_tlb::ISpeechRecognizerStatusPtr Status;
  this->get_Status(&Status);
  return Status;
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::_set_Profile(Speechlib_tlb::ISpeechObjectToken* Profile/*[in,def,opt]*/)
{
  _TDispID _dispid(*this, OLETEXT("Profile"), DISPID(8));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechObjectToken*)Profile /*[VT_USERDEFINED:1]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::get_Profile(Speechlib_tlb::ISpeechObjectToken** Profile/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Profile"), DISPID(8));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechObjectToken**)Profile /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechObjectTokenPtr __fastcall
ISpeechRecognizerDispT<T>::get_Profile(void)
{
  Speechlib_tlb::ISpeechObjectTokenPtr Profile;
  this->get_Profile(&Profile);
  return Profile;
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::EmulateRecognition(VARIANT TextElements/*[in]*/, 
                                              VARIANT* ElementDisplayAttributes/*[in,def,opt]*/, 
                                              long LanguageId/*[in,def,opt]*/)
{
  _TDispID _dispid(*this, OLETEXT("EmulateRecognition"), DISPID(9));
  TAutoArgs<3> _args;
  _args[1] = TextElements /*[VT_VARIANT:0]*/;
  _args[2] = ElementDisplayAttributes /*[VT_VARIANT:1]*/;
  _args[3] = LanguageId /*[VT_I4:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::CreateRecoContext(Speechlib_tlb::ISpeechRecoContext** NewContext/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("CreateRecoContext"), DISPID(10));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechRecoContext**)NewContext /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechRecoContext* __fastcall
ISpeechRecognizerDispT<T>::CreateRecoContext(void)
{
  Speechlib_tlb::ISpeechRecoContext* NewContext;
  this->CreateRecoContext((Speechlib_tlb::ISpeechRecoContext**)&NewContext);
  return NewContext;
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::GetFormat(Speechlib_tlb::SpeechFormatType Type/*[in]*/, 
                                     Speechlib_tlb::ISpeechAudioFormat** Format/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetFormat"), DISPID(11));
  TAutoArgs<1> _args;
  _args[1] = (int)Type /*[VT_USERDEFINED:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechAudioFormat**)Format /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechAudioFormat* __fastcall
ISpeechRecognizerDispT<T>::GetFormat(Speechlib_tlb::SpeechFormatType Type/*[in]*/)
{
  Speechlib_tlb::ISpeechAudioFormat* Format;
  this->GetFormat(Type, (Speechlib_tlb::ISpeechAudioFormat**)&Format);
  return Format;
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::SetPropertyNumber(BSTR Name/*[in]*/, long Value/*[in]*/, 
                                             VARIANT_BOOL* Supported/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("SetPropertyNumber"), DISPID(12));
  TAutoArgs<2> _args;
  _args[1] = Name /*[VT_BSTR:0]*/;
  _args[2] = Value /*[VT_I4:0]*/;
  return OutRetValSetterPtr(Supported /*[VT_BOOL:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
ISpeechRecognizerDispT<T>::SetPropertyNumber(BSTR Name/*[in]*/, long Value/*[in]*/)
{
  VARIANT_BOOL Supported;
  this->SetPropertyNumber(Name, Value, (VARIANT_BOOL*)&Supported);
  return Supported;
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::GetPropertyNumber(BSTR Name/*[in]*/, long* Value/*[in,out]*/, 
                                             VARIANT_BOOL* Supported/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetPropertyNumber"), DISPID(13));
  TAutoArgs<2> _args;
  _args[1] = Name /*[VT_BSTR:0]*/;
  _args[2] = Value /*[VT_I4:1]*/;
  return OutRetValSetterPtr(Supported /*[VT_BOOL:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
ISpeechRecognizerDispT<T>::GetPropertyNumber(BSTR Name/*[in]*/, long* Value/*[in,out]*/)
{
  VARIANT_BOOL Supported;
  this->GetPropertyNumber(Name, Value, (VARIANT_BOOL*)&Supported);
  return Supported;
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::SetPropertyString(BSTR Name/*[in]*/, BSTR Value/*[in]*/, 
                                             VARIANT_BOOL* Supported/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("SetPropertyString"), DISPID(14));
  TAutoArgs<2> _args;
  _args[1] = Name /*[VT_BSTR:0]*/;
  _args[2] = Value /*[VT_BSTR:0]*/;
  return OutRetValSetterPtr(Supported /*[VT_BOOL:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
ISpeechRecognizerDispT<T>::SetPropertyString(BSTR Name/*[in]*/, BSTR Value/*[in]*/)
{
  VARIANT_BOOL Supported;
  this->SetPropertyString(Name, Value, (VARIANT_BOOL*)&Supported);
  return Supported;
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::GetPropertyString(BSTR Name/*[in]*/, BSTR* Value/*[in,out]*/, 
                                             VARIANT_BOOL* Supported/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetPropertyString"), DISPID(15));
  TAutoArgs<2> _args;
  _args[1] = Name /*[VT_BSTR:0]*/;
  _args[2] = Value /*[VT_BSTR:1]*/;
  return OutRetValSetterPtr(Supported /*[VT_BOOL:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
ISpeechRecognizerDispT<T>::GetPropertyString(BSTR Name/*[in]*/, BSTR* Value/*[in,out]*/)
{
  VARIANT_BOOL Supported;
  this->GetPropertyString(Name, Value, (VARIANT_BOOL*)&Supported);
  return Supported;
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::IsUISupported(BSTR TypeOfUI/*[in]*/, VARIANT* ExtraData/*[in,def,opt]*/, 
                                         VARIANT_BOOL* Supported/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("IsUISupported"), DISPID(16));
  TAutoArgs<2> _args;
  _args[1] = TypeOfUI /*[VT_BSTR:0]*/;
  _args[2] = ExtraData /*[VT_VARIANT:1]*/;
  return OutRetValSetterPtr(Supported /*[VT_BOOL:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
ISpeechRecognizerDispT<T>::IsUISupported(BSTR TypeOfUI/*[in]*/, VARIANT* ExtraData/*[in,def,opt]*/)
{
  VARIANT_BOOL Supported;
  this->IsUISupported(TypeOfUI, ExtraData, (VARIANT_BOOL*)&Supported);
  return Supported;
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::DisplayUI(long hWndParent/*[in]*/, BSTR Title/*[in]*/, 
                                     BSTR TypeOfUI/*[in]*/, VARIANT* ExtraData/*[in,def,opt]*/)
{
  _TDispID _dispid(*this, OLETEXT("DisplayUI"), DISPID(17));
  TAutoArgs<4> _args;
  _args[1] = hWndParent /*[VT_I4:0]*/;
  _args[2] = Title /*[VT_BSTR:0]*/;
  _args[3] = TypeOfUI /*[VT_BSTR:0]*/;
  _args[4] = ExtraData /*[VT_VARIANT:1]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::GetRecognizers(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                          BSTR OptionalAttributes/*[in,def,opt]*/, 
                                          Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetRecognizers"), DISPID(18));
  TAutoArgs<2> _args;
  _args[1] = RequiredAttributes /*[VT_BSTR:0]*/;
  _args[2] = OptionalAttributes /*[VT_BSTR:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechObjectTokens**)ObjectTokens /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechObjectTokens* __fastcall
ISpeechRecognizerDispT<T>::GetRecognizers(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                          BSTR OptionalAttributes/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechObjectTokens* ObjectTokens;
  this->GetRecognizers(RequiredAttributes, OptionalAttributes, (Speechlib_tlb::ISpeechObjectTokens**)&ObjectTokens);
  return ObjectTokens;
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::GetAudioInputs(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                          BSTR OptionalAttributes/*[in,def,opt]*/, 
                                          Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetAudioInputs"), DISPID(19));
  TAutoArgs<2> _args;
  _args[1] = RequiredAttributes /*[VT_BSTR:0]*/;
  _args[2] = OptionalAttributes /*[VT_BSTR:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechObjectTokens**)ObjectTokens /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechObjectTokens* __fastcall
ISpeechRecognizerDispT<T>::GetAudioInputs(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                          BSTR OptionalAttributes/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechObjectTokens* ObjectTokens;
  this->GetAudioInputs(RequiredAttributes, OptionalAttributes, (Speechlib_tlb::ISpeechObjectTokens**)&ObjectTokens);
  return ObjectTokens;
}

template <class T> HRESULT __fastcall
ISpeechRecognizerDispT<T>::GetProfiles(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                       BSTR OptionalAttributes/*[in,def,opt]*/, 
                                       Speechlib_tlb::ISpeechObjectTokens** ObjectTokens/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetProfiles"), DISPID(20));
  TAutoArgs<2> _args;
  _args[1] = RequiredAttributes /*[VT_BSTR:0]*/;
  _args[2] = OptionalAttributes /*[VT_BSTR:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechObjectTokens**)ObjectTokens /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechObjectTokens* __fastcall
ISpeechRecognizerDispT<T>::GetProfiles(BSTR RequiredAttributes/*[in,def,opt]*/, 
                                       BSTR OptionalAttributes/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechObjectTokens* ObjectTokens;
  this->GetProfiles(RequiredAttributes, OptionalAttributes, (Speechlib_tlb::ISpeechObjectTokens**)&ObjectTokens);
  return ObjectTokens;
}

// *********************************************************************//
// DispIntf:  ISpeechRecognizerStatus
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {BFF9E781-53EC-484E-BB8A-0E1B5551E35C}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechRecognizerStatusDispT<T>::get_AudioStatus(Speechlib_tlb::ISpeechAudioStatus** AudioStatus/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioStatus"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechAudioStatus**)AudioStatus /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechAudioStatusPtr __fastcall
ISpeechRecognizerStatusDispT<T>::get_AudioStatus(void)
{
  Speechlib_tlb::ISpeechAudioStatusPtr AudioStatus;
  this->get_AudioStatus(&AudioStatus);
  return AudioStatus;
}

template <class T> HRESULT __fastcall
ISpeechRecognizerStatusDispT<T>::get_CurrentStreamPosition(VARIANT* pCurrentStreamPos/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("CurrentStreamPosition"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pCurrentStreamPos /*[VT_VARIANT:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechRecognizerStatusDispT<T>::get_CurrentStreamPosition(void)
{
  VARIANT pCurrentStreamPos;
  this->get_CurrentStreamPosition((VARIANT*)&pCurrentStreamPos);
  return pCurrentStreamPos;
}

template <class T> HRESULT __fastcall
ISpeechRecognizerStatusDispT<T>::get_CurrentStreamNumber(long* StreamNumber/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("CurrentStreamNumber"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(StreamNumber /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechRecognizerStatusDispT<T>::get_CurrentStreamNumber(void)
{
  long StreamNumber;
  this->get_CurrentStreamNumber((long*)&StreamNumber);
  return StreamNumber;
}

template <class T> HRESULT __fastcall
ISpeechRecognizerStatusDispT<T>::get_NumberOfActiveRules(long* NumberOfActiveRules/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("NumberOfActiveRules"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(NumberOfActiveRules /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechRecognizerStatusDispT<T>::get_NumberOfActiveRules(void)
{
  long NumberOfActiveRules;
  this->get_NumberOfActiveRules((long*)&NumberOfActiveRules);
  return NumberOfActiveRules;
}

template <class T> HRESULT __fastcall
ISpeechRecognizerStatusDispT<T>::get_ClsidEngine(BSTR* ClsidEngine/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("ClsidEngine"), DISPID(5));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(ClsidEngine /*[VT_BSTR:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechRecognizerStatusDispT<T>::get_ClsidEngine(void)
{
  BSTR ClsidEngine;
  this->get_ClsidEngine((BSTR*)&ClsidEngine);
  return ClsidEngine;
}

template <class T> HRESULT __fastcall
ISpeechRecognizerStatusDispT<T>::get_SupportedLanguages(VARIANT* SupportedLanguages/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("SupportedLanguages"), DISPID(6));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(SupportedLanguages /*[VT_VARIANT:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechRecognizerStatusDispT<T>::get_SupportedLanguages(void)
{
  VARIANT SupportedLanguages;
  this->get_SupportedLanguages((VARIANT*)&SupportedLanguages);
  return SupportedLanguages;
}

// *********************************************************************//
// SmartIntf: TCOMISpeechRecoContext
// Interface: ISpeechRecoContext
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::get_Recognizer(Speechlib_tlb::ISpeechRecognizer** Recognizer/*[out,retval]*/)
{
  return (*this)->get_Recognizer(Recognizer);
}

template <class T> Speechlib_tlb::ISpeechRecognizerPtr __fastcall
TCOMISpeechRecoContextT<T>::get_Recognizer(void)
{
  Speechlib_tlb::ISpeechRecognizerPtr Recognizer;
  OLECHECK(this->get_Recognizer((Speechlib_tlb::ISpeechRecognizerPtr*)&Recognizer));
  return Recognizer;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::get_AudioInputInterferenceStatus(Speechlib_tlb::SpeechInterference* Interference/*[out,retval]*/)
{
  return (*this)->get_AudioInputInterferenceStatus(Interference);
}

template <class T> Speechlib_tlb::SpeechInterference __fastcall
TCOMISpeechRecoContextT<T>::get_AudioInputInterferenceStatus(void)
{
  Speechlib_tlb::SpeechInterference Interference;
  OLECHECK(this->get_AudioInputInterferenceStatus((Speechlib_tlb::SpeechInterference*)&Interference));
  return Interference;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::get_RequestedUIType(BSTR* UIType/*[out,retval]*/)
{
  return (*this)->get_RequestedUIType(UIType);
}

template <class T> BSTR __fastcall
TCOMISpeechRecoContextT<T>::get_RequestedUIType(void)
{
  BSTR UIType = 0;
  OLECHECK(this->get_RequestedUIType((BSTR*)&UIType));
  return UIType;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::_set_Voice(Speechlib_tlb::ISpeechVoice* Voice/*[in]*/)
{
  return (*this)->_set_Voice(Voice);
}

template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::get_Voice(Speechlib_tlb::ISpeechVoice** Voice/*[out,retval]*/)
{
  return (*this)->get_Voice(Voice);
}

template <class T> Speechlib_tlb::ISpeechVoicePtr __fastcall
TCOMISpeechRecoContextT<T>::get_Voice(void)
{
  Speechlib_tlb::ISpeechVoicePtr Voice;
  OLECHECK(this->get_Voice((Speechlib_tlb::ISpeechVoicePtr*)&Voice));
  return Voice;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::set_AllowVoiceFormatMatchingOnNextSet(VARIANT_BOOL pAllow/*[in]*/)
{
  return (*this)->set_AllowVoiceFormatMatchingOnNextSet(pAllow);
}

template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::get_AllowVoiceFormatMatchingOnNextSet(VARIANT_BOOL* pAllow/*[out,retval]*/)
{
  return (*this)->get_AllowVoiceFormatMatchingOnNextSet(pAllow);
}

template <class T> VARIANT_BOOL __fastcall
TCOMISpeechRecoContextT<T>::get_AllowVoiceFormatMatchingOnNextSet(void)
{
  VARIANT_BOOL pAllow;
  OLECHECK(this->get_AllowVoiceFormatMatchingOnNextSet((VARIANT_BOOL*)&pAllow));
  return pAllow;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::set_VoicePurgeEvent(Speechlib_tlb::SpeechRecoEvents EventInterest/*[in]*/)
{
  return (*this)->set_VoicePurgeEvent(EventInterest);
}

template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::get_VoicePurgeEvent(Speechlib_tlb::SpeechRecoEvents* EventInterest/*[out,retval]*/)
{
  return (*this)->get_VoicePurgeEvent(EventInterest);
}

template <class T> Speechlib_tlb::SpeechRecoEvents __fastcall
TCOMISpeechRecoContextT<T>::get_VoicePurgeEvent(void)
{
  Speechlib_tlb::SpeechRecoEvents EventInterest;
  OLECHECK(this->get_VoicePurgeEvent((Speechlib_tlb::SpeechRecoEvents*)&EventInterest));
  return EventInterest;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::set_EventInterests(Speechlib_tlb::SpeechRecoEvents EventInterest/*[in]*/)
{
  return (*this)->set_EventInterests(EventInterest);
}

template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::get_EventInterests(Speechlib_tlb::SpeechRecoEvents* EventInterest/*[out,retval]*/)
{
  return (*this)->get_EventInterests(EventInterest);
}

template <class T> Speechlib_tlb::SpeechRecoEvents __fastcall
TCOMISpeechRecoContextT<T>::get_EventInterests(void)
{
  Speechlib_tlb::SpeechRecoEvents EventInterest;
  OLECHECK(this->get_EventInterests((Speechlib_tlb::SpeechRecoEvents*)&EventInterest));
  return EventInterest;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::set_CmdMaxAlternates(long MaxAlternates/*[in]*/)
{
  return (*this)->set_CmdMaxAlternates(MaxAlternates);
}

template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::get_CmdMaxAlternates(long* MaxAlternates/*[out,retval]*/)
{
  return (*this)->get_CmdMaxAlternates(MaxAlternates);
}

template <class T> long __fastcall
TCOMISpeechRecoContextT<T>::get_CmdMaxAlternates(void)
{
  long MaxAlternates;
  OLECHECK(this->get_CmdMaxAlternates((long*)&MaxAlternates));
  return MaxAlternates;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::set_State(Speechlib_tlb::SpeechRecoContextState State/*[in]*/)
{
  return (*this)->set_State(State);
}

template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::get_State(Speechlib_tlb::SpeechRecoContextState* State/*[out,retval]*/)
{
  return (*this)->get_State(State);
}

template <class T> Speechlib_tlb::SpeechRecoContextState __fastcall
TCOMISpeechRecoContextT<T>::get_State(void)
{
  Speechlib_tlb::SpeechRecoContextState State;
  OLECHECK(this->get_State((Speechlib_tlb::SpeechRecoContextState*)&State));
  return State;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::set_RetainedAudio(Speechlib_tlb::SpeechRetainedAudioOptions Option/*[in]*/)
{
  return (*this)->set_RetainedAudio(Option);
}

template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::get_RetainedAudio(Speechlib_tlb::SpeechRetainedAudioOptions* Option/*[out,retval]*/)
{
  return (*this)->get_RetainedAudio(Option);
}

template <class T> Speechlib_tlb::SpeechRetainedAudioOptions __fastcall
TCOMISpeechRecoContextT<T>::get_RetainedAudio(void)
{
  Speechlib_tlb::SpeechRetainedAudioOptions Option;
  OLECHECK(this->get_RetainedAudio((Speechlib_tlb::SpeechRetainedAudioOptions*)&Option));
  return Option;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::_set_RetainedAudioFormat(Speechlib_tlb::ISpeechAudioFormat* Format/*[in]*/)
{
  return (*this)->_set_RetainedAudioFormat(Format);
}

template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::get_RetainedAudioFormat(Speechlib_tlb::ISpeechAudioFormat** Format/*[out,retval]*/)
{
  return (*this)->get_RetainedAudioFormat(Format);
}

template <class T> Speechlib_tlb::ISpeechAudioFormatPtr __fastcall
TCOMISpeechRecoContextT<T>::get_RetainedAudioFormat(void)
{
  Speechlib_tlb::ISpeechAudioFormatPtr Format;
  OLECHECK(this->get_RetainedAudioFormat((Speechlib_tlb::ISpeechAudioFormatPtr*)&Format));
  return Format;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::Pause(void)
{
  return (*this)->Pause();
}

template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::Resume(void)
{
  return (*this)->Resume();
}

template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::CreateGrammar(VARIANT GrammarId/*[in,def,opt]*/, 
                                          Speechlib_tlb::ISpeechRecoGrammar** Grammar/*[out,retval]*/)
{
  return (*this)->CreateGrammar(GrammarId, Grammar);
}

template <class T> Speechlib_tlb::ISpeechRecoGrammar* __fastcall
TCOMISpeechRecoContextT<T>::CreateGrammar(VARIANT GrammarId/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechRecoGrammar* Grammar;
  OLECHECK(this->CreateGrammar(GrammarId/*[in,def,opt]*/, (Speechlib_tlb::ISpeechRecoGrammar**)&Grammar));
  return Grammar;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::CreateResultFromMemory(VARIANT* ResultBlock/*[in]*/, 
                                                   Speechlib_tlb::ISpeechRecoResult** Result/*[out,retval]*/)
{
  return (*this)->CreateResultFromMemory(ResultBlock, Result);
}

template <class T> Speechlib_tlb::ISpeechRecoResult* __fastcall
TCOMISpeechRecoContextT<T>::CreateResultFromMemory(VARIANT* ResultBlock/*[in]*/)
{
  Speechlib_tlb::ISpeechRecoResult* Result;
  OLECHECK(this->CreateResultFromMemory(ResultBlock/*[in]*/, (Speechlib_tlb::ISpeechRecoResult**)&Result));
  return Result;
}

template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::Bookmark(Speechlib_tlb::SpeechBookmarkOptions Options/*[in]*/, 
                                     VARIANT StreamPos/*[in]*/, VARIANT BookmarkId/*[in]*/)
{
  return (*this)->Bookmark(Options, StreamPos, BookmarkId);
}

template <class T> HRESULT __fastcall
TCOMISpeechRecoContextT<T>::SetAdaptationData(BSTR AdaptationString/*[in]*/)
{
  return (*this)->SetAdaptationData(AdaptationString);
}

// *********************************************************************//
// DispIntf:  ISpeechRecoContext
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {580AA49D-7E1E-4809-B8E2-57DA806104B8}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::get_Recognizer(Speechlib_tlb::ISpeechRecognizer** Recognizer/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Recognizer"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechRecognizer**)Recognizer /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechRecognizerPtr __fastcall
ISpeechRecoContextDispT<T>::get_Recognizer(void)
{
  Speechlib_tlb::ISpeechRecognizerPtr Recognizer;
  this->get_Recognizer(&Recognizer);
  return Recognizer;
}

template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::get_AudioInputInterferenceStatus(Speechlib_tlb::SpeechInterference* Interference/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioInputInterferenceStatus"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)Interference /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechInterference __fastcall
ISpeechRecoContextDispT<T>::get_AudioInputInterferenceStatus(void)
{
  Speechlib_tlb::SpeechInterference Interference;
  this->get_AudioInputInterferenceStatus((Speechlib_tlb::SpeechInterference*)&Interference);
  return Interference;
}

template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::get_RequestedUIType(BSTR* UIType/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RequestedUIType"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(UIType /*[VT_BSTR:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechRecoContextDispT<T>::get_RequestedUIType(void)
{
  BSTR UIType;
  this->get_RequestedUIType((BSTR*)&UIType);
  return UIType;
}

template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::_set_Voice(Speechlib_tlb::ISpeechVoice* Voice/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Voice"), DISPID(4));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechVoice*)Voice /*[VT_USERDEFINED:1]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::get_Voice(Speechlib_tlb::ISpeechVoice** Voice/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Voice"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechVoice**)Voice /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechVoicePtr __fastcall
ISpeechRecoContextDispT<T>::get_Voice(void)
{
  Speechlib_tlb::ISpeechVoicePtr Voice;
  this->get_Voice(&Voice);
  return Voice;
}

template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::set_AllowVoiceFormatMatchingOnNextSet(VARIANT_BOOL pAllow/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("AllowVoiceFormatMatchingOnNextSet"), DISPID(5));
  TAutoArgs<1> _args;
  _args[1] = pAllow /*[VT_BOOL:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::get_AllowVoiceFormatMatchingOnNextSet(VARIANT_BOOL* pAllow/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("AllowVoiceFormatMatchingOnNextSet"), DISPID(5));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pAllow /*[VT_BOOL:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
ISpeechRecoContextDispT<T>::get_AllowVoiceFormatMatchingOnNextSet(void)
{
  VARIANT_BOOL pAllow;
  this->get_AllowVoiceFormatMatchingOnNextSet((VARIANT_BOOL*)&pAllow);
  return pAllow;
}

template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::set_VoicePurgeEvent(Speechlib_tlb::SpeechRecoEvents EventInterest/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("VoicePurgeEvent"), DISPID(6));
  TAutoArgs<1> _args;
  _args[1] = (int)EventInterest /*[VT_USERDEFINED:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::get_VoicePurgeEvent(Speechlib_tlb::SpeechRecoEvents* EventInterest/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("VoicePurgeEvent"), DISPID(6));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)EventInterest /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechRecoEvents __fastcall
ISpeechRecoContextDispT<T>::get_VoicePurgeEvent(void)
{
  Speechlib_tlb::SpeechRecoEvents EventInterest;
  this->get_VoicePurgeEvent((Speechlib_tlb::SpeechRecoEvents*)&EventInterest);
  return EventInterest;
}

template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::set_EventInterests(Speechlib_tlb::SpeechRecoEvents EventInterest/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("EventInterests"), DISPID(7));
  TAutoArgs<1> _args;
  _args[1] = (int)EventInterest /*[VT_USERDEFINED:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::get_EventInterests(Speechlib_tlb::SpeechRecoEvents* EventInterest/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("EventInterests"), DISPID(7));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)EventInterest /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechRecoEvents __fastcall
ISpeechRecoContextDispT<T>::get_EventInterests(void)
{
  Speechlib_tlb::SpeechRecoEvents EventInterest;
  this->get_EventInterests((Speechlib_tlb::SpeechRecoEvents*)&EventInterest);
  return EventInterest;
}

template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::set_CmdMaxAlternates(long MaxAlternates/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("CmdMaxAlternates"), DISPID(8));
  TAutoArgs<1> _args;
  _args[1] = MaxAlternates /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::get_CmdMaxAlternates(long* MaxAlternates/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("CmdMaxAlternates"), DISPID(8));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(MaxAlternates /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechRecoContextDispT<T>::get_CmdMaxAlternates(void)
{
  long MaxAlternates;
  this->get_CmdMaxAlternates((long*)&MaxAlternates);
  return MaxAlternates;
}

template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::set_State(Speechlib_tlb::SpeechRecoContextState State/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("State"), DISPID(9));
  TAutoArgs<1> _args;
  _args[1] = (int)State /*[VT_USERDEFINED:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::get_State(Speechlib_tlb::SpeechRecoContextState* State/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("State"), DISPID(9));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)State /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechRecoContextState __fastcall
ISpeechRecoContextDispT<T>::get_State(void)
{
  Speechlib_tlb::SpeechRecoContextState State;
  this->get_State((Speechlib_tlb::SpeechRecoContextState*)&State);
  return State;
}

template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::set_RetainedAudio(Speechlib_tlb::SpeechRetainedAudioOptions Option/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("RetainedAudio"), DISPID(10));
  TAutoArgs<1> _args;
  _args[1] = (int)Option /*[VT_USERDEFINED:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::get_RetainedAudio(Speechlib_tlb::SpeechRetainedAudioOptions* Option/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RetainedAudio"), DISPID(10));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)Option /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechRetainedAudioOptions __fastcall
ISpeechRecoContextDispT<T>::get_RetainedAudio(void)
{
  Speechlib_tlb::SpeechRetainedAudioOptions Option;
  this->get_RetainedAudio((Speechlib_tlb::SpeechRetainedAudioOptions*)&Option);
  return Option;
}

template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::_set_RetainedAudioFormat(Speechlib_tlb::ISpeechAudioFormat* Format/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("RetainedAudioFormat"), DISPID(11));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechAudioFormat*)Format /*[VT_USERDEFINED:1]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::get_RetainedAudioFormat(Speechlib_tlb::ISpeechAudioFormat** Format/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RetainedAudioFormat"), DISPID(11));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechAudioFormat**)Format /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechAudioFormatPtr __fastcall
ISpeechRecoContextDispT<T>::get_RetainedAudioFormat(void)
{
  Speechlib_tlb::ISpeechAudioFormatPtr Format;
  this->get_RetainedAudioFormat(&Format);
  return Format;
}

template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::Pause()
{
  _TDispID _dispid(*this, OLETEXT("Pause"), DISPID(12));
  return OleFunction(_dispid);
}

template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::Resume()
{
  _TDispID _dispid(*this, OLETEXT("Resume"), DISPID(13));
  return OleFunction(_dispid);
}

template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::CreateGrammar(VARIANT GrammarId/*[in,def,opt]*/, 
                                          Speechlib_tlb::ISpeechRecoGrammar** Grammar/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("CreateGrammar"), DISPID(14));
  TAutoArgs<1> _args;
  _args[1] = GrammarId /*[VT_VARIANT:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechRecoGrammar**)Grammar /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechRecoGrammar* __fastcall
ISpeechRecoContextDispT<T>::CreateGrammar(VARIANT GrammarId/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechRecoGrammar* Grammar;
  this->CreateGrammar(GrammarId, (Speechlib_tlb::ISpeechRecoGrammar**)&Grammar);
  return Grammar;
}

template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::CreateResultFromMemory(VARIANT* ResultBlock/*[in]*/, 
                                                   Speechlib_tlb::ISpeechRecoResult** Result/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("CreateResultFromMemory"), DISPID(15));
  TAutoArgs<1> _args;
  _args[1] = ResultBlock /*[VT_VARIANT:1]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechRecoResult**)Result /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechRecoResult* __fastcall
ISpeechRecoContextDispT<T>::CreateResultFromMemory(VARIANT* ResultBlock/*[in]*/)
{
  Speechlib_tlb::ISpeechRecoResult* Result;
  this->CreateResultFromMemory(ResultBlock, (Speechlib_tlb::ISpeechRecoResult**)&Result);
  return Result;
}

template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::Bookmark(Speechlib_tlb::SpeechBookmarkOptions Options/*[in]*/, 
                                     VARIANT StreamPos/*[in]*/, VARIANT BookmarkId/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("Bookmark"), DISPID(16));
  TAutoArgs<3> _args;
  _args[1] = (int)Options /*[VT_USERDEFINED:0]*/;
  _args[2] = StreamPos /*[VT_VARIANT:0]*/;
  _args[3] = BookmarkId /*[VT_VARIANT:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoContextDispT<T>::SetAdaptationData(BSTR AdaptationString/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("SetAdaptationData"), DISPID(17));
  TAutoArgs<1> _args;
  _args[1] = AdaptationString /*[VT_BSTR:0]*/;
  return OleFunction(_dispid, _args);
}

// *********************************************************************//
// DispIntf:  ISpeechRecoGrammar
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {B6D6F79F-2158-4E50-B5BC-9A9CCD852A09}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechRecoGrammarDispT<T>::get_Id(VARIANT* Id/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Id"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Id /*[VT_VARIANT:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechRecoGrammarDispT<T>::get_Id(void)
{
  VARIANT Id;
  this->get_Id((VARIANT*)&Id);
  return Id;
}

template <class T> HRESULT __fastcall
ISpeechRecoGrammarDispT<T>::get_RecoContext(Speechlib_tlb::ISpeechRecoContext** RecoContext/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RecoContext"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechRecoContext**)RecoContext /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechRecoContextPtr __fastcall
ISpeechRecoGrammarDispT<T>::get_RecoContext(void)
{
  Speechlib_tlb::ISpeechRecoContextPtr RecoContext;
  this->get_RecoContext(&RecoContext);
  return RecoContext;
}

template <class T> HRESULT __fastcall
ISpeechRecoGrammarDispT<T>::set_State(Speechlib_tlb::SpeechGrammarState State/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("State"), DISPID(3));
  TAutoArgs<1> _args;
  _args[1] = (int)State /*[VT_USERDEFINED:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoGrammarDispT<T>::get_State(Speechlib_tlb::SpeechGrammarState* State/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("State"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)State /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechGrammarState __fastcall
ISpeechRecoGrammarDispT<T>::get_State(void)
{
  Speechlib_tlb::SpeechGrammarState State;
  this->get_State((Speechlib_tlb::SpeechGrammarState*)&State);
  return State;
}

template <class T> HRESULT __fastcall
ISpeechRecoGrammarDispT<T>::get_Rules(Speechlib_tlb::ISpeechGrammarRules** Rules/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Rules"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechGrammarRules**)Rules /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechGrammarRulesPtr __fastcall
ISpeechRecoGrammarDispT<T>::get_Rules(void)
{
  Speechlib_tlb::ISpeechGrammarRulesPtr Rules;
  this->get_Rules(&Rules);
  return Rules;
}

template <class T> HRESULT __fastcall
ISpeechRecoGrammarDispT<T>::Reset(long NewLanguage/*[in,def,opt]*/)
{
  _TDispID _dispid(*this, OLETEXT("Reset"), DISPID(5));
  TAutoArgs<1> _args;
  _args[1] = NewLanguage /*[VT_I4:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoGrammarDispT<T>::CmdLoadFromFile(BSTR FileName/*[in]*/, 
                                            Speechlib_tlb::SpeechLoadOption LoadOption/*[in,def,opt]*/)
{
  _TDispID _dispid(*this, OLETEXT("CmdLoadFromFile"), DISPID(7));
  TAutoArgs<2> _args;
  _args[1] = FileName /*[VT_BSTR:0]*/;
  _args[2] = (int)LoadOption /*[VT_USERDEFINED:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoGrammarDispT<T>::CmdLoadFromObject(BSTR ClassId/*[in]*/, BSTR GrammarName/*[in]*/, 
                                              Speechlib_tlb::SpeechLoadOption LoadOption/*[in,def,opt]*/)
{
  _TDispID _dispid(*this, OLETEXT("CmdLoadFromObject"), DISPID(8));
  TAutoArgs<3> _args;
  _args[1] = ClassId /*[VT_BSTR:0]*/;
  _args[2] = GrammarName /*[VT_BSTR:0]*/;
  _args[3] = (int)LoadOption /*[VT_USERDEFINED:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoGrammarDispT<T>::CmdLoadFromResource(long hModule/*[in]*/, VARIANT ResourceName/*[in]*/, 
                                                VARIANT ResourceType/*[in]*/, 
                                                long LanguageId/*[in]*/, 
                                                Speechlib_tlb::SpeechLoadOption LoadOption/*[in,def,opt]*/)
{
  _TDispID _dispid(*this, OLETEXT("CmdLoadFromResource"), DISPID(9));
  TAutoArgs<5> _args;
  _args[1] = hModule /*[VT_I4:0]*/;
  _args[2] = ResourceName /*[VT_VARIANT:0]*/;
  _args[3] = ResourceType /*[VT_VARIANT:0]*/;
  _args[4] = LanguageId /*[VT_I4:0]*/;
  _args[5] = (int)LoadOption /*[VT_USERDEFINED:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoGrammarDispT<T>::CmdLoadFromMemory(VARIANT GrammarData/*[in]*/, 
                                              Speechlib_tlb::SpeechLoadOption LoadOption/*[in,def,opt]*/)
{
  _TDispID _dispid(*this, OLETEXT("CmdLoadFromMemory"), DISPID(10));
  TAutoArgs<2> _args;
  _args[1] = GrammarData /*[VT_VARIANT:0]*/;
  _args[2] = (int)LoadOption /*[VT_USERDEFINED:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoGrammarDispT<T>::CmdLoadFromProprietaryGrammar(BSTR ProprietaryGuid/*[in]*/, 
                                                          BSTR ProprietaryString/*[in]*/, 
                                                          VARIANT ProprietaryData/*[in]*/, 
                                                          Speechlib_tlb::SpeechLoadOption LoadOption/*[in,def,opt]*/)
{
  _TDispID _dispid(*this, OLETEXT("CmdLoadFromProprietaryGrammar"), DISPID(11));
  TAutoArgs<4> _args;
  _args[1] = ProprietaryGuid /*[VT_BSTR:0]*/;
  _args[2] = ProprietaryString /*[VT_BSTR:0]*/;
  _args[3] = ProprietaryData /*[VT_VARIANT:0]*/;
  _args[4] = (int)LoadOption /*[VT_USERDEFINED:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoGrammarDispT<T>::CmdSetRuleState(BSTR Name/*[in]*/, 
                                            Speechlib_tlb::SpeechRuleState State/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("CmdSetRuleState"), DISPID(12));
  TAutoArgs<2> _args;
  _args[1] = Name /*[VT_BSTR:0]*/;
  _args[2] = (int)State /*[VT_USERDEFINED:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoGrammarDispT<T>::CmdSetRuleIdState(long RuleId/*[in]*/, 
                                              Speechlib_tlb::SpeechRuleState State/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("CmdSetRuleIdState"), DISPID(13));
  TAutoArgs<2> _args;
  _args[1] = RuleId /*[VT_I4:0]*/;
  _args[2] = (int)State /*[VT_USERDEFINED:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoGrammarDispT<T>::DictationLoad(BSTR TopicName/*[in,def,opt]*/, 
                                          Speechlib_tlb::SpeechLoadOption LoadOption/*[in,def,opt]*/)
{
  _TDispID _dispid(*this, OLETEXT("DictationLoad"), DISPID(14));
  TAutoArgs<2> _args;
  _args[1] = TopicName /*[VT_BSTR:0]*/;
  _args[2] = (int)LoadOption /*[VT_USERDEFINED:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoGrammarDispT<T>::DictationUnload()
{
  _TDispID _dispid(*this, OLETEXT("DictationUnload"), DISPID(15));
  return OleFunction(_dispid);
}

template <class T> HRESULT __fastcall
ISpeechRecoGrammarDispT<T>::DictationSetState(Speechlib_tlb::SpeechRuleState State/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("DictationSetState"), DISPID(16));
  TAutoArgs<1> _args;
  _args[1] = (int)State /*[VT_USERDEFINED:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoGrammarDispT<T>::SetWordSequenceData(BSTR Text/*[in]*/, long TextLength/*[in]*/, 
                                                Speechlib_tlb::ISpeechTextSelectionInformation* Info/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("SetWordSequenceData"), DISPID(17));
  TAutoArgs<3> _args;
  _args[1] = Text /*[VT_BSTR:0]*/;
  _args[2] = TextLength /*[VT_I4:0]*/;
  _args[3] = (LPDISPATCH)(Speechlib_tlb::ISpeechTextSelectionInformation*)Info /*[VT_USERDEFINED:1]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoGrammarDispT<T>::SetTextSelection(Speechlib_tlb::ISpeechTextSelectionInformation* Info/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("SetTextSelection"), DISPID(18));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechTextSelectionInformation*)Info /*[VT_USERDEFINED:1]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoGrammarDispT<T>::IsPronounceable(BSTR Word/*[in]*/, 
                                            Speechlib_tlb::SpeechWordPronounceable* WordPronounceable/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("IsPronounceable"), DISPID(19));
  TAutoArgs<1> _args;
  _args[1] = Word /*[VT_BSTR:0]*/;
  return OutRetValSetterPtr((int*)WordPronounceable /*[VT_USERDEFINED:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechWordPronounceable __fastcall
ISpeechRecoGrammarDispT<T>::IsPronounceable(BSTR Word/*[in]*/)
{
  Speechlib_tlb::SpeechWordPronounceable WordPronounceable;
  this->IsPronounceable(Word, (Speechlib_tlb::SpeechWordPronounceable*)&WordPronounceable);
  return WordPronounceable;
}

// *********************************************************************//
// DispIntf:  ISpeechGrammarRules
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {6FFA3B44-FC2D-40D1-8AFC-32911C7F1AD1}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechGrammarRulesDispT<T>::get_Count(long* Count/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Count"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Count /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechGrammarRulesDispT<T>::get_Count(void)
{
  long Count;
  this->get_Count((long*)&Count);
  return Count;
}

template <class T> HRESULT __fastcall
ISpeechGrammarRulesDispT<T>::FindRule(VARIANT RuleNameOrId/*[in]*/, 
                                      Speechlib_tlb::ISpeechGrammarRule** Rule/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("FindRule"), DISPID(6));
  TAutoArgs<1> _args;
  _args[1] = RuleNameOrId /*[VT_VARIANT:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechGrammarRule**)Rule /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechGrammarRule* __fastcall
ISpeechGrammarRulesDispT<T>::FindRule(VARIANT RuleNameOrId/*[in]*/)
{
  Speechlib_tlb::ISpeechGrammarRule* Rule;
  this->FindRule(RuleNameOrId, (Speechlib_tlb::ISpeechGrammarRule**)&Rule);
  return Rule;
}

template <class T> HRESULT __fastcall
ISpeechGrammarRulesDispT<T>::Item(long Index/*[in]*/, 
                                  Speechlib_tlb::ISpeechGrammarRule** Rule/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Item"), DISPID(0));
  TAutoArgs<1> _args;
  _args[1] = Index /*[VT_I4:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechGrammarRule**)Rule /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechGrammarRule* __fastcall
ISpeechGrammarRulesDispT<T>::Item(long Index/*[in]*/)
{
  Speechlib_tlb::ISpeechGrammarRule* Rule;
  this->Item(Index, (Speechlib_tlb::ISpeechGrammarRule**)&Rule);
  return Rule;
}

template <class T> HRESULT __fastcall
ISpeechGrammarRulesDispT<T>::get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("_NewEnum"), DISPID(-4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(EnumVARIANT /*[VT_UNKNOWN:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> LPUNKNOWN __fastcall
ISpeechGrammarRulesDispT<T>::get__NewEnum(void)
{
  LPUNKNOWN EnumVARIANT;
  this->get__NewEnum((LPUNKNOWN*)&EnumVARIANT);
  return EnumVARIANT;
}

template <class T> HRESULT __fastcall
ISpeechGrammarRulesDispT<T>::get_Dynamic(VARIANT_BOOL* Dynamic/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Dynamic"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Dynamic /*[VT_BOOL:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
ISpeechGrammarRulesDispT<T>::get_Dynamic(void)
{
  VARIANT_BOOL Dynamic;
  this->get_Dynamic((VARIANT_BOOL*)&Dynamic);
  return Dynamic;
}

template <class T> HRESULT __fastcall
ISpeechGrammarRulesDispT<T>::Add(BSTR RuleName/*[in]*/, 
                                 Speechlib_tlb::SpeechRuleAttributes Attributes/*[in]*/, 
                                 long RuleId/*[in,def,opt]*/, 
                                 Speechlib_tlb::ISpeechGrammarRule** Rule/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Add"), DISPID(3));
  TAutoArgs<3> _args;
  _args[1] = RuleName /*[VT_BSTR:0]*/;
  _args[2] = (int)Attributes /*[VT_USERDEFINED:0]*/;
  _args[3] = RuleId /*[VT_I4:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechGrammarRule**)Rule /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechGrammarRule* __fastcall
ISpeechGrammarRulesDispT<T>::Add(BSTR RuleName/*[in]*/, 
                                 Speechlib_tlb::SpeechRuleAttributes Attributes/*[in]*/, 
                                 long RuleId/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechGrammarRule* Rule;
  this->Add(RuleName, Attributes, RuleId, (Speechlib_tlb::ISpeechGrammarRule**)&Rule);
  return Rule;
}

template <class T> HRESULT __fastcall
ISpeechGrammarRulesDispT<T>::Commit()
{
  _TDispID _dispid(*this, OLETEXT("Commit"), DISPID(4));
  return OleFunction(_dispid);
}

template <class T> HRESULT __fastcall
ISpeechGrammarRulesDispT<T>::CommitAndSave(BSTR* ErrorText/*[out]*/, 
                                           VARIANT* SaveStream/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("CommitAndSave"), DISPID(5));
  TAutoArgs<1> _args;
  _args[1] = ErrorText /*[VT_BSTR:1]*/;
  return OutRetValSetterPtr(SaveStream /*[VT_VARIANT:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechGrammarRulesDispT<T>::CommitAndSave(BSTR* ErrorText/*[out]*/)
{
  VARIANT SaveStream;
  this->CommitAndSave(ErrorText, (VARIANT*)&SaveStream);
  return SaveStream;
}

// *********************************************************************//
// DispIntf:  ISpeechGrammarRule
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {AFE719CF-5DD1-44F2-999C-7A399F1CFCCC}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechGrammarRuleDispT<T>::get_Attributes(Speechlib_tlb::SpeechRuleAttributes* Attributes/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Attributes"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)Attributes /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechRuleAttributes __fastcall
ISpeechGrammarRuleDispT<T>::get_Attributes(void)
{
  Speechlib_tlb::SpeechRuleAttributes Attributes;
  this->get_Attributes((Speechlib_tlb::SpeechRuleAttributes*)&Attributes);
  return Attributes;
}

template <class T> HRESULT __fastcall
ISpeechGrammarRuleDispT<T>::get_InitialState(Speechlib_tlb::ISpeechGrammarRuleState** State/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("InitialState"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechGrammarRuleState**)State /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechGrammarRuleStatePtr __fastcall
ISpeechGrammarRuleDispT<T>::get_InitialState(void)
{
  Speechlib_tlb::ISpeechGrammarRuleStatePtr State;
  this->get_InitialState(&State);
  return State;
}

template <class T> HRESULT __fastcall
ISpeechGrammarRuleDispT<T>::get_Name(BSTR* Name/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Name"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Name /*[VT_BSTR:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechGrammarRuleDispT<T>::get_Name(void)
{
  BSTR Name;
  this->get_Name((BSTR*)&Name);
  return Name;
}

template <class T> HRESULT __fastcall
ISpeechGrammarRuleDispT<T>::get_Id(long* Id/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Id"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Id /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechGrammarRuleDispT<T>::get_Id(void)
{
  long Id;
  this->get_Id((long*)&Id);
  return Id;
}

template <class T> HRESULT __fastcall
ISpeechGrammarRuleDispT<T>::Clear()
{
  _TDispID _dispid(*this, OLETEXT("Clear"), DISPID(5));
  return OleFunction(_dispid);
}

template <class T> HRESULT __fastcall
ISpeechGrammarRuleDispT<T>::AddResource(BSTR ResourceName/*[in]*/, BSTR ResourceValue/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("AddResource"), DISPID(6));
  TAutoArgs<2> _args;
  _args[1] = ResourceName /*[VT_BSTR:0]*/;
  _args[2] = ResourceValue /*[VT_BSTR:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechGrammarRuleDispT<T>::AddState(Speechlib_tlb::ISpeechGrammarRuleState** State/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("AddState"), DISPID(7));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechGrammarRuleState**)State /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechGrammarRuleState* __fastcall
ISpeechGrammarRuleDispT<T>::AddState(void)
{
  Speechlib_tlb::ISpeechGrammarRuleState* State;
  this->AddState((Speechlib_tlb::ISpeechGrammarRuleState**)&State);
  return State;
}

// *********************************************************************//
// DispIntf:  ISpeechGrammarRuleState
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {D4286F2C-EE67-45AE-B928-28D695362EDA}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechGrammarRuleStateDispT<T>::get_Rule(Speechlib_tlb::ISpeechGrammarRule** Rule/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Rule"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechGrammarRule**)Rule /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechGrammarRulePtr __fastcall
ISpeechGrammarRuleStateDispT<T>::get_Rule(void)
{
  Speechlib_tlb::ISpeechGrammarRulePtr Rule;
  this->get_Rule(&Rule);
  return Rule;
}

template <class T> HRESULT __fastcall
ISpeechGrammarRuleStateDispT<T>::get_Transitions(Speechlib_tlb::ISpeechGrammarRuleStateTransitions** Transitions/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Transitions"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechGrammarRuleStateTransitions**)Transitions /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechGrammarRuleStateTransitionsPtr __fastcall
ISpeechGrammarRuleStateDispT<T>::get_Transitions(void)
{
  Speechlib_tlb::ISpeechGrammarRuleStateTransitionsPtr Transitions;
  this->get_Transitions(&Transitions);
  return Transitions;
}

template <class T> HRESULT __fastcall
ISpeechGrammarRuleStateDispT<T>::AddWordTransition(Speechlib_tlb::ISpeechGrammarRuleState* DestState/*[in]*/
                                                   , BSTR Words/*[in]*/, 
                                                   BSTR Separators/*[in,def,opt]*/, 
                                                   Speechlib_tlb::SpeechGrammarWordType Type/*[in,def,opt]*/
                                                   , BSTR PropertyName/*[in,def,opt]*/, 
                                                   long PropertyId/*[in,def,opt]*/, 
                                                   VARIANT* PropertyValue/*[in,def,opt]*/, 
                                                   float Weight/*[in,def,opt]*/)
{
  _TDispID _dispid(*this, OLETEXT("AddWordTransition"), DISPID(3));
  TAutoArgs<8> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechGrammarRuleState*)DestState /*[VT_USERDEFINED:1]*/;
  _args[2] = Words /*[VT_BSTR:0]*/;
  _args[3] = Separators /*[VT_BSTR:0]*/;
  _args[4] = (int)Type /*[VT_USERDEFINED:0]*/;
  _args[5] = PropertyName /*[VT_BSTR:0]*/;
  _args[6] = PropertyId /*[VT_I4:0]*/;
  _args[7] = PropertyValue /*[VT_VARIANT:1]*/;
  _args[8] = Weight /*[VT_R4:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechGrammarRuleStateDispT<T>::AddRuleTransition(Speechlib_tlb::ISpeechGrammarRuleState* DestinationState/*[in]*/
                                                   , Speechlib_tlb::ISpeechGrammarRule* Rule/*[in]*/
                                                   , BSTR PropertyName/*[in,def,opt]*/, 
                                                   long PropertyId/*[in,def,opt]*/, 
                                                   VARIANT* PropertyValue/*[in,def,opt]*/, 
                                                   float Weight/*[in,def,opt]*/)
{
  _TDispID _dispid(*this, OLETEXT("AddRuleTransition"), DISPID(4));
  TAutoArgs<6> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechGrammarRuleState*)DestinationState /*[VT_USERDEFINED:1]*/;
  _args[2] = (LPDISPATCH)(Speechlib_tlb::ISpeechGrammarRule*)Rule /*[VT_USERDEFINED:1]*/;
  _args[3] = PropertyName /*[VT_BSTR:0]*/;
  _args[4] = PropertyId /*[VT_I4:0]*/;
  _args[5] = PropertyValue /*[VT_VARIANT:1]*/;
  _args[6] = Weight /*[VT_R4:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechGrammarRuleStateDispT<T>::AddSpecialTransition(Speechlib_tlb::ISpeechGrammarRuleState* DestinationState/*[in]*/
                                                      , 
                                                      Speechlib_tlb::SpeechSpecialTransitionType Type/*[in]*/
                                                      , BSTR PropertyName/*[in,def,opt]*/, 
                                                      long PropertyId/*[in,def,opt]*/, 
                                                      VARIANT* PropertyValue/*[in,def,opt]*/, 
                                                      float Weight/*[in,def,opt]*/)
{
  _TDispID _dispid(*this, OLETEXT("AddSpecialTransition"), DISPID(5));
  TAutoArgs<6> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechGrammarRuleState*)DestinationState /*[VT_USERDEFINED:1]*/;
  _args[2] = (int)Type /*[VT_USERDEFINED:0]*/;
  _args[3] = PropertyName /*[VT_BSTR:0]*/;
  _args[4] = PropertyId /*[VT_I4:0]*/;
  _args[5] = PropertyValue /*[VT_VARIANT:1]*/;
  _args[6] = Weight /*[VT_R4:0]*/;
  return OleFunction(_dispid, _args);
}

// *********************************************************************//
// DispIntf:  ISpeechGrammarRuleStateTransitions
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {EABCE657-75BC-44A2-AA7F-C56476742963}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechGrammarRuleStateTransitionsDispT<T>::get_Count(long* Count/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Count"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Count /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechGrammarRuleStateTransitionsDispT<T>::get_Count(void)
{
  long Count;
  this->get_Count((long*)&Count);
  return Count;
}

template <class T> HRESULT __fastcall
ISpeechGrammarRuleStateTransitionsDispT<T>::Item(long Index/*[in]*/, 
                                                 Speechlib_tlb::ISpeechGrammarRuleStateTransition** Transition/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Item"), DISPID(0));
  TAutoArgs<1> _args;
  _args[1] = Index /*[VT_I4:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechGrammarRuleStateTransition**)Transition /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechGrammarRuleStateTransition* __fastcall
ISpeechGrammarRuleStateTransitionsDispT<T>::Item(long Index/*[in]*/)
{
  Speechlib_tlb::ISpeechGrammarRuleStateTransition* Transition;
  this->Item(Index, (Speechlib_tlb::ISpeechGrammarRuleStateTransition**)&Transition);
  return Transition;
}

template <class T> HRESULT __fastcall
ISpeechGrammarRuleStateTransitionsDispT<T>::get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("_NewEnum"), DISPID(-4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(EnumVARIANT /*[VT_UNKNOWN:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> LPUNKNOWN __fastcall
ISpeechGrammarRuleStateTransitionsDispT<T>::get__NewEnum(void)
{
  LPUNKNOWN EnumVARIANT;
  this->get__NewEnum((LPUNKNOWN*)&EnumVARIANT);
  return EnumVARIANT;
}

// *********************************************************************//
// DispIntf:  ISpeechGrammarRuleStateTransition
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {CAFD1DB1-41D1-4A06-9863-E2E81DA17A9A}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechGrammarRuleStateTransitionDispT<T>::get_Type(Speechlib_tlb::SpeechGrammarRuleStateTransitionType* Type/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Type"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)Type /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechGrammarRuleStateTransitionType __fastcall
ISpeechGrammarRuleStateTransitionDispT<T>::get_Type(void)
{
  Speechlib_tlb::SpeechGrammarRuleStateTransitionType Type;
  this->get_Type((Speechlib_tlb::SpeechGrammarRuleStateTransitionType*)&Type);
  return Type;
}

template <class T> HRESULT __fastcall
ISpeechGrammarRuleStateTransitionDispT<T>::get_Text(BSTR* Text/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Text"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Text /*[VT_BSTR:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechGrammarRuleStateTransitionDispT<T>::get_Text(void)
{
  BSTR Text;
  this->get_Text((BSTR*)&Text);
  return Text;
}

template <class T> HRESULT __fastcall
ISpeechGrammarRuleStateTransitionDispT<T>::get_Rule(Speechlib_tlb::ISpeechGrammarRule** Rule/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Rule"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechGrammarRule**)Rule /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechGrammarRulePtr __fastcall
ISpeechGrammarRuleStateTransitionDispT<T>::get_Rule(void)
{
  Speechlib_tlb::ISpeechGrammarRulePtr Rule;
  this->get_Rule(&Rule);
  return Rule;
}

template <class T> HRESULT __fastcall
ISpeechGrammarRuleStateTransitionDispT<T>::get_Weight(VARIANT* Weight/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Weight"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Weight /*[VT_VARIANT:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechGrammarRuleStateTransitionDispT<T>::get_Weight(void)
{
  VARIANT Weight;
  this->get_Weight((VARIANT*)&Weight);
  return Weight;
}

template <class T> HRESULT __fastcall
ISpeechGrammarRuleStateTransitionDispT<T>::get_PropertyName(BSTR* PropertyName/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("PropertyName"), DISPID(5));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(PropertyName /*[VT_BSTR:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechGrammarRuleStateTransitionDispT<T>::get_PropertyName(void)
{
  BSTR PropertyName;
  this->get_PropertyName((BSTR*)&PropertyName);
  return PropertyName;
}

template <class T> HRESULT __fastcall
ISpeechGrammarRuleStateTransitionDispT<T>::get_PropertyId(long* PropertyId/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("PropertyId"), DISPID(6));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(PropertyId /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechGrammarRuleStateTransitionDispT<T>::get_PropertyId(void)
{
  long PropertyId;
  this->get_PropertyId((long*)&PropertyId);
  return PropertyId;
}

template <class T> HRESULT __fastcall
ISpeechGrammarRuleStateTransitionDispT<T>::get_PropertyValue(VARIANT* PropertyValue/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("PropertyValue"), DISPID(7));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(PropertyValue /*[VT_VARIANT:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechGrammarRuleStateTransitionDispT<T>::get_PropertyValue(void)
{
  VARIANT PropertyValue;
  this->get_PropertyValue((VARIANT*)&PropertyValue);
  return PropertyValue;
}

template <class T> HRESULT __fastcall
ISpeechGrammarRuleStateTransitionDispT<T>::get_NextState(Speechlib_tlb::ISpeechGrammarRuleState** NextState/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("NextState"), DISPID(8));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechGrammarRuleState**)NextState /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechGrammarRuleStatePtr __fastcall
ISpeechGrammarRuleStateTransitionDispT<T>::get_NextState(void)
{
  Speechlib_tlb::ISpeechGrammarRuleStatePtr NextState;
  this->get_NextState(&NextState);
  return NextState;
}

// *********************************************************************//
// SmartIntf: TCOMISpeechTextSelectionInformation
// Interface: ISpeechTextSelectionInformation
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMISpeechTextSelectionInformationT<T>::set_ActiveOffset(long ActiveOffset/*[in]*/)
{
  return (*this)->set_ActiveOffset(ActiveOffset);
}

template <class T> HRESULT __fastcall
TCOMISpeechTextSelectionInformationT<T>::get_ActiveOffset(long* ActiveOffset/*[out,retval]*/)
{
  return (*this)->get_ActiveOffset(ActiveOffset);
}

template <class T> long __fastcall
TCOMISpeechTextSelectionInformationT<T>::get_ActiveOffset(void)
{
  long ActiveOffset;
  OLECHECK(this->get_ActiveOffset((long*)&ActiveOffset));
  return ActiveOffset;
}

template <class T> HRESULT __fastcall
TCOMISpeechTextSelectionInformationT<T>::set_ActiveLength(long ActiveLength/*[in]*/)
{
  return (*this)->set_ActiveLength(ActiveLength);
}

template <class T> HRESULT __fastcall
TCOMISpeechTextSelectionInformationT<T>::get_ActiveLength(long* ActiveLength/*[out,retval]*/)
{
  return (*this)->get_ActiveLength(ActiveLength);
}

template <class T> long __fastcall
TCOMISpeechTextSelectionInformationT<T>::get_ActiveLength(void)
{
  long ActiveLength;
  OLECHECK(this->get_ActiveLength((long*)&ActiveLength));
  return ActiveLength;
}

template <class T> HRESULT __fastcall
TCOMISpeechTextSelectionInformationT<T>::set_SelectionOffset(long SelectionOffset/*[in]*/)
{
  return (*this)->set_SelectionOffset(SelectionOffset);
}

template <class T> HRESULT __fastcall
TCOMISpeechTextSelectionInformationT<T>::get_SelectionOffset(long* SelectionOffset/*[out,retval]*/)
{
  return (*this)->get_SelectionOffset(SelectionOffset);
}

template <class T> long __fastcall
TCOMISpeechTextSelectionInformationT<T>::get_SelectionOffset(void)
{
  long SelectionOffset;
  OLECHECK(this->get_SelectionOffset((long*)&SelectionOffset));
  return SelectionOffset;
}

template <class T> HRESULT __fastcall
TCOMISpeechTextSelectionInformationT<T>::set_SelectionLength(long SelectionLength/*[in]*/)
{
  return (*this)->set_SelectionLength(SelectionLength);
}

template <class T> HRESULT __fastcall
TCOMISpeechTextSelectionInformationT<T>::get_SelectionLength(long* SelectionLength/*[out,retval]*/)
{
  return (*this)->get_SelectionLength(SelectionLength);
}

template <class T> long __fastcall
TCOMISpeechTextSelectionInformationT<T>::get_SelectionLength(void)
{
  long SelectionLength;
  OLECHECK(this->get_SelectionLength((long*)&SelectionLength));
  return SelectionLength;
}

// *********************************************************************//
// DispIntf:  ISpeechTextSelectionInformation
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {3B9C7E7A-6EEE-4DED-9092-11657279ADBE}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechTextSelectionInformationDispT<T>::set_ActiveOffset(long ActiveOffset/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("ActiveOffset"), DISPID(1));
  TAutoArgs<1> _args;
  _args[1] = ActiveOffset /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechTextSelectionInformationDispT<T>::get_ActiveOffset(long* ActiveOffset/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("ActiveOffset"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(ActiveOffset /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechTextSelectionInformationDispT<T>::get_ActiveOffset(void)
{
  long ActiveOffset;
  this->get_ActiveOffset((long*)&ActiveOffset);
  return ActiveOffset;
}

template <class T> HRESULT __fastcall
ISpeechTextSelectionInformationDispT<T>::set_ActiveLength(long ActiveLength/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("ActiveLength"), DISPID(2));
  TAutoArgs<1> _args;
  _args[1] = ActiveLength /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechTextSelectionInformationDispT<T>::get_ActiveLength(long* ActiveLength/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("ActiveLength"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(ActiveLength /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechTextSelectionInformationDispT<T>::get_ActiveLength(void)
{
  long ActiveLength;
  this->get_ActiveLength((long*)&ActiveLength);
  return ActiveLength;
}

template <class T> HRESULT __fastcall
ISpeechTextSelectionInformationDispT<T>::set_SelectionOffset(long SelectionOffset/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("SelectionOffset"), DISPID(3));
  TAutoArgs<1> _args;
  _args[1] = SelectionOffset /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechTextSelectionInformationDispT<T>::get_SelectionOffset(long* SelectionOffset/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("SelectionOffset"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(SelectionOffset /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechTextSelectionInformationDispT<T>::get_SelectionOffset(void)
{
  long SelectionOffset;
  this->get_SelectionOffset((long*)&SelectionOffset);
  return SelectionOffset;
}

template <class T> HRESULT __fastcall
ISpeechTextSelectionInformationDispT<T>::set_SelectionLength(long SelectionLength/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("SelectionLength"), DISPID(4));
  TAutoArgs<1> _args;
  _args[1] = SelectionLength /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechTextSelectionInformationDispT<T>::get_SelectionLength(long* SelectionLength/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("SelectionLength"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(SelectionLength /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechTextSelectionInformationDispT<T>::get_SelectionLength(void)
{
  long SelectionLength;
  this->get_SelectionLength((long*)&SelectionLength);
  return SelectionLength;
}

// *********************************************************************//
// DispIntf:  ISpeechRecoResult
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {ED2879CF-CED9-4EE6-A534-DE0191D5468D}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechRecoResultDispT<T>::get_RecoContext(Speechlib_tlb::ISpeechRecoContext** RecoContext/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RecoContext"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechRecoContext**)RecoContext /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechRecoContextPtr __fastcall
ISpeechRecoResultDispT<T>::get_RecoContext(void)
{
  Speechlib_tlb::ISpeechRecoContextPtr RecoContext;
  this->get_RecoContext(&RecoContext);
  return RecoContext;
}

template <class T> HRESULT __fastcall
ISpeechRecoResultDispT<T>::get_Times(Speechlib_tlb::ISpeechRecoResultTimes** Times/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Times"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechRecoResultTimes**)Times /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechRecoResultTimesPtr __fastcall
ISpeechRecoResultDispT<T>::get_Times(void)
{
  Speechlib_tlb::ISpeechRecoResultTimesPtr Times;
  this->get_Times(&Times);
  return Times;
}

template <class T> HRESULT __fastcall
ISpeechRecoResultDispT<T>::_set_AudioFormat(Speechlib_tlb::ISpeechAudioFormat* Format/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioFormat"), DISPID(3));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechAudioFormat*)Format /*[VT_USERDEFINED:1]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoResultDispT<T>::get_AudioFormat(Speechlib_tlb::ISpeechAudioFormat** Format/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioFormat"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechAudioFormat**)Format /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechAudioFormatPtr __fastcall
ISpeechRecoResultDispT<T>::get_AudioFormat(void)
{
  Speechlib_tlb::ISpeechAudioFormatPtr Format;
  this->get_AudioFormat(&Format);
  return Format;
}

template <class T> HRESULT __fastcall
ISpeechRecoResultDispT<T>::get_PhraseInfo(Speechlib_tlb::ISpeechPhraseInfo** PhraseInfo/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("PhraseInfo"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechPhraseInfo**)PhraseInfo /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechPhraseInfoPtr __fastcall
ISpeechRecoResultDispT<T>::get_PhraseInfo(void)
{
  Speechlib_tlb::ISpeechPhraseInfoPtr PhraseInfo;
  this->get_PhraseInfo(&PhraseInfo);
  return PhraseInfo;
}

template <class T> HRESULT __fastcall
ISpeechRecoResultDispT<T>::Alternates(long RequestCount/*[in]*/, long StartElement/*[in,def,opt]*/, 
                                      long Elements/*[in,def,opt]*/, 
                                      Speechlib_tlb::ISpeechPhraseAlternates** Alternates/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Alternates"), DISPID(5));
  TAutoArgs<3> _args;
  _args[1] = RequestCount /*[VT_I4:0]*/;
  _args[2] = StartElement /*[VT_I4:0]*/;
  _args[3] = Elements /*[VT_I4:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechPhraseAlternates**)Alternates /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechPhraseAlternates* __fastcall
ISpeechRecoResultDispT<T>::Alternates(long RequestCount/*[in]*/, long StartElement/*[in,def,opt]*/, 
                                      long Elements/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechPhraseAlternates* Alternates;
  this->Alternates(RequestCount, StartElement, Elements, (Speechlib_tlb::ISpeechPhraseAlternates**)&Alternates);
  return Alternates;
}

template <class T> HRESULT __fastcall
ISpeechRecoResultDispT<T>::Audio(long StartElement/*[in,def,opt]*/, long Elements/*[in,def,opt]*/, 
                                 Speechlib_tlb::ISpeechMemoryStream** Stream/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Audio"), DISPID(6));
  TAutoArgs<2> _args;
  _args[1] = StartElement /*[VT_I4:0]*/;
  _args[2] = Elements /*[VT_I4:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechMemoryStream**)Stream /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechMemoryStream* __fastcall
ISpeechRecoResultDispT<T>::Audio(long StartElement/*[in,def,opt]*/, long Elements/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechMemoryStream* Stream;
  this->Audio(StartElement, Elements, (Speechlib_tlb::ISpeechMemoryStream**)&Stream);
  return Stream;
}

template <class T> HRESULT __fastcall
ISpeechRecoResultDispT<T>::SpeakAudio(long StartElement/*[in,def,opt]*/, 
                                      long Elements/*[in,def,opt]*/, 
                                      Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/, 
                                      long* StreamNumber/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("SpeakAudio"), DISPID(7));
  TAutoArgs<3> _args;
  _args[1] = StartElement /*[VT_I4:0]*/;
  _args[2] = Elements /*[VT_I4:0]*/;
  _args[3] = (int)Flags /*[VT_USERDEFINED:0]*/;
  return OutRetValSetterPtr(StreamNumber /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
ISpeechRecoResultDispT<T>::SpeakAudio(long StartElement/*[in,def,opt]*/, 
                                      long Elements/*[in,def,opt]*/, 
                                      Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/)
{
  long StreamNumber;
  this->SpeakAudio(StartElement, Elements, Flags, (long*)&StreamNumber);
  return StreamNumber;
}

template <class T> HRESULT __fastcall
ISpeechRecoResultDispT<T>::SaveToMemory(VARIANT* ResultBlock/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("SaveToMemory"), DISPID(8));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(ResultBlock /*[VT_VARIANT:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechRecoResultDispT<T>::SaveToMemory(void)
{
  VARIANT ResultBlock;
  this->SaveToMemory((VARIANT*)&ResultBlock);
  return ResultBlock;
}

template <class T> HRESULT __fastcall
ISpeechRecoResultDispT<T>::DiscardResultInfo(Speechlib_tlb::SpeechDiscardType ValueTypes/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("DiscardResultInfo"), DISPID(9));
  TAutoArgs<1> _args;
  _args[1] = (int)ValueTypes /*[VT_USERDEFINED:0]*/;
  return OleFunction(_dispid, _args);
}

// *********************************************************************//
// DispIntf:  ISpeechRecoResultTimes
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {62B3B8FB-F6E7-41BE-BDCB-056B1C29EFC0}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechRecoResultTimesDispT<T>::get_StreamTime(VARIANT* Time/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("StreamTime"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Time /*[VT_VARIANT:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechRecoResultTimesDispT<T>::get_StreamTime(void)
{
  VARIANT Time;
  this->get_StreamTime((VARIANT*)&Time);
  return Time;
}

template <class T> HRESULT __fastcall
ISpeechRecoResultTimesDispT<T>::get_Length(VARIANT* Length/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Length"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Length /*[VT_VARIANT:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechRecoResultTimesDispT<T>::get_Length(void)
{
  VARIANT Length;
  this->get_Length((VARIANT*)&Length);
  return Length;
}

template <class T> HRESULT __fastcall
ISpeechRecoResultTimesDispT<T>::get_TickCount(long* TickCount/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("TickCount"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(TickCount /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechRecoResultTimesDispT<T>::get_TickCount(void)
{
  long TickCount;
  this->get_TickCount((long*)&TickCount);
  return TickCount;
}

template <class T> HRESULT __fastcall
ISpeechRecoResultTimesDispT<T>::get_OffsetFromStart(VARIANT* OffsetFromStart/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("OffsetFromStart"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(OffsetFromStart /*[VT_VARIANT:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechRecoResultTimesDispT<T>::get_OffsetFromStart(void)
{
  VARIANT OffsetFromStart;
  this->get_OffsetFromStart((VARIANT*)&OffsetFromStart);
  return OffsetFromStart;
}

// *********************************************************************//
// DispIntf:  ISpeechPhraseInfo
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {961559CF-4E67-4662-8BF0-D93F1FCD61B3}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechPhraseInfoDispT<T>::get_LanguageId(long* LanguageId/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("LanguageId"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(LanguageId /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhraseInfoDispT<T>::get_LanguageId(void)
{
  long LanguageId;
  this->get_LanguageId((long*)&LanguageId);
  return LanguageId;
}

template <class T> HRESULT __fastcall
ISpeechPhraseInfoDispT<T>::get_GrammarId(VARIANT* GrammarId/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GrammarId"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(GrammarId /*[VT_VARIANT:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechPhraseInfoDispT<T>::get_GrammarId(void)
{
  VARIANT GrammarId;
  this->get_GrammarId((VARIANT*)&GrammarId);
  return GrammarId;
}

template <class T> HRESULT __fastcall
ISpeechPhraseInfoDispT<T>::get_StartTime(VARIANT* StartTime/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("StartTime"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(StartTime /*[VT_VARIANT:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechPhraseInfoDispT<T>::get_StartTime(void)
{
  VARIANT StartTime;
  this->get_StartTime((VARIANT*)&StartTime);
  return StartTime;
}

template <class T> HRESULT __fastcall
ISpeechPhraseInfoDispT<T>::get_AudioStreamPosition(VARIANT* AudioStreamPosition/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioStreamPosition"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(AudioStreamPosition /*[VT_VARIANT:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechPhraseInfoDispT<T>::get_AudioStreamPosition(void)
{
  VARIANT AudioStreamPosition;
  this->get_AudioStreamPosition((VARIANT*)&AudioStreamPosition);
  return AudioStreamPosition;
}

template <class T> HRESULT __fastcall
ISpeechPhraseInfoDispT<T>::get_AudioSizeBytes(long* pAudioSizeBytes/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioSizeBytes"), DISPID(5));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(pAudioSizeBytes /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhraseInfoDispT<T>::get_AudioSizeBytes(void)
{
  long pAudioSizeBytes;
  this->get_AudioSizeBytes((long*)&pAudioSizeBytes);
  return pAudioSizeBytes;
}

template <class T> HRESULT __fastcall
ISpeechPhraseInfoDispT<T>::get_RetainedSizeBytes(long* RetainedSizeBytes/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RetainedSizeBytes"), DISPID(6));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(RetainedSizeBytes /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhraseInfoDispT<T>::get_RetainedSizeBytes(void)
{
  long RetainedSizeBytes;
  this->get_RetainedSizeBytes((long*)&RetainedSizeBytes);
  return RetainedSizeBytes;
}

template <class T> HRESULT __fastcall
ISpeechPhraseInfoDispT<T>::get_AudioSizeTime(long* AudioSizeTime/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioSizeTime"), DISPID(7));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(AudioSizeTime /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhraseInfoDispT<T>::get_AudioSizeTime(void)
{
  long AudioSizeTime;
  this->get_AudioSizeTime((long*)&AudioSizeTime);
  return AudioSizeTime;
}

template <class T> HRESULT __fastcall
ISpeechPhraseInfoDispT<T>::get_Rule(Speechlib_tlb::ISpeechPhraseRule** Rule/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Rule"), DISPID(8));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechPhraseRule**)Rule /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechPhraseRulePtr __fastcall
ISpeechPhraseInfoDispT<T>::get_Rule(void)
{
  Speechlib_tlb::ISpeechPhraseRulePtr Rule;
  this->get_Rule(&Rule);
  return Rule;
}

template <class T> HRESULT __fastcall
ISpeechPhraseInfoDispT<T>::get_Properties(Speechlib_tlb::ISpeechPhraseProperties** Properties/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Properties"), DISPID(9));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechPhraseProperties**)Properties /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechPhrasePropertiesPtr __fastcall
ISpeechPhraseInfoDispT<T>::get_Properties(void)
{
  Speechlib_tlb::ISpeechPhrasePropertiesPtr Properties;
  this->get_Properties(&Properties);
  return Properties;
}

template <class T> HRESULT __fastcall
ISpeechPhraseInfoDispT<T>::get_Elements(Speechlib_tlb::ISpeechPhraseElements** Elements/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Elements"), DISPID(10));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechPhraseElements**)Elements /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechPhraseElementsPtr __fastcall
ISpeechPhraseInfoDispT<T>::get_Elements(void)
{
  Speechlib_tlb::ISpeechPhraseElementsPtr Elements;
  this->get_Elements(&Elements);
  return Elements;
}

template <class T> HRESULT __fastcall
ISpeechPhraseInfoDispT<T>::get_Replacements(Speechlib_tlb::ISpeechPhraseReplacements** Replacements/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Replacements"), DISPID(11));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechPhraseReplacements**)Replacements /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechPhraseReplacementsPtr __fastcall
ISpeechPhraseInfoDispT<T>::get_Replacements(void)
{
  Speechlib_tlb::ISpeechPhraseReplacementsPtr Replacements;
  this->get_Replacements(&Replacements);
  return Replacements;
}

template <class T> HRESULT __fastcall
ISpeechPhraseInfoDispT<T>::get_EngineId(BSTR* EngineIdGuid/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("EngineId"), DISPID(12));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(EngineIdGuid /*[VT_BSTR:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechPhraseInfoDispT<T>::get_EngineId(void)
{
  BSTR EngineIdGuid;
  this->get_EngineId((BSTR*)&EngineIdGuid);
  return EngineIdGuid;
}

template <class T> HRESULT __fastcall
ISpeechPhraseInfoDispT<T>::get_EnginePrivateData(VARIANT* PrivateData/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("EnginePrivateData"), DISPID(13));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(PrivateData /*[VT_VARIANT:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechPhraseInfoDispT<T>::get_EnginePrivateData(void)
{
  VARIANT PrivateData;
  this->get_EnginePrivateData((VARIANT*)&PrivateData);
  return PrivateData;
}

template <class T> HRESULT __fastcall
ISpeechPhraseInfoDispT<T>::SaveToMemory(VARIANT* PhraseBlock/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("SaveToMemory"), DISPID(14));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(PhraseBlock /*[VT_VARIANT:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechPhraseInfoDispT<T>::SaveToMemory(void)
{
  VARIANT PhraseBlock;
  this->SaveToMemory((VARIANT*)&PhraseBlock);
  return PhraseBlock;
}

template <class T> HRESULT __fastcall
ISpeechPhraseInfoDispT<T>::GetText(long StartElement/*[in,def,opt]*/, long Elements/*[in,def,opt]*/
                                   , VARIANT_BOOL UseReplacements/*[in,def,opt]*/, 
                                   BSTR* Text/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetText"), DISPID(15));
  TAutoArgs<3> _args;
  _args[1] = StartElement /*[VT_I4:0]*/;
  _args[2] = Elements /*[VT_I4:0]*/;
  _args[3] = UseReplacements /*[VT_BOOL:0]*/;
  return OutRetValSetterPtr(Text /*[VT_BSTR:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechPhraseInfoDispT<T>::GetText(long StartElement/*[in,def,opt]*/, long Elements/*[in,def,opt]*/, 
                                   VARIANT_BOOL UseReplacements/*[in,def,opt]*/)
{
  BSTR Text;
  this->GetText(StartElement, Elements, UseReplacements, (BSTR*)&Text);
  return Text;
}

template <class T> HRESULT __fastcall
ISpeechPhraseInfoDispT<T>::GetDisplayAttributes(long StartElement/*[in,def,opt]*/, 
                                                long Elements/*[in,def,opt]*/, 
                                                VARIANT_BOOL UseReplacements/*[in,def,opt]*/, 
                                                Speechlib_tlb::SpeechDisplayAttributes* DisplayAttributes/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetDisplayAttributes"), DISPID(16));
  TAutoArgs<3> _args;
  _args[1] = StartElement /*[VT_I4:0]*/;
  _args[2] = Elements /*[VT_I4:0]*/;
  _args[3] = UseReplacements /*[VT_BOOL:0]*/;
  return OutRetValSetterPtr((int*)DisplayAttributes /*[VT_USERDEFINED:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechDisplayAttributes __fastcall
ISpeechPhraseInfoDispT<T>::GetDisplayAttributes(long StartElement/*[in,def,opt]*/, 
                                                long Elements/*[in,def,opt]*/, 
                                                VARIANT_BOOL UseReplacements/*[in,def,opt]*/)
{
  Speechlib_tlb::SpeechDisplayAttributes DisplayAttributes;
  this->GetDisplayAttributes(StartElement, Elements, UseReplacements, (Speechlib_tlb::SpeechDisplayAttributes*)&DisplayAttributes);
  return DisplayAttributes;
}

// *********************************************************************//
// DispIntf:  ISpeechPhraseRule
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {A7BFE112-A4A0-48D9-B602-C313843F6964}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechPhraseRuleDispT<T>::get_Name(BSTR* Name/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Name"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Name /*[VT_BSTR:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechPhraseRuleDispT<T>::get_Name(void)
{
  BSTR Name;
  this->get_Name((BSTR*)&Name);
  return Name;
}

template <class T> HRESULT __fastcall
ISpeechPhraseRuleDispT<T>::get_Id(long* Id/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Id"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Id /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhraseRuleDispT<T>::get_Id(void)
{
  long Id;
  this->get_Id((long*)&Id);
  return Id;
}

template <class T> HRESULT __fastcall
ISpeechPhraseRuleDispT<T>::get_FirstElement(long* FirstElement/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("FirstElement"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(FirstElement /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhraseRuleDispT<T>::get_FirstElement(void)
{
  long FirstElement;
  this->get_FirstElement((long*)&FirstElement);
  return FirstElement;
}

template <class T> HRESULT __fastcall
ISpeechPhraseRuleDispT<T>::get_NumberOfElements(long* NumberOfElements/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("NumberOfElements"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(NumberOfElements /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhraseRuleDispT<T>::get_NumberOfElements(void)
{
  long NumberOfElements;
  this->get_NumberOfElements((long*)&NumberOfElements);
  return NumberOfElements;
}

template <class T> HRESULT __fastcall
ISpeechPhraseRuleDispT<T>::get_Parent(Speechlib_tlb::ISpeechPhraseRule** Parent/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Parent"), DISPID(5));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechPhraseRule**)Parent /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechPhraseRulePtr __fastcall
ISpeechPhraseRuleDispT<T>::get_Parent(void)
{
  Speechlib_tlb::ISpeechPhraseRulePtr Parent;
  this->get_Parent(&Parent);
  return Parent;
}

template <class T> HRESULT __fastcall
ISpeechPhraseRuleDispT<T>::get_Children(Speechlib_tlb::ISpeechPhraseRules** Children/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Children"), DISPID(6));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechPhraseRules**)Children /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechPhraseRulesPtr __fastcall
ISpeechPhraseRuleDispT<T>::get_Children(void)
{
  Speechlib_tlb::ISpeechPhraseRulesPtr Children;
  this->get_Children(&Children);
  return Children;
}

template <class T> HRESULT __fastcall
ISpeechPhraseRuleDispT<T>::get_Confidence(Speechlib_tlb::SpeechEngineConfidence* ActualConfidence/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Confidence"), DISPID(7));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)ActualConfidence /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechEngineConfidence __fastcall
ISpeechPhraseRuleDispT<T>::get_Confidence(void)
{
  Speechlib_tlb::SpeechEngineConfidence ActualConfidence;
  this->get_Confidence((Speechlib_tlb::SpeechEngineConfidence*)&ActualConfidence);
  return ActualConfidence;
}

template <class T> HRESULT __fastcall
ISpeechPhraseRuleDispT<T>::get_EngineConfidence(float* EngineConfidence/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("EngineConfidence"), DISPID(8));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(EngineConfidence /*[VT_R4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> float __fastcall
ISpeechPhraseRuleDispT<T>::get_EngineConfidence(void)
{
  float EngineConfidence;
  this->get_EngineConfidence((float*)&EngineConfidence);
  return EngineConfidence;
}

// *********************************************************************//
// DispIntf:  ISpeechPhraseRules
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {9047D593-01DD-4B72-81A3-E4A0CA69F407}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechPhraseRulesDispT<T>::get_Count(long* Count/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Count"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Count /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhraseRulesDispT<T>::get_Count(void)
{
  long Count;
  this->get_Count((long*)&Count);
  return Count;
}

template <class T> HRESULT __fastcall
ISpeechPhraseRulesDispT<T>::Item(long Index/*[in]*/, 
                                 Speechlib_tlb::ISpeechPhraseRule** Rule/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Item"), DISPID(0));
  TAutoArgs<1> _args;
  _args[1] = Index /*[VT_I4:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechPhraseRule**)Rule /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechPhraseRule* __fastcall
ISpeechPhraseRulesDispT<T>::Item(long Index/*[in]*/)
{
  Speechlib_tlb::ISpeechPhraseRule* Rule;
  this->Item(Index, (Speechlib_tlb::ISpeechPhraseRule**)&Rule);
  return Rule;
}

template <class T> HRESULT __fastcall
ISpeechPhraseRulesDispT<T>::get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("_NewEnum"), DISPID(-4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(EnumVARIANT /*[VT_UNKNOWN:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> LPUNKNOWN __fastcall
ISpeechPhraseRulesDispT<T>::get__NewEnum(void)
{
  LPUNKNOWN EnumVARIANT;
  this->get__NewEnum((LPUNKNOWN*)&EnumVARIANT);
  return EnumVARIANT;
}

// *********************************************************************//
// DispIntf:  ISpeechPhraseProperties
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {08166B47-102E-4B23-A599-BDB98DBFD1F4}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechPhrasePropertiesDispT<T>::get_Count(long* Count/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Count"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Count /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhrasePropertiesDispT<T>::get_Count(void)
{
  long Count;
  this->get_Count((long*)&Count);
  return Count;
}

template <class T> HRESULT __fastcall
ISpeechPhrasePropertiesDispT<T>::Item(long Index/*[in]*/, 
                                      Speechlib_tlb::ISpeechPhraseProperty** Property/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Item"), DISPID(0));
  TAutoArgs<1> _args;
  _args[1] = Index /*[VT_I4:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechPhraseProperty**)Property /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechPhraseProperty* __fastcall
ISpeechPhrasePropertiesDispT<T>::Item(long Index/*[in]*/)
{
  Speechlib_tlb::ISpeechPhraseProperty* Property;
  this->Item(Index, (Speechlib_tlb::ISpeechPhraseProperty**)&Property);
  return Property;
}

template <class T> HRESULT __fastcall
ISpeechPhrasePropertiesDispT<T>::get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("_NewEnum"), DISPID(-4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(EnumVARIANT /*[VT_UNKNOWN:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> LPUNKNOWN __fastcall
ISpeechPhrasePropertiesDispT<T>::get__NewEnum(void)
{
  LPUNKNOWN EnumVARIANT;
  this->get__NewEnum((LPUNKNOWN*)&EnumVARIANT);
  return EnumVARIANT;
}

// *********************************************************************//
// DispIntf:  ISpeechPhraseProperty
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {CE563D48-961E-4732-A2E1-378A42B430BE}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechPhrasePropertyDispT<T>::get_Name(BSTR* Name/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Name"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Name /*[VT_BSTR:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechPhrasePropertyDispT<T>::get_Name(void)
{
  BSTR Name;
  this->get_Name((BSTR*)&Name);
  return Name;
}

template <class T> HRESULT __fastcall
ISpeechPhrasePropertyDispT<T>::get_Id(long* Id/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Id"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Id /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhrasePropertyDispT<T>::get_Id(void)
{
  long Id;
  this->get_Id((long*)&Id);
  return Id;
}

template <class T> HRESULT __fastcall
ISpeechPhrasePropertyDispT<T>::get_Value(VARIANT* Value/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Value"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Value /*[VT_VARIANT:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechPhrasePropertyDispT<T>::get_Value(void)
{
  VARIANT Value;
  this->get_Value((VARIANT*)&Value);
  return Value;
}

template <class T> HRESULT __fastcall
ISpeechPhrasePropertyDispT<T>::get_FirstElement(long* FirstElement/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("FirstElement"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(FirstElement /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhrasePropertyDispT<T>::get_FirstElement(void)
{
  long FirstElement;
  this->get_FirstElement((long*)&FirstElement);
  return FirstElement;
}

template <class T> HRESULT __fastcall
ISpeechPhrasePropertyDispT<T>::get_NumberOfElements(long* NumberOfElements/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("NumberOfElements"), DISPID(5));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(NumberOfElements /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhrasePropertyDispT<T>::get_NumberOfElements(void)
{
  long NumberOfElements;
  this->get_NumberOfElements((long*)&NumberOfElements);
  return NumberOfElements;
}

template <class T> HRESULT __fastcall
ISpeechPhrasePropertyDispT<T>::get_EngineConfidence(float* Confidence/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("EngineConfidence"), DISPID(6));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Confidence /*[VT_R4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> float __fastcall
ISpeechPhrasePropertyDispT<T>::get_EngineConfidence(void)
{
  float Confidence;
  this->get_EngineConfidence((float*)&Confidence);
  return Confidence;
}

template <class T> HRESULT __fastcall
ISpeechPhrasePropertyDispT<T>::get_Confidence(Speechlib_tlb::SpeechEngineConfidence* Confidence/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Confidence"), DISPID(7));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)Confidence /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechEngineConfidence __fastcall
ISpeechPhrasePropertyDispT<T>::get_Confidence(void)
{
  Speechlib_tlb::SpeechEngineConfidence Confidence;
  this->get_Confidence((Speechlib_tlb::SpeechEngineConfidence*)&Confidence);
  return Confidence;
}

template <class T> HRESULT __fastcall
ISpeechPhrasePropertyDispT<T>::get_Parent(Speechlib_tlb::ISpeechPhraseProperty** ParentProperty/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Parent"), DISPID(8));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechPhraseProperty**)ParentProperty /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechPhrasePropertyPtr __fastcall
ISpeechPhrasePropertyDispT<T>::get_Parent(void)
{
  Speechlib_tlb::ISpeechPhrasePropertyPtr ParentProperty;
  this->get_Parent(&ParentProperty);
  return ParentProperty;
}

template <class T> HRESULT __fastcall
ISpeechPhrasePropertyDispT<T>::get_Children(Speechlib_tlb::ISpeechPhraseProperties** Children/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Children"), DISPID(9));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechPhraseProperties**)Children /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechPhrasePropertiesPtr __fastcall
ISpeechPhrasePropertyDispT<T>::get_Children(void)
{
  Speechlib_tlb::ISpeechPhrasePropertiesPtr Children;
  this->get_Children(&Children);
  return Children;
}

// *********************************************************************//
// DispIntf:  ISpeechPhraseElements
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {0626B328-3478-467D-A0B3-D0853B93DDA3}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechPhraseElementsDispT<T>::get_Count(long* Count/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Count"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Count /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhraseElementsDispT<T>::get_Count(void)
{
  long Count;
  this->get_Count((long*)&Count);
  return Count;
}

template <class T> HRESULT __fastcall
ISpeechPhraseElementsDispT<T>::Item(long Index/*[in]*/, 
                                    Speechlib_tlb::ISpeechPhraseElement** Element/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Item"), DISPID(0));
  TAutoArgs<1> _args;
  _args[1] = Index /*[VT_I4:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechPhraseElement**)Element /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechPhraseElement* __fastcall
ISpeechPhraseElementsDispT<T>::Item(long Index/*[in]*/)
{
  Speechlib_tlb::ISpeechPhraseElement* Element;
  this->Item(Index, (Speechlib_tlb::ISpeechPhraseElement**)&Element);
  return Element;
}

template <class T> HRESULT __fastcall
ISpeechPhraseElementsDispT<T>::get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("_NewEnum"), DISPID(-4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(EnumVARIANT /*[VT_UNKNOWN:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> LPUNKNOWN __fastcall
ISpeechPhraseElementsDispT<T>::get__NewEnum(void)
{
  LPUNKNOWN EnumVARIANT;
  this->get__NewEnum((LPUNKNOWN*)&EnumVARIANT);
  return EnumVARIANT;
}

// *********************************************************************//
// DispIntf:  ISpeechPhraseElement
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {E6176F96-E373-4801-B223-3B62C068C0B4}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechPhraseElementDispT<T>::get_AudioTimeOffset(long* AudioTimeOffset/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioTimeOffset"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(AudioTimeOffset /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhraseElementDispT<T>::get_AudioTimeOffset(void)
{
  long AudioTimeOffset;
  this->get_AudioTimeOffset((long*)&AudioTimeOffset);
  return AudioTimeOffset;
}

template <class T> HRESULT __fastcall
ISpeechPhraseElementDispT<T>::get_AudioSizeTime(long* AudioSizeTime/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioSizeTime"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(AudioSizeTime /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhraseElementDispT<T>::get_AudioSizeTime(void)
{
  long AudioSizeTime;
  this->get_AudioSizeTime((long*)&AudioSizeTime);
  return AudioSizeTime;
}

template <class T> HRESULT __fastcall
ISpeechPhraseElementDispT<T>::get_AudioStreamOffset(long* AudioStreamOffset/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioStreamOffset"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(AudioStreamOffset /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhraseElementDispT<T>::get_AudioStreamOffset(void)
{
  long AudioStreamOffset;
  this->get_AudioStreamOffset((long*)&AudioStreamOffset);
  return AudioStreamOffset;
}

template <class T> HRESULT __fastcall
ISpeechPhraseElementDispT<T>::get_AudioSizeBytes(long* AudioSizeBytes/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioSizeBytes"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(AudioSizeBytes /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhraseElementDispT<T>::get_AudioSizeBytes(void)
{
  long AudioSizeBytes;
  this->get_AudioSizeBytes((long*)&AudioSizeBytes);
  return AudioSizeBytes;
}

template <class T> HRESULT __fastcall
ISpeechPhraseElementDispT<T>::get_RetainedStreamOffset(long* RetainedStreamOffset/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RetainedStreamOffset"), DISPID(5));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(RetainedStreamOffset /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhraseElementDispT<T>::get_RetainedStreamOffset(void)
{
  long RetainedStreamOffset;
  this->get_RetainedStreamOffset((long*)&RetainedStreamOffset);
  return RetainedStreamOffset;
}

template <class T> HRESULT __fastcall
ISpeechPhraseElementDispT<T>::get_RetainedSizeBytes(long* RetainedSizeBytes/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RetainedSizeBytes"), DISPID(6));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(RetainedSizeBytes /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhraseElementDispT<T>::get_RetainedSizeBytes(void)
{
  long RetainedSizeBytes;
  this->get_RetainedSizeBytes((long*)&RetainedSizeBytes);
  return RetainedSizeBytes;
}

template <class T> HRESULT __fastcall
ISpeechPhraseElementDispT<T>::get_DisplayText(BSTR* DisplayText/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("DisplayText"), DISPID(7));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(DisplayText /*[VT_BSTR:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechPhraseElementDispT<T>::get_DisplayText(void)
{
  BSTR DisplayText;
  this->get_DisplayText((BSTR*)&DisplayText);
  return DisplayText;
}

template <class T> HRESULT __fastcall
ISpeechPhraseElementDispT<T>::get_LexicalForm(BSTR* LexicalForm/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("LexicalForm"), DISPID(8));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(LexicalForm /*[VT_BSTR:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechPhraseElementDispT<T>::get_LexicalForm(void)
{
  BSTR LexicalForm;
  this->get_LexicalForm((BSTR*)&LexicalForm);
  return LexicalForm;
}

template <class T> HRESULT __fastcall
ISpeechPhraseElementDispT<T>::get_Pronunciation(VARIANT* Pronunciation/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Pronunciation"), DISPID(9));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Pronunciation /*[VT_VARIANT:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechPhraseElementDispT<T>::get_Pronunciation(void)
{
  VARIANT Pronunciation;
  this->get_Pronunciation((VARIANT*)&Pronunciation);
  return Pronunciation;
}

template <class T> HRESULT __fastcall
ISpeechPhraseElementDispT<T>::get_DisplayAttributes(Speechlib_tlb::SpeechDisplayAttributes* DisplayAttributes/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("DisplayAttributes"), DISPID(10));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)DisplayAttributes /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechDisplayAttributes __fastcall
ISpeechPhraseElementDispT<T>::get_DisplayAttributes(void)
{
  Speechlib_tlb::SpeechDisplayAttributes DisplayAttributes;
  this->get_DisplayAttributes((Speechlib_tlb::SpeechDisplayAttributes*)&DisplayAttributes);
  return DisplayAttributes;
}

template <class T> HRESULT __fastcall
ISpeechPhraseElementDispT<T>::get_RequiredConfidence(Speechlib_tlb::SpeechEngineConfidence* RequiredConfidence/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RequiredConfidence"), DISPID(11));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)RequiredConfidence /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechEngineConfidence __fastcall
ISpeechPhraseElementDispT<T>::get_RequiredConfidence(void)
{
  Speechlib_tlb::SpeechEngineConfidence RequiredConfidence;
  this->get_RequiredConfidence((Speechlib_tlb::SpeechEngineConfidence*)&RequiredConfidence);
  return RequiredConfidence;
}

template <class T> HRESULT __fastcall
ISpeechPhraseElementDispT<T>::get_ActualConfidence(Speechlib_tlb::SpeechEngineConfidence* ActualConfidence/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("ActualConfidence"), DISPID(12));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)ActualConfidence /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechEngineConfidence __fastcall
ISpeechPhraseElementDispT<T>::get_ActualConfidence(void)
{
  Speechlib_tlb::SpeechEngineConfidence ActualConfidence;
  this->get_ActualConfidence((Speechlib_tlb::SpeechEngineConfidence*)&ActualConfidence);
  return ActualConfidence;
}

template <class T> HRESULT __fastcall
ISpeechPhraseElementDispT<T>::get_EngineConfidence(float* EngineConfidence/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("EngineConfidence"), DISPID(13));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(EngineConfidence /*[VT_R4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> float __fastcall
ISpeechPhraseElementDispT<T>::get_EngineConfidence(void)
{
  float EngineConfidence;
  this->get_EngineConfidence((float*)&EngineConfidence);
  return EngineConfidence;
}

// *********************************************************************//
// DispIntf:  ISpeechPhraseReplacements
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {38BC662F-2257-4525-959E-2069D2596C05}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechPhraseReplacementsDispT<T>::get_Count(long* Count/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Count"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Count /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhraseReplacementsDispT<T>::get_Count(void)
{
  long Count;
  this->get_Count((long*)&Count);
  return Count;
}

template <class T> HRESULT __fastcall
ISpeechPhraseReplacementsDispT<T>::Item(long Index/*[in]*/, 
                                        Speechlib_tlb::ISpeechPhraseReplacement** Reps/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Item"), DISPID(0));
  TAutoArgs<1> _args;
  _args[1] = Index /*[VT_I4:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechPhraseReplacement**)Reps /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechPhraseReplacement* __fastcall
ISpeechPhraseReplacementsDispT<T>::Item(long Index/*[in]*/)
{
  Speechlib_tlb::ISpeechPhraseReplacement* Reps;
  this->Item(Index, (Speechlib_tlb::ISpeechPhraseReplacement**)&Reps);
  return Reps;
}

template <class T> HRESULT __fastcall
ISpeechPhraseReplacementsDispT<T>::get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("_NewEnum"), DISPID(-4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(EnumVARIANT /*[VT_UNKNOWN:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> LPUNKNOWN __fastcall
ISpeechPhraseReplacementsDispT<T>::get__NewEnum(void)
{
  LPUNKNOWN EnumVARIANT;
  this->get__NewEnum((LPUNKNOWN*)&EnumVARIANT);
  return EnumVARIANT;
}

// *********************************************************************//
// DispIntf:  ISpeechPhraseReplacement
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {2890A410-53A7-4FB5-94EC-06D4998E3D02}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechPhraseReplacementDispT<T>::get_DisplayAttributes(Speechlib_tlb::SpeechDisplayAttributes* DisplayAttributes/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("DisplayAttributes"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)DisplayAttributes /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechDisplayAttributes __fastcall
ISpeechPhraseReplacementDispT<T>::get_DisplayAttributes(void)
{
  Speechlib_tlb::SpeechDisplayAttributes DisplayAttributes;
  this->get_DisplayAttributes((Speechlib_tlb::SpeechDisplayAttributes*)&DisplayAttributes);
  return DisplayAttributes;
}

template <class T> HRESULT __fastcall
ISpeechPhraseReplacementDispT<T>::get_Text(BSTR* Text/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Text"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Text /*[VT_BSTR:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechPhraseReplacementDispT<T>::get_Text(void)
{
  BSTR Text;
  this->get_Text((BSTR*)&Text);
  return Text;
}

template <class T> HRESULT __fastcall
ISpeechPhraseReplacementDispT<T>::get_FirstElement(long* FirstElement/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("FirstElement"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(FirstElement /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhraseReplacementDispT<T>::get_FirstElement(void)
{
  long FirstElement;
  this->get_FirstElement((long*)&FirstElement);
  return FirstElement;
}

template <class T> HRESULT __fastcall
ISpeechPhraseReplacementDispT<T>::get_NumberOfElements(long* NumberOfElements/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("NumberOfElements"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(NumberOfElements /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhraseReplacementDispT<T>::get_NumberOfElements(void)
{
  long NumberOfElements;
  this->get_NumberOfElements((long*)&NumberOfElements);
  return NumberOfElements;
}

// *********************************************************************//
// DispIntf:  ISpeechPhraseAlternates
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {B238B6D5-F276-4C3D-A6C1-2974801C3CC2}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechPhraseAlternatesDispT<T>::get_Count(long* Count/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Count"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Count /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhraseAlternatesDispT<T>::get_Count(void)
{
  long Count;
  this->get_Count((long*)&Count);
  return Count;
}

template <class T> HRESULT __fastcall
ISpeechPhraseAlternatesDispT<T>::Item(long Index/*[in]*/, 
                                      Speechlib_tlb::ISpeechPhraseAlternate** PhraseAlternate/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Item"), DISPID(0));
  TAutoArgs<1> _args;
  _args[1] = Index /*[VT_I4:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechPhraseAlternate**)PhraseAlternate /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechPhraseAlternate* __fastcall
ISpeechPhraseAlternatesDispT<T>::Item(long Index/*[in]*/)
{
  Speechlib_tlb::ISpeechPhraseAlternate* PhraseAlternate;
  this->Item(Index, (Speechlib_tlb::ISpeechPhraseAlternate**)&PhraseAlternate);
  return PhraseAlternate;
}

template <class T> HRESULT __fastcall
ISpeechPhraseAlternatesDispT<T>::get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("_NewEnum"), DISPID(-4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(EnumVARIANT /*[VT_UNKNOWN:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> LPUNKNOWN __fastcall
ISpeechPhraseAlternatesDispT<T>::get__NewEnum(void)
{
  LPUNKNOWN EnumVARIANT;
  this->get__NewEnum((LPUNKNOWN*)&EnumVARIANT);
  return EnumVARIANT;
}

// *********************************************************************//
// DispIntf:  ISpeechPhraseAlternate
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {27864A2A-2B9F-4CB8-92D3-0D2722FD1E73}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechPhraseAlternateDispT<T>::get_RecoResult(Speechlib_tlb::ISpeechRecoResult** RecoResult/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RecoResult"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechRecoResult**)RecoResult /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechRecoResultPtr __fastcall
ISpeechPhraseAlternateDispT<T>::get_RecoResult(void)
{
  Speechlib_tlb::ISpeechRecoResultPtr RecoResult;
  this->get_RecoResult(&RecoResult);
  return RecoResult;
}

template <class T> HRESULT __fastcall
ISpeechPhraseAlternateDispT<T>::get_StartElementInResult(long* StartElement/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("StartElementInResult"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(StartElement /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhraseAlternateDispT<T>::get_StartElementInResult(void)
{
  long StartElement;
  this->get_StartElementInResult((long*)&StartElement);
  return StartElement;
}

template <class T> HRESULT __fastcall
ISpeechPhraseAlternateDispT<T>::get_NumberOfElementsInResult(long* NumberOfElements/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("NumberOfElementsInResult"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(NumberOfElements /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhraseAlternateDispT<T>::get_NumberOfElementsInResult(void)
{
  long NumberOfElements;
  this->get_NumberOfElementsInResult((long*)&NumberOfElements);
  return NumberOfElements;
}

template <class T> HRESULT __fastcall
ISpeechPhraseAlternateDispT<T>::get_PhraseInfo(Speechlib_tlb::ISpeechPhraseInfo** PhraseInfo/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("PhraseInfo"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechPhraseInfo**)PhraseInfo /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechPhraseInfoPtr __fastcall
ISpeechPhraseAlternateDispT<T>::get_PhraseInfo(void)
{
  Speechlib_tlb::ISpeechPhraseInfoPtr PhraseInfo;
  this->get_PhraseInfo(&PhraseInfo);
  return PhraseInfo;
}

template <class T> HRESULT __fastcall
ISpeechPhraseAlternateDispT<T>::Commit()
{
  _TDispID _dispid(*this, OLETEXT("Commit"), DISPID(5));
  return OleFunction(_dispid);
}

// *********************************************************************//
// DispIntf:  _ISpeechRecoContextEvents
// Flags:     (4096) Dispatchable
// GUID:      {7B8FCB42-0E9D-4F00-A048-7B04D6179D3D}
// *********************************************************************//
template <class T> void __fastcall
_ISpeechRecoContextEventsDispT<T>::StartStream(long StreamNumber/*[in]*/, 
                                               VARIANT StreamPosition/*[in]*/)
{
  _TDispID _dispid(/* StartStream */ DISPID(1));
  TAutoArgs<2> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechRecoContextEventsDispT<T>::EndStream(long StreamNumber/*[in]*/, 
                                             VARIANT StreamPosition/*[in]*/, 
                                             VARIANT_BOOL StreamReleased/*[in]*/)
{
  _TDispID _dispid(/* EndStream */ DISPID(2));
  TAutoArgs<3> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  _args[3] = StreamReleased /*[VT_BOOL:0]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechRecoContextEventsDispT<T>::Bookmark(long StreamNumber/*[in]*/, 
                                            VARIANT StreamPosition/*[in]*/, 
                                            VARIANT BookmarkId/*[in]*/, 
                                            Speechlib_tlb::SpeechBookmarkOptions Options/*[in]*/)
{
  _TDispID _dispid(/* Bookmark */ DISPID(3));
  TAutoArgs<4> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  _args[3] = BookmarkId /*[VT_VARIANT:0]*/;
  _args[4] = (int)Options /*[VT_USERDEFINED:0]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechRecoContextEventsDispT<T>::SoundStart(long StreamNumber/*[in]*/, 
                                              VARIANT StreamPosition/*[in]*/)
{
  _TDispID _dispid(/* SoundStart */ DISPID(4));
  TAutoArgs<2> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechRecoContextEventsDispT<T>::SoundEnd(long StreamNumber/*[in]*/, 
                                            VARIANT StreamPosition/*[in]*/)
{
  _TDispID _dispid(/* SoundEnd */ DISPID(5));
  TAutoArgs<2> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechRecoContextEventsDispT<T>::PhraseStart(long StreamNumber/*[in]*/, 
                                               VARIANT StreamPosition/*[in]*/)
{
  _TDispID _dispid(/* PhraseStart */ DISPID(6));
  TAutoArgs<2> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechRecoContextEventsDispT<T>::Recognition(long StreamNumber/*[in]*/, 
                                               VARIANT StreamPosition/*[in]*/, 
                                               Speechlib_tlb::SpeechRecognitionType RecognitionType/*[in]*/
                                               , Speechlib_tlb::ISpeechRecoResult* Result/*[in]*/)
{
  _TDispID _dispid(/* Recognition */ DISPID(7));
  TAutoArgs<4> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  _args[3] = (int)RecognitionType /*[VT_USERDEFINED:0]*/;
  _args[4] = (LPDISPATCH)(Speechlib_tlb::ISpeechRecoResult*)Result /*[VT_USERDEFINED:1]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechRecoContextEventsDispT<T>::Hypothesis(long StreamNumber/*[in]*/, 
                                              VARIANT StreamPosition/*[in]*/, 
                                              Speechlib_tlb::ISpeechRecoResult* Result/*[in]*/)
{
  _TDispID _dispid(/* Hypothesis */ DISPID(8));
  TAutoArgs<3> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  _args[3] = (LPDISPATCH)(Speechlib_tlb::ISpeechRecoResult*)Result /*[VT_USERDEFINED:1]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechRecoContextEventsDispT<T>::PropertyNumberChange(long StreamNumber/*[in]*/, 
                                                        VARIANT StreamPosition/*[in]*/, 
                                                        BSTR PropertyName/*[in]*/, 
                                                        long NewNumberValue/*[in]*/)
{
  _TDispID _dispid(/* PropertyNumberChange */ DISPID(9));
  TAutoArgs<4> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  _args[3] = PropertyName /*[VT_BSTR:0]*/;
  _args[4] = NewNumberValue /*[VT_I4:0]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechRecoContextEventsDispT<T>::PropertyStringChange(long StreamNumber/*[in]*/, 
                                                        VARIANT StreamPosition/*[in]*/, 
                                                        BSTR PropertyName/*[in]*/, 
                                                        BSTR NewStringValue/*[in]*/)
{
  _TDispID _dispid(/* PropertyStringChange */ DISPID(10));
  TAutoArgs<4> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  _args[3] = PropertyName /*[VT_BSTR:0]*/;
  _args[4] = NewStringValue /*[VT_BSTR:0]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechRecoContextEventsDispT<T>::FalseRecognition(long StreamNumber/*[in]*/, 
                                                    VARIANT StreamPosition/*[in]*/, 
                                                    Speechlib_tlb::ISpeechRecoResult* Result/*[in]*/)
{
  _TDispID _dispid(/* FalseRecognition */ DISPID(11));
  TAutoArgs<3> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  _args[3] = (LPDISPATCH)(Speechlib_tlb::ISpeechRecoResult*)Result /*[VT_USERDEFINED:1]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechRecoContextEventsDispT<T>::Interference(long StreamNumber/*[in]*/, 
                                                VARIANT StreamPosition/*[in]*/, 
                                                Speechlib_tlb::SpeechInterference Interference/*[in]*/)
{
  _TDispID _dispid(/* Interference */ DISPID(12));
  TAutoArgs<3> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  _args[3] = (int)Interference /*[VT_USERDEFINED:0]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechRecoContextEventsDispT<T>::RequestUI(long StreamNumber/*[in]*/, 
                                             VARIANT StreamPosition/*[in]*/, BSTR UIType/*[in]*/)
{
  _TDispID _dispid(/* RequestUI */ DISPID(13));
  TAutoArgs<3> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  _args[3] = UIType /*[VT_BSTR:0]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechRecoContextEventsDispT<T>::RecognizerStateChange(long StreamNumber/*[in]*/, 
                                                         VARIANT StreamPosition/*[in]*/, 
                                                         Speechlib_tlb::SpeechRecognizerState NewState/*[in]*/)
{
  _TDispID _dispid(/* RecognizerStateChange */ DISPID(14));
  TAutoArgs<3> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  _args[3] = (int)NewState /*[VT_USERDEFINED:0]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechRecoContextEventsDispT<T>::Adaptation(long StreamNumber/*[in]*/, 
                                              VARIANT StreamPosition/*[in]*/)
{
  _TDispID _dispid(/* Adaptation */ DISPID(15));
  TAutoArgs<2> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechRecoContextEventsDispT<T>::RecognitionForOtherContext(long StreamNumber/*[in]*/, 
                                                              VARIANT StreamPosition/*[in]*/)
{
  _TDispID _dispid(/* RecognitionForOtherContext */ DISPID(16));
  TAutoArgs<2> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechRecoContextEventsDispT<T>::AudioLevel(long StreamNumber/*[in]*/, 
                                              VARIANT StreamPosition/*[in]*/, 
                                              long AudioLevel/*[in]*/)
{
  _TDispID _dispid(/* AudioLevel */ DISPID(17));
  TAutoArgs<3> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  _args[3] = AudioLevel /*[VT_I4:0]*/;
  OleProcedure(_dispid, _args);
}

template <class T> void __fastcall
_ISpeechRecoContextEventsDispT<T>::EnginePrivate(long StreamNumber/*[in]*/, 
                                                 VARIANT StreamPosition/*[in]*/, 
                                                 VARIANT EngineData/*[in]*/)
{
  _TDispID _dispid(/* EnginePrivate */ DISPID(18));
  TAutoArgs<3> _args;
  _args[1] = StreamNumber /*[VT_I4:0]*/;
  _args[2] = StreamPosition /*[VT_VARIANT:0]*/;
  _args[3] = EngineData /*[VT_VARIANT:0]*/;
  OleProcedure(_dispid, _args);
}

// *********************************************************************//
// DispIntf:  ISpeechRecoResult2
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {8E0A246D-D3C8-45DE-8657-04290C458C3C}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechRecoResult2DispT<T>::SetTextFeedback(BSTR Feedback/*[in]*/, 
                                            VARIANT_BOOL WasSuccessful/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("SetTextFeedback"), DISPID(12));
  TAutoArgs<2> _args;
  _args[1] = Feedback /*[VT_BSTR:0]*/;
  _args[2] = WasSuccessful /*[VT_BOOL:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoResult2DispT<T>::get_RecoContext(Speechlib_tlb::ISpeechRecoContext** RecoContext/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RecoContext"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechRecoContext**)RecoContext /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechRecoContextPtr __fastcall
ISpeechRecoResult2DispT<T>::get_RecoContext(void)
{
  Speechlib_tlb::ISpeechRecoContextPtr RecoContext;
  this->get_RecoContext(&RecoContext);
  return RecoContext;
}

template <class T> HRESULT __fastcall
ISpeechRecoResult2DispT<T>::get_Times(Speechlib_tlb::ISpeechRecoResultTimes** Times/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Times"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechRecoResultTimes**)Times /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechRecoResultTimesPtr __fastcall
ISpeechRecoResult2DispT<T>::get_Times(void)
{
  Speechlib_tlb::ISpeechRecoResultTimesPtr Times;
  this->get_Times(&Times);
  return Times;
}

template <class T> HRESULT __fastcall
ISpeechRecoResult2DispT<T>::_set_AudioFormat(Speechlib_tlb::ISpeechAudioFormat* Format/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioFormat"), DISPID(3));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechAudioFormat*)Format /*[VT_USERDEFINED:1]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoResult2DispT<T>::get_AudioFormat(Speechlib_tlb::ISpeechAudioFormat** Format/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioFormat"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechAudioFormat**)Format /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechAudioFormatPtr __fastcall
ISpeechRecoResult2DispT<T>::get_AudioFormat(void)
{
  Speechlib_tlb::ISpeechAudioFormatPtr Format;
  this->get_AudioFormat(&Format);
  return Format;
}

template <class T> HRESULT __fastcall
ISpeechRecoResult2DispT<T>::get_PhraseInfo(Speechlib_tlb::ISpeechPhraseInfo** PhraseInfo/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("PhraseInfo"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechPhraseInfo**)PhraseInfo /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechPhraseInfoPtr __fastcall
ISpeechRecoResult2DispT<T>::get_PhraseInfo(void)
{
  Speechlib_tlb::ISpeechPhraseInfoPtr PhraseInfo;
  this->get_PhraseInfo(&PhraseInfo);
  return PhraseInfo;
}

template <class T> HRESULT __fastcall
ISpeechRecoResult2DispT<T>::Alternates(long RequestCount/*[in]*/, long StartElement/*[in,def,opt]*/
                                       , long Elements/*[in,def,opt]*/, 
                                       Speechlib_tlb::ISpeechPhraseAlternates** Alternates/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Alternates"), DISPID(5));
  TAutoArgs<3> _args;
  _args[1] = RequestCount /*[VT_I4:0]*/;
  _args[2] = StartElement /*[VT_I4:0]*/;
  _args[3] = Elements /*[VT_I4:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechPhraseAlternates**)Alternates /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechPhraseAlternates* __fastcall
ISpeechRecoResult2DispT<T>::Alternates(long RequestCount/*[in]*/, long StartElement/*[in,def,opt]*/, 
                                       long Elements/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechPhraseAlternates* Alternates;
  this->Alternates(RequestCount, StartElement, Elements, (Speechlib_tlb::ISpeechPhraseAlternates**)&Alternates);
  return Alternates;
}

template <class T> HRESULT __fastcall
ISpeechRecoResult2DispT<T>::Audio(long StartElement/*[in,def,opt]*/, long Elements/*[in,def,opt]*/, 
                                  Speechlib_tlb::ISpeechMemoryStream** Stream/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Audio"), DISPID(6));
  TAutoArgs<2> _args;
  _args[1] = StartElement /*[VT_I4:0]*/;
  _args[2] = Elements /*[VT_I4:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechMemoryStream**)Stream /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechMemoryStream* __fastcall
ISpeechRecoResult2DispT<T>::Audio(long StartElement/*[in,def,opt]*/, long Elements/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechMemoryStream* Stream;
  this->Audio(StartElement, Elements, (Speechlib_tlb::ISpeechMemoryStream**)&Stream);
  return Stream;
}

template <class T> HRESULT __fastcall
ISpeechRecoResult2DispT<T>::SpeakAudio(long StartElement/*[in,def,opt]*/, 
                                       long Elements/*[in,def,opt]*/, 
                                       Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/, 
                                       long* StreamNumber/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("SpeakAudio"), DISPID(7));
  TAutoArgs<3> _args;
  _args[1] = StartElement /*[VT_I4:0]*/;
  _args[2] = Elements /*[VT_I4:0]*/;
  _args[3] = (int)Flags /*[VT_USERDEFINED:0]*/;
  return OutRetValSetterPtr(StreamNumber /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
ISpeechRecoResult2DispT<T>::SpeakAudio(long StartElement/*[in,def,opt]*/, 
                                       long Elements/*[in,def,opt]*/, 
                                       Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/)
{
  long StreamNumber;
  this->SpeakAudio(StartElement, Elements, Flags, (long*)&StreamNumber);
  return StreamNumber;
}

template <class T> HRESULT __fastcall
ISpeechRecoResult2DispT<T>::SaveToMemory(VARIANT* ResultBlock/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("SaveToMemory"), DISPID(8));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(ResultBlock /*[VT_VARIANT:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechRecoResult2DispT<T>::SaveToMemory(void)
{
  VARIANT ResultBlock;
  this->SaveToMemory((VARIANT*)&ResultBlock);
  return ResultBlock;
}

template <class T> HRESULT __fastcall
ISpeechRecoResult2DispT<T>::DiscardResultInfo(Speechlib_tlb::SpeechDiscardType ValueTypes/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("DiscardResultInfo"), DISPID(9));
  TAutoArgs<1> _args;
  _args[1] = (int)ValueTypes /*[VT_USERDEFINED:0]*/;
  return OleFunction(_dispid, _args);
}

// *********************************************************************//
// SmartIntf: TCOMISpeechLexicon
// Interface: ISpeechLexicon
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMISpeechLexiconT<T>::get_GenerationId(long* GenerationId/*[out,retval]*/)
{
  return (*this)->get_GenerationId(GenerationId);
}

template <class T> long __fastcall
TCOMISpeechLexiconT<T>::get_GenerationId(void)
{
  long GenerationId;
  OLECHECK(this->get_GenerationId((long*)&GenerationId));
  return GenerationId;
}

template <class T> HRESULT __fastcall
TCOMISpeechLexiconT<T>::GetWords(Speechlib_tlb::SpeechLexiconType Flags/*[in,def,opt]*/, 
                                 long* GenerationId/*[out,def,opt]*/, 
                                 Speechlib_tlb::ISpeechLexiconWords** Words/*[out,retval]*/)
{
  return (*this)->GetWords(Flags, GenerationId, Words);
}

template <class T> Speechlib_tlb::ISpeechLexiconWords* __fastcall
TCOMISpeechLexiconT<T>::GetWords(Speechlib_tlb::SpeechLexiconType Flags/*[in,def,opt]*/, 
                                 long* GenerationId/*[out,def,opt]*/)
{
  Speechlib_tlb::ISpeechLexiconWords* Words;
  OLECHECK(this->GetWords(Flags/*[in,def,opt]*/, GenerationId/*[out,def,opt]*/, (Speechlib_tlb::ISpeechLexiconWords**)&Words));
  return Words;
}

template <class T> HRESULT __fastcall
TCOMISpeechLexiconT<T>::AddPronunciation(BSTR bstrWord/*[in]*/, long LangId/*[in]*/, 
                                         Speechlib_tlb::SpeechPartOfSpeech PartOfSpeech/*[in,def,opt]*/, 
                                         BSTR bstrPronunciation/*[in,def,opt]*/)
{
  return (*this)->AddPronunciation(bstrWord, LangId, PartOfSpeech, bstrPronunciation);
}

template <class T> HRESULT __fastcall
TCOMISpeechLexiconT<T>::AddPronunciationByPhoneIds(BSTR bstrWord/*[in]*/, long LangId/*[in]*/, 
                                                   Speechlib_tlb::SpeechPartOfSpeech PartOfSpeech/*[in,def,opt]*/, 
                                                   VARIANT* PhoneIds/*[in,def,opt]*/)
{
  return (*this)->AddPronunciationByPhoneIds(bstrWord, LangId, PartOfSpeech, PhoneIds);
}

template <class T> HRESULT __fastcall
TCOMISpeechLexiconT<T>::RemovePronunciation(BSTR bstrWord/*[in]*/, long LangId/*[in]*/, 
                                            Speechlib_tlb::SpeechPartOfSpeech PartOfSpeech/*[in,def,opt]*/, 
                                            BSTR bstrPronunciation/*[in,def,opt]*/)
{
  return (*this)->RemovePronunciation(bstrWord, LangId, PartOfSpeech, bstrPronunciation);
}

template <class T> HRESULT __fastcall
TCOMISpeechLexiconT<T>::RemovePronunciationByPhoneIds(BSTR bstrWord/*[in]*/, long LangId/*[in]*/, 
                                                      Speechlib_tlb::SpeechPartOfSpeech PartOfSpeech/*[in,def,opt]*/, 
                                                      VARIANT* PhoneIds/*[in,def,opt]*/)
{
  return (*this)->RemovePronunciationByPhoneIds(bstrWord, LangId, PartOfSpeech, PhoneIds);
}

template <class T> HRESULT __fastcall
TCOMISpeechLexiconT<T>::GetPronunciations(BSTR bstrWord/*[in]*/, long LangId/*[in,def,opt]*/, 
                                          Speechlib_tlb::SpeechLexiconType TypeFlags/*[in,def,opt]*/, 
                                          Speechlib_tlb::ISpeechLexiconPronunciations** ppPronunciations/*[out,retval]*/)
{
  return (*this)->GetPronunciations(bstrWord, LangId, TypeFlags, ppPronunciations);
}

template <class T> Speechlib_tlb::ISpeechLexiconPronunciations* __fastcall
TCOMISpeechLexiconT<T>::GetPronunciations(BSTR bstrWord/*[in]*/, long LangId/*[in,def,opt]*/, 
                                          Speechlib_tlb::SpeechLexiconType TypeFlags/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechLexiconPronunciations* ppPronunciations;
  OLECHECK(this->GetPronunciations(bstrWord/*[in]*/, LangId/*[in,def,opt]*/, 
                                   TypeFlags/*[in,def,opt]*/, (Speechlib_tlb::ISpeechLexiconPronunciations**)&ppPronunciations));
  return ppPronunciations;
}

template <class T> HRESULT __fastcall
TCOMISpeechLexiconT<T>::GetGenerationChange(long* GenerationId/*[in,out]*/, 
                                            Speechlib_tlb::ISpeechLexiconWords** ppWords/*[out,retval]*/)
{
  return (*this)->GetGenerationChange(GenerationId, ppWords);
}

template <class T> Speechlib_tlb::ISpeechLexiconWords* __fastcall
TCOMISpeechLexiconT<T>::GetGenerationChange(long* GenerationId/*[in,out]*/)
{
  Speechlib_tlb::ISpeechLexiconWords* ppWords;
  OLECHECK(this->GetGenerationChange(GenerationId/*[in,out]*/, (Speechlib_tlb::ISpeechLexiconWords**)&ppWords));
  return ppWords;
}

// *********************************************************************//
// DispIntf:  ISpeechLexicon
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {3DA7627A-C7AE-4B23-8708-638C50362C25}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechLexiconDispT<T>::get_GenerationId(long* GenerationId/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GenerationId"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(GenerationId /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechLexiconDispT<T>::get_GenerationId(void)
{
  long GenerationId;
  this->get_GenerationId((long*)&GenerationId);
  return GenerationId;
}

template <class T> HRESULT __fastcall
ISpeechLexiconDispT<T>::GetWords(Speechlib_tlb::SpeechLexiconType Flags/*[in,def,opt]*/, 
                                 long* GenerationId/*[out,def,opt]*/, 
                                 Speechlib_tlb::ISpeechLexiconWords** Words/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetWords"), DISPID(2));
  TAutoArgs<2> _args;
  _args[1] = (int)Flags /*[VT_USERDEFINED:0]*/;
  _args[2] = GenerationId /*[VT_I4:1]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechLexiconWords**)Words /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechLexiconWords* __fastcall
ISpeechLexiconDispT<T>::GetWords(Speechlib_tlb::SpeechLexiconType Flags/*[in,def,opt]*/, 
                                 long* GenerationId/*[out,def,opt]*/)
{
  Speechlib_tlb::ISpeechLexiconWords* Words;
  this->GetWords(Flags, GenerationId, (Speechlib_tlb::ISpeechLexiconWords**)&Words);
  return Words;
}

template <class T> HRESULT __fastcall
ISpeechLexiconDispT<T>::AddPronunciation(BSTR bstrWord/*[in]*/, long LangId/*[in]*/, 
                                         Speechlib_tlb::SpeechPartOfSpeech PartOfSpeech/*[in,def,opt]*/
                                         , BSTR bstrPronunciation/*[in,def,opt]*/)
{
  _TDispID _dispid(*this, OLETEXT("AddPronunciation"), DISPID(3));
  TAutoArgs<4> _args;
  _args[1] = bstrWord /*[VT_BSTR:0]*/;
  _args[2] = LangId /*[VT_I4:0]*/;
  _args[3] = (int)PartOfSpeech /*[VT_USERDEFINED:0]*/;
  _args[4] = bstrPronunciation /*[VT_BSTR:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechLexiconDispT<T>::AddPronunciationByPhoneIds(BSTR bstrWord/*[in]*/, long LangId/*[in]*/, 
                                                   Speechlib_tlb::SpeechPartOfSpeech PartOfSpeech/*[in,def,opt]*/
                                                   , VARIANT* PhoneIds/*[in,def,opt]*/)
{
  _TDispID _dispid(*this, OLETEXT("AddPronunciationByPhoneIds"), DISPID(4));
  TAutoArgs<4> _args;
  _args[1] = bstrWord /*[VT_BSTR:0]*/;
  _args[2] = LangId /*[VT_I4:0]*/;
  _args[3] = (int)PartOfSpeech /*[VT_USERDEFINED:0]*/;
  _args[4] = PhoneIds /*[VT_VARIANT:1]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechLexiconDispT<T>::RemovePronunciation(BSTR bstrWord/*[in]*/, long LangId/*[in]*/, 
                                            Speechlib_tlb::SpeechPartOfSpeech PartOfSpeech/*[in,def,opt]*/
                                            , BSTR bstrPronunciation/*[in,def,opt]*/)
{
  _TDispID _dispid(*this, OLETEXT("RemovePronunciation"), DISPID(5));
  TAutoArgs<4> _args;
  _args[1] = bstrWord /*[VT_BSTR:0]*/;
  _args[2] = LangId /*[VT_I4:0]*/;
  _args[3] = (int)PartOfSpeech /*[VT_USERDEFINED:0]*/;
  _args[4] = bstrPronunciation /*[VT_BSTR:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechLexiconDispT<T>::RemovePronunciationByPhoneIds(BSTR bstrWord/*[in]*/, long LangId/*[in]*/, 
                                                      Speechlib_tlb::SpeechPartOfSpeech PartOfSpeech/*[in,def,opt]*/
                                                      , VARIANT* PhoneIds/*[in,def,opt]*/)
{
  _TDispID _dispid(*this, OLETEXT("RemovePronunciationByPhoneIds"), DISPID(6));
  TAutoArgs<4> _args;
  _args[1] = bstrWord /*[VT_BSTR:0]*/;
  _args[2] = LangId /*[VT_I4:0]*/;
  _args[3] = (int)PartOfSpeech /*[VT_USERDEFINED:0]*/;
  _args[4] = PhoneIds /*[VT_VARIANT:1]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechLexiconDispT<T>::GetPronunciations(BSTR bstrWord/*[in]*/, long LangId/*[in,def,opt]*/, 
                                          Speechlib_tlb::SpeechLexiconType TypeFlags/*[in,def,opt]*/
                                          , 
                                          Speechlib_tlb::ISpeechLexiconPronunciations** ppPronunciations/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetPronunciations"), DISPID(7));
  TAutoArgs<3> _args;
  _args[1] = bstrWord /*[VT_BSTR:0]*/;
  _args[2] = LangId /*[VT_I4:0]*/;
  _args[3] = (int)TypeFlags /*[VT_USERDEFINED:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechLexiconPronunciations**)ppPronunciations /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechLexiconPronunciations* __fastcall
ISpeechLexiconDispT<T>::GetPronunciations(BSTR bstrWord/*[in]*/, long LangId/*[in,def,opt]*/, 
                                          Speechlib_tlb::SpeechLexiconType TypeFlags/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechLexiconPronunciations* ppPronunciations;
  this->GetPronunciations(bstrWord, LangId, TypeFlags, (Speechlib_tlb::ISpeechLexiconPronunciations**)&ppPronunciations);
  return ppPronunciations;
}

template <class T> HRESULT __fastcall
ISpeechLexiconDispT<T>::GetGenerationChange(long* GenerationId/*[in,out]*/, 
                                            Speechlib_tlb::ISpeechLexiconWords** ppWords/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetGenerationChange"), DISPID(8));
  TAutoArgs<1> _args;
  _args[1] = GenerationId /*[VT_I4:1]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechLexiconWords**)ppWords /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechLexiconWords* __fastcall
ISpeechLexiconDispT<T>::GetGenerationChange(long* GenerationId/*[in,out]*/)
{
  Speechlib_tlb::ISpeechLexiconWords* ppWords;
  this->GetGenerationChange(GenerationId, (Speechlib_tlb::ISpeechLexiconWords**)&ppWords);
  return ppWords;
}

// *********************************************************************//
// DispIntf:  ISpeechLexiconWords
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {8D199862-415E-47D5-AC4F-FAA608B424E6}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechLexiconWordsDispT<T>::get_Count(long* Count/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Count"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Count /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechLexiconWordsDispT<T>::get_Count(void)
{
  long Count;
  this->get_Count((long*)&Count);
  return Count;
}

template <class T> HRESULT __fastcall
ISpeechLexiconWordsDispT<T>::Item(long Index/*[in]*/, 
                                  Speechlib_tlb::ISpeechLexiconWord** Word/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Item"), DISPID(0));
  TAutoArgs<1> _args;
  _args[1] = Index /*[VT_I4:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechLexiconWord**)Word /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechLexiconWord* __fastcall
ISpeechLexiconWordsDispT<T>::Item(long Index/*[in]*/)
{
  Speechlib_tlb::ISpeechLexiconWord* Word;
  this->Item(Index, (Speechlib_tlb::ISpeechLexiconWord**)&Word);
  return Word;
}

template <class T> HRESULT __fastcall
ISpeechLexiconWordsDispT<T>::get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("_NewEnum"), DISPID(-4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(EnumVARIANT /*[VT_UNKNOWN:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> LPUNKNOWN __fastcall
ISpeechLexiconWordsDispT<T>::get__NewEnum(void)
{
  LPUNKNOWN EnumVARIANT;
  this->get__NewEnum((LPUNKNOWN*)&EnumVARIANT);
  return EnumVARIANT;
}

// *********************************************************************//
// DispIntf:  ISpeechLexiconWord
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {4E5B933C-C9BE-48ED-8842-1EE51BB1D4FF}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechLexiconWordDispT<T>::get_LangId(long* LangId/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("LangId"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(LangId /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechLexiconWordDispT<T>::get_LangId(void)
{
  long LangId;
  this->get_LangId((long*)&LangId);
  return LangId;
}

template <class T> HRESULT __fastcall
ISpeechLexiconWordDispT<T>::get_Type(Speechlib_tlb::SpeechWordType* WordType/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Type"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)WordType /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechWordType __fastcall
ISpeechLexiconWordDispT<T>::get_Type(void)
{
  Speechlib_tlb::SpeechWordType WordType;
  this->get_Type((Speechlib_tlb::SpeechWordType*)&WordType);
  return WordType;
}

template <class T> HRESULT __fastcall
ISpeechLexiconWordDispT<T>::get_Word(BSTR* Word/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Word"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Word /*[VT_BSTR:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechLexiconWordDispT<T>::get_Word(void)
{
  BSTR Word;
  this->get_Word((BSTR*)&Word);
  return Word;
}

template <class T> HRESULT __fastcall
ISpeechLexiconWordDispT<T>::get_Pronunciations(Speechlib_tlb::ISpeechLexiconPronunciations** Pronunciations/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Pronunciations"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechLexiconPronunciations**)Pronunciations /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechLexiconPronunciationsPtr __fastcall
ISpeechLexiconWordDispT<T>::get_Pronunciations(void)
{
  Speechlib_tlb::ISpeechLexiconPronunciationsPtr Pronunciations;
  this->get_Pronunciations(&Pronunciations);
  return Pronunciations;
}

// *********************************************************************//
// DispIntf:  ISpeechLexiconPronunciations
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {72829128-5682-4704-A0D4-3E2BB6F2EAD3}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechLexiconPronunciationsDispT<T>::get_Count(long* Count/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Count"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Count /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechLexiconPronunciationsDispT<T>::get_Count(void)
{
  long Count;
  this->get_Count((long*)&Count);
  return Count;
}

template <class T> HRESULT __fastcall
ISpeechLexiconPronunciationsDispT<T>::Item(long Index/*[in]*/, 
                                           Speechlib_tlb::ISpeechLexiconPronunciation** Pronunciation/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Item"), DISPID(0));
  TAutoArgs<1> _args;
  _args[1] = Index /*[VT_I4:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechLexiconPronunciation**)Pronunciation /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechLexiconPronunciation* __fastcall
ISpeechLexiconPronunciationsDispT<T>::Item(long Index/*[in]*/)
{
  Speechlib_tlb::ISpeechLexiconPronunciation* Pronunciation;
  this->Item(Index, (Speechlib_tlb::ISpeechLexiconPronunciation**)&Pronunciation);
  return Pronunciation;
}

template <class T> HRESULT __fastcall
ISpeechLexiconPronunciationsDispT<T>::get__NewEnum(LPUNKNOWN* EnumVARIANT/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("_NewEnum"), DISPID(-4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(EnumVARIANT /*[VT_UNKNOWN:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> LPUNKNOWN __fastcall
ISpeechLexiconPronunciationsDispT<T>::get__NewEnum(void)
{
  LPUNKNOWN EnumVARIANT;
  this->get__NewEnum((LPUNKNOWN*)&EnumVARIANT);
  return EnumVARIANT;
}

// *********************************************************************//
// DispIntf:  ISpeechLexiconPronunciation
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {95252C5D-9E43-4F4A-9899-48EE73352F9F}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechLexiconPronunciationDispT<T>::get_Type(Speechlib_tlb::SpeechLexiconType* LexiconType/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Type"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)LexiconType /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechLexiconType __fastcall
ISpeechLexiconPronunciationDispT<T>::get_Type(void)
{
  Speechlib_tlb::SpeechLexiconType LexiconType;
  this->get_Type((Speechlib_tlb::SpeechLexiconType*)&LexiconType);
  return LexiconType;
}

template <class T> HRESULT __fastcall
ISpeechLexiconPronunciationDispT<T>::get_LangId(long* LangId/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("LangId"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(LangId /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechLexiconPronunciationDispT<T>::get_LangId(void)
{
  long LangId;
  this->get_LangId((long*)&LangId);
  return LangId;
}

template <class T> HRESULT __fastcall
ISpeechLexiconPronunciationDispT<T>::get_PartOfSpeech(Speechlib_tlb::SpeechPartOfSpeech* PartOfSpeech/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("PartOfSpeech"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((int*)PartOfSpeech /*[VT_USERDEFINED:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::SpeechPartOfSpeech __fastcall
ISpeechLexiconPronunciationDispT<T>::get_PartOfSpeech(void)
{
  Speechlib_tlb::SpeechPartOfSpeech PartOfSpeech;
  this->get_PartOfSpeech((Speechlib_tlb::SpeechPartOfSpeech*)&PartOfSpeech);
  return PartOfSpeech;
}

template <class T> HRESULT __fastcall
ISpeechLexiconPronunciationDispT<T>::get_PhoneIds(VARIANT* PhoneIds/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("PhoneIds"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(PhoneIds /*[VT_VARIANT:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechLexiconPronunciationDispT<T>::get_PhoneIds(void)
{
  VARIANT PhoneIds;
  this->get_PhoneIds((VARIANT*)&PhoneIds);
  return PhoneIds;
}

template <class T> HRESULT __fastcall
ISpeechLexiconPronunciationDispT<T>::get_Symbolic(BSTR* Symbolic/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Symbolic"), DISPID(5));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(Symbolic /*[VT_BSTR:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechLexiconPronunciationDispT<T>::get_Symbolic(void)
{
  BSTR Symbolic;
  this->get_Symbolic((BSTR*)&Symbolic);
  return Symbolic;
}

// *********************************************************************//
// DispIntf:  ISpeechXMLRecoResult
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {AAEC54AF-8F85-4924-944D-B79D39D72E19}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechXMLRecoResultDispT<T>::GetXMLResult(Speechlib_tlb::SPXMLRESULTOPTIONS Options/*[in]*/, 
                                           BSTR* pResult/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetXMLResult"), DISPID(10));
  TAutoArgs<1> _args;
  _args[1] = (int)Options /*[VT_USERDEFINED:0]*/;
  return OutRetValSetterPtr(pResult /*[VT_BSTR:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechXMLRecoResultDispT<T>::GetXMLResult(Speechlib_tlb::SPXMLRESULTOPTIONS Options/*[in]*/)
{
  BSTR pResult;
  this->GetXMLResult(Options, (BSTR*)&pResult);
  return pResult;
}

template <class T> HRESULT __fastcall
ISpeechXMLRecoResultDispT<T>::GetXMLErrorInfo(long* LineNumber/*[out]*/, BSTR* ScriptLine/*[out]*/, 
                                              BSTR* Source/*[out]*/, BSTR* Description/*[out]*/, 
                                              long* ResultCode/*[out]*/, 
                                              VARIANT_BOOL* IsError/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetXMLErrorInfo"), DISPID(11));
  TAutoArgs<5> _args;
  _args[1] = LineNumber /*[VT_I4:1]*/;
  _args[2] = ScriptLine /*[VT_BSTR:1]*/;
  _args[3] = Source /*[VT_BSTR:1]*/;
  _args[4] = Description /*[VT_BSTR:1]*/;
  _args[5] = ResultCode /*[VT_I4:1]*/;
  return OutRetValSetterPtr(IsError /*[VT_BOOL:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
ISpeechXMLRecoResultDispT<T>::GetXMLErrorInfo(long* LineNumber/*[out]*/, BSTR* ScriptLine/*[out]*/, 
                                              BSTR* Source/*[out]*/, BSTR* Description/*[out]*/, 
                                              long* ResultCode/*[out]*/)
{
  VARIANT_BOOL IsError;
  this->GetXMLErrorInfo(LineNumber, ScriptLine, Source, Description, ResultCode, (VARIANT_BOOL*)&IsError);
  return IsError;
}

template <class T> HRESULT __fastcall
ISpeechXMLRecoResultDispT<T>::get_RecoContext(Speechlib_tlb::ISpeechRecoContext** RecoContext/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RecoContext"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechRecoContext**)RecoContext /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechRecoContextPtr __fastcall
ISpeechXMLRecoResultDispT<T>::get_RecoContext(void)
{
  Speechlib_tlb::ISpeechRecoContextPtr RecoContext;
  this->get_RecoContext(&RecoContext);
  return RecoContext;
}

template <class T> HRESULT __fastcall
ISpeechXMLRecoResultDispT<T>::get_Times(Speechlib_tlb::ISpeechRecoResultTimes** Times/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Times"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechRecoResultTimes**)Times /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechRecoResultTimesPtr __fastcall
ISpeechXMLRecoResultDispT<T>::get_Times(void)
{
  Speechlib_tlb::ISpeechRecoResultTimesPtr Times;
  this->get_Times(&Times);
  return Times;
}

template <class T> HRESULT __fastcall
ISpeechXMLRecoResultDispT<T>::_set_AudioFormat(Speechlib_tlb::ISpeechAudioFormat* Format/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioFormat"), DISPID(3));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechAudioFormat*)Format /*[VT_USERDEFINED:1]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechXMLRecoResultDispT<T>::get_AudioFormat(Speechlib_tlb::ISpeechAudioFormat** Format/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioFormat"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechAudioFormat**)Format /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechAudioFormatPtr __fastcall
ISpeechXMLRecoResultDispT<T>::get_AudioFormat(void)
{
  Speechlib_tlb::ISpeechAudioFormatPtr Format;
  this->get_AudioFormat(&Format);
  return Format;
}

template <class T> HRESULT __fastcall
ISpeechXMLRecoResultDispT<T>::get_PhraseInfo(Speechlib_tlb::ISpeechPhraseInfo** PhraseInfo/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("PhraseInfo"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechPhraseInfo**)PhraseInfo /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechPhraseInfoPtr __fastcall
ISpeechXMLRecoResultDispT<T>::get_PhraseInfo(void)
{
  Speechlib_tlb::ISpeechPhraseInfoPtr PhraseInfo;
  this->get_PhraseInfo(&PhraseInfo);
  return PhraseInfo;
}

template <class T> HRESULT __fastcall
ISpeechXMLRecoResultDispT<T>::Alternates(long RequestCount/*[in]*/, 
                                         long StartElement/*[in,def,opt]*/, 
                                         long Elements/*[in,def,opt]*/, 
                                         Speechlib_tlb::ISpeechPhraseAlternates** Alternates/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Alternates"), DISPID(5));
  TAutoArgs<3> _args;
  _args[1] = RequestCount /*[VT_I4:0]*/;
  _args[2] = StartElement /*[VT_I4:0]*/;
  _args[3] = Elements /*[VT_I4:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechPhraseAlternates**)Alternates /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechPhraseAlternates* __fastcall
ISpeechXMLRecoResultDispT<T>::Alternates(long RequestCount/*[in]*/, 
                                         long StartElement/*[in,def,opt]*/, 
                                         long Elements/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechPhraseAlternates* Alternates;
  this->Alternates(RequestCount, StartElement, Elements, (Speechlib_tlb::ISpeechPhraseAlternates**)&Alternates);
  return Alternates;
}

template <class T> HRESULT __fastcall
ISpeechXMLRecoResultDispT<T>::Audio(long StartElement/*[in,def,opt]*/, long Elements/*[in,def,opt]*/
                                    , Speechlib_tlb::ISpeechMemoryStream** Stream/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Audio"), DISPID(6));
  TAutoArgs<2> _args;
  _args[1] = StartElement /*[VT_I4:0]*/;
  _args[2] = Elements /*[VT_I4:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechMemoryStream**)Stream /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechMemoryStream* __fastcall
ISpeechXMLRecoResultDispT<T>::Audio(long StartElement/*[in,def,opt]*/, long Elements/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechMemoryStream* Stream;
  this->Audio(StartElement, Elements, (Speechlib_tlb::ISpeechMemoryStream**)&Stream);
  return Stream;
}

template <class T> HRESULT __fastcall
ISpeechXMLRecoResultDispT<T>::SpeakAudio(long StartElement/*[in,def,opt]*/, 
                                         long Elements/*[in,def,opt]*/, 
                                         Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/
                                         , long* StreamNumber/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("SpeakAudio"), DISPID(7));
  TAutoArgs<3> _args;
  _args[1] = StartElement /*[VT_I4:0]*/;
  _args[2] = Elements /*[VT_I4:0]*/;
  _args[3] = (int)Flags /*[VT_USERDEFINED:0]*/;
  return OutRetValSetterPtr(StreamNumber /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
ISpeechXMLRecoResultDispT<T>::SpeakAudio(long StartElement/*[in,def,opt]*/, 
                                         long Elements/*[in,def,opt]*/, 
                                         Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/)
{
  long StreamNumber;
  this->SpeakAudio(StartElement, Elements, Flags, (long*)&StreamNumber);
  return StreamNumber;
}

template <class T> HRESULT __fastcall
ISpeechXMLRecoResultDispT<T>::SaveToMemory(VARIANT* ResultBlock/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("SaveToMemory"), DISPID(8));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(ResultBlock /*[VT_VARIANT:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechXMLRecoResultDispT<T>::SaveToMemory(void)
{
  VARIANT ResultBlock;
  this->SaveToMemory((VARIANT*)&ResultBlock);
  return ResultBlock;
}

template <class T> HRESULT __fastcall
ISpeechXMLRecoResultDispT<T>::DiscardResultInfo(Speechlib_tlb::SpeechDiscardType ValueTypes/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("DiscardResultInfo"), DISPID(9));
  TAutoArgs<1> _args;
  _args[1] = (int)ValueTypes /*[VT_USERDEFINED:0]*/;
  return OleFunction(_dispid, _args);
}

// *********************************************************************//
// DispIntf:  ISpeechRecoResultDispatch
// Flags:     (4432) Hidden Dual OleAutomation Dispatchable
// GUID:      {6D60EB64-ACED-40A6-BBF3-4E557F71DEE2}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechRecoResultDispatchDispT<T>::get_RecoContext(Speechlib_tlb::ISpeechRecoContext** RecoContext/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RecoContext"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechRecoContext**)RecoContext /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechRecoContextPtr __fastcall
ISpeechRecoResultDispatchDispT<T>::get_RecoContext(void)
{
  Speechlib_tlb::ISpeechRecoContextPtr RecoContext;
  this->get_RecoContext(&RecoContext);
  return RecoContext;
}

template <class T> HRESULT __fastcall
ISpeechRecoResultDispatchDispT<T>::get_Times(Speechlib_tlb::ISpeechRecoResultTimes** Times/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Times"), DISPID(2));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechRecoResultTimes**)Times /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechRecoResultTimesPtr __fastcall
ISpeechRecoResultDispatchDispT<T>::get_Times(void)
{
  Speechlib_tlb::ISpeechRecoResultTimesPtr Times;
  this->get_Times(&Times);
  return Times;
}

template <class T> HRESULT __fastcall
ISpeechRecoResultDispatchDispT<T>::_set_AudioFormat(Speechlib_tlb::ISpeechAudioFormat* Format/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioFormat"), DISPID(3));
  TAutoArgs<1> _args;
  _args[1] = (LPDISPATCH)(Speechlib_tlb::ISpeechAudioFormat*)Format /*[VT_USERDEFINED:1]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoResultDispatchDispT<T>::get_AudioFormat(Speechlib_tlb::ISpeechAudioFormat** Format/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("AudioFormat"), DISPID(3));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechAudioFormat**)Format /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechAudioFormatPtr __fastcall
ISpeechRecoResultDispatchDispT<T>::get_AudioFormat(void)
{
  Speechlib_tlb::ISpeechAudioFormatPtr Format;
  this->get_AudioFormat(&Format);
  return Format;
}

template <class T> HRESULT __fastcall
ISpeechRecoResultDispatchDispT<T>::get_PhraseInfo(Speechlib_tlb::ISpeechPhraseInfo** PhraseInfo/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("PhraseInfo"), DISPID(4));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechPhraseInfo**)PhraseInfo /*[VT_USERDEFINED:2]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechPhraseInfoPtr __fastcall
ISpeechRecoResultDispatchDispT<T>::get_PhraseInfo(void)
{
  Speechlib_tlb::ISpeechPhraseInfoPtr PhraseInfo;
  this->get_PhraseInfo(&PhraseInfo);
  return PhraseInfo;
}

template <class T> HRESULT __fastcall
ISpeechRecoResultDispatchDispT<T>::Alternates(long RequestCount/*[in]*/, 
                                              long StartElement/*[in,def,opt]*/, 
                                              long Elements/*[in,def,opt]*/, 
                                              Speechlib_tlb::ISpeechPhraseAlternates** Alternates/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Alternates"), DISPID(5));
  TAutoArgs<3> _args;
  _args[1] = RequestCount /*[VT_I4:0]*/;
  _args[2] = StartElement /*[VT_I4:0]*/;
  _args[3] = Elements /*[VT_I4:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechPhraseAlternates**)Alternates /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechPhraseAlternates* __fastcall
ISpeechRecoResultDispatchDispT<T>::Alternates(long RequestCount/*[in]*/, 
                                              long StartElement/*[in,def,opt]*/, 
                                              long Elements/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechPhraseAlternates* Alternates;
  this->Alternates(RequestCount, StartElement, Elements, (Speechlib_tlb::ISpeechPhraseAlternates**)&Alternates);
  return Alternates;
}

template <class T> HRESULT __fastcall
ISpeechRecoResultDispatchDispT<T>::Audio(long StartElement/*[in,def,opt]*/, 
                                         long Elements/*[in,def,opt]*/, 
                                         Speechlib_tlb::ISpeechMemoryStream** Stream/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("Audio"), DISPID(6));
  TAutoArgs<2> _args;
  _args[1] = StartElement /*[VT_I4:0]*/;
  _args[2] = Elements /*[VT_I4:0]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechMemoryStream**)Stream /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechMemoryStream* __fastcall
ISpeechRecoResultDispatchDispT<T>::Audio(long StartElement/*[in,def,opt]*/, 
                                         long Elements/*[in,def,opt]*/)
{
  Speechlib_tlb::ISpeechMemoryStream* Stream;
  this->Audio(StartElement, Elements, (Speechlib_tlb::ISpeechMemoryStream**)&Stream);
  return Stream;
}

template <class T> HRESULT __fastcall
ISpeechRecoResultDispatchDispT<T>::SpeakAudio(long StartElement/*[in,def,opt]*/, 
                                              long Elements/*[in,def,opt]*/, 
                                              Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/
                                              , long* StreamNumber/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("SpeakAudio"), DISPID(7));
  TAutoArgs<3> _args;
  _args[1] = StartElement /*[VT_I4:0]*/;
  _args[2] = Elements /*[VT_I4:0]*/;
  _args[3] = (int)Flags /*[VT_USERDEFINED:0]*/;
  return OutRetValSetterPtr(StreamNumber /*[VT_I4:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> long __fastcall
ISpeechRecoResultDispatchDispT<T>::SpeakAudio(long StartElement/*[in,def,opt]*/, 
                                              long Elements/*[in,def,opt]*/, 
                                              Speechlib_tlb::SpeechVoiceSpeakFlags Flags/*[in,def,opt]*/)
{
  long StreamNumber;
  this->SpeakAudio(StartElement, Elements, Flags, (long*)&StreamNumber);
  return StreamNumber;
}

template <class T> HRESULT __fastcall
ISpeechRecoResultDispatchDispT<T>::SaveToMemory(VARIANT* ResultBlock/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("SaveToMemory"), DISPID(8));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(ResultBlock /*[VT_VARIANT:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechRecoResultDispatchDispT<T>::SaveToMemory(void)
{
  VARIANT ResultBlock;
  this->SaveToMemory((VARIANT*)&ResultBlock);
  return ResultBlock;
}

template <class T> HRESULT __fastcall
ISpeechRecoResultDispatchDispT<T>::DiscardResultInfo(Speechlib_tlb::SpeechDiscardType ValueTypes/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("DiscardResultInfo"), DISPID(9));
  TAutoArgs<1> _args;
  _args[1] = (int)ValueTypes /*[VT_USERDEFINED:0]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechRecoResultDispatchDispT<T>::GetXMLResult(Speechlib_tlb::SPXMLRESULTOPTIONS Options/*[in]*/, 
                                                BSTR* pResult/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetXMLResult"), DISPID(10));
  TAutoArgs<1> _args;
  _args[1] = (int)Options /*[VT_USERDEFINED:0]*/;
  return OutRetValSetterPtr(pResult /*[VT_BSTR:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechRecoResultDispatchDispT<T>::GetXMLResult(Speechlib_tlb::SPXMLRESULTOPTIONS Options/*[in]*/)
{
  BSTR pResult;
  this->GetXMLResult(Options, (BSTR*)&pResult);
  return pResult;
}

template <class T> HRESULT __fastcall
ISpeechRecoResultDispatchDispT<T>::GetXMLErrorInfo(long* LineNumber/*[out]*/, 
                                                   BSTR* ScriptLine/*[out]*/, BSTR* Source/*[out]*/
                                                   , BSTR* Description/*[out]*/, 
                                                   HRESULT* ResultCode/*[out]*/, 
                                                   VARIANT_BOOL* IsError/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetXMLErrorInfo"), DISPID(11));
  TAutoArgs<5> _args;
  _args[1] = LineNumber /*[VT_I4:1]*/;
  _args[2] = ScriptLine /*[VT_BSTR:1]*/;
  _args[3] = Source /*[VT_BSTR:1]*/;
  _args[4] = Description /*[VT_BSTR:1]*/;
  _args[5] = ResultCode /*[VT_HRESULT:1]*/;
  return OutRetValSetterPtr(IsError /*[VT_BOOL:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT_BOOL __fastcall
ISpeechRecoResultDispatchDispT<T>::GetXMLErrorInfo(long* LineNumber/*[out]*/, 
                                                   BSTR* ScriptLine/*[out]*/, BSTR* Source/*[out]*/, 
                                                   BSTR* Description/*[out]*/, 
                                                   HRESULT* ResultCode/*[out]*/)
{
  VARIANT_BOOL IsError;
  this->GetXMLErrorInfo(LineNumber, ScriptLine, Source, Description, ResultCode, (VARIANT_BOOL*)&IsError);
  return IsError;
}

template <class T> HRESULT __fastcall
ISpeechRecoResultDispatchDispT<T>::SetTextFeedback(BSTR Feedback/*[in]*/, 
                                                   VARIANT_BOOL WasSuccessful/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("SetTextFeedback"), DISPID(12));
  TAutoArgs<2> _args;
  _args[1] = Feedback /*[VT_BSTR:0]*/;
  _args[2] = WasSuccessful /*[VT_BOOL:0]*/;
  return OleFunction(_dispid, _args);
}

// *********************************************************************//
// SmartIntf: TCOMISpeechPhraseInfoBuilder
// Interface: ISpeechPhraseInfoBuilder
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMISpeechPhraseInfoBuilderT<T>::RestorePhraseFromMemory(VARIANT* PhraseInMemory/*[in]*/, 
                                                          Speechlib_tlb::ISpeechPhraseInfo** PhraseInfo/*[out,retval]*/)
{
  return (*this)->RestorePhraseFromMemory(PhraseInMemory, PhraseInfo);
}

template <class T> Speechlib_tlb::ISpeechPhraseInfo* __fastcall
TCOMISpeechPhraseInfoBuilderT<T>::RestorePhraseFromMemory(VARIANT* PhraseInMemory/*[in]*/)
{
  Speechlib_tlb::ISpeechPhraseInfo* PhraseInfo;
  OLECHECK(this->RestorePhraseFromMemory(PhraseInMemory/*[in]*/, (Speechlib_tlb::ISpeechPhraseInfo**)&PhraseInfo));
  return PhraseInfo;
}

// *********************************************************************//
// DispIntf:  ISpeechPhraseInfoBuilder
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {3B151836-DF3A-4E0A-846C-D2ADC9334333}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechPhraseInfoBuilderDispT<T>::RestorePhraseFromMemory(VARIANT* PhraseInMemory/*[in]*/, 
                                                          Speechlib_tlb::ISpeechPhraseInfo** PhraseInfo/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("RestorePhraseFromMemory"), DISPID(1));
  TAutoArgs<1> _args;
  _args[1] = PhraseInMemory /*[VT_VARIANT:1]*/;
  return OutRetValSetterPtr((LPDISPATCH*)(Speechlib_tlb::ISpeechPhraseInfo**)PhraseInfo /*[VT_USERDEFINED:2]*/, _args, OleFunction(_dispid, _args));
}

template <class T> Speechlib_tlb::ISpeechPhraseInfo* __fastcall
ISpeechPhraseInfoBuilderDispT<T>::RestorePhraseFromMemory(VARIANT* PhraseInMemory/*[in]*/)
{
  Speechlib_tlb::ISpeechPhraseInfo* PhraseInfo;
  this->RestorePhraseFromMemory(PhraseInMemory, (Speechlib_tlb::ISpeechPhraseInfo**)&PhraseInfo);
  return PhraseInfo;
}

// *********************************************************************//
// SmartIntf: TCOMISpeechPhoneConverter
// Interface: ISpeechPhoneConverter
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMISpeechPhoneConverterT<T>::get_LanguageId(long* LanguageId/*[out,retval]*/)
{
  return (*this)->get_LanguageId(LanguageId);
}

template <class T> long __fastcall
TCOMISpeechPhoneConverterT<T>::get_LanguageId(void)
{
  long LanguageId;
  OLECHECK(this->get_LanguageId((long*)&LanguageId));
  return LanguageId;
}

template <class T> HRESULT __fastcall
TCOMISpeechPhoneConverterT<T>::set_LanguageId(long LanguageId/*[in]*/)
{
  return (*this)->set_LanguageId(LanguageId);
}

template <class T> HRESULT __fastcall
TCOMISpeechPhoneConverterT<T>::PhoneToId(BSTR Phonemes/*[in]*/, VARIANT* IdArray/*[out,retval]*/)
{
  return (*this)->PhoneToId(Phonemes, IdArray);
}

template <class T> VARIANT __fastcall
TCOMISpeechPhoneConverterT<T>::PhoneToId(BSTR Phonemes/*[in]*/)
{
  VARIANT IdArray;
  OLECHECK(this->PhoneToId(Phonemes/*[in]*/, (VARIANT*)&IdArray));
  return IdArray;
}

template <class T> HRESULT __fastcall
TCOMISpeechPhoneConverterT<T>::IdToPhone(VARIANT IdArray/*[in]*/, BSTR* Phonemes/*[out,retval]*/)
{
  return (*this)->IdToPhone(IdArray, Phonemes);
}

template <class T> BSTR __fastcall
TCOMISpeechPhoneConverterT<T>::IdToPhone(VARIANT IdArray/*[in]*/)
{
  BSTR Phonemes = 0;
  OLECHECK(this->IdToPhone(IdArray/*[in]*/, (BSTR*)&Phonemes));
  return Phonemes;
}

// *********************************************************************//
// DispIntf:  ISpeechPhoneConverter
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {C3E4F353-433F-43D6-89A1-6A62A7054C3D}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechPhoneConverterDispT<T>::get_LanguageId(long* LanguageId/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("LanguageId"), DISPID(1));
  TAutoArgs<0> _args;
  return OutRetValSetterPtr(LanguageId /*[VT_I4:1]*/, _args, OlePropertyGet(_dispid, _args));
}

template <class T> long __fastcall
ISpeechPhoneConverterDispT<T>::get_LanguageId(void)
{
  long LanguageId;
  this->get_LanguageId((long*)&LanguageId);
  return LanguageId;
}

template <class T> HRESULT __fastcall
ISpeechPhoneConverterDispT<T>::set_LanguageId(long LanguageId/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("LanguageId"), DISPID(1));
  TAutoArgs<1> _args;
  _args[1] = LanguageId /*[VT_I4:0]*/;
  return OlePropertyPut(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechPhoneConverterDispT<T>::PhoneToId(BSTR Phonemes/*[in]*/, VARIANT* IdArray/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("PhoneToId"), DISPID(2));
  TAutoArgs<1> _args;
  _args[1] = Phonemes /*[VT_BSTR:0]*/;
  return OutRetValSetterPtr(IdArray /*[VT_VARIANT:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> VARIANT __fastcall
ISpeechPhoneConverterDispT<T>::PhoneToId(BSTR Phonemes/*[in]*/)
{
  VARIANT IdArray;
  this->PhoneToId(Phonemes, (VARIANT*)&IdArray);
  return IdArray;
}

template <class T> HRESULT __fastcall
ISpeechPhoneConverterDispT<T>::IdToPhone(VARIANT IdArray/*[in]*/, BSTR* Phonemes/*[out,retval]*/)
{
  _TDispID _dispid(*this, OLETEXT("IdToPhone"), DISPID(3));
  TAutoArgs<1> _args;
  _args[1] = IdArray /*[VT_VARIANT:0]*/;
  return OutRetValSetterPtr(Phonemes /*[VT_BSTR:1]*/, _args, OleFunction(_dispid, _args));
}

template <class T> BSTR __fastcall
ISpeechPhoneConverterDispT<T>::IdToPhone(VARIANT IdArray/*[in]*/)
{
  BSTR Phonemes;
  this->IdToPhone(IdArray, (BSTR*)&Phonemes);
  return Phonemes;
}

// *********************************************************************//
// SmartIntf: TCOMISpNotifyTranslator
// Interface: ISpNotifyTranslator
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMISpNotifyTranslatorT<T>::InitWindowMessage(Speechlib_tlb::wireHWND hWnd/*[in]*/, 
                                               unsigned Msg/*[in]*/, 
                                               Speechlib_tlb::UINT_PTR wParam/*[in]*/, 
                                               Speechlib_tlb::LONG_PTR lParam/*[in]*/)
{
  return (*this)->InitWindowMessage(hWnd, Msg, wParam, lParam);
}

template <class T> HRESULT __fastcall
TCOMISpNotifyTranslatorT<T>::InitCallback(void** pfnCallback/*[in]*/, 
                                          Speechlib_tlb::UINT_PTR wParam/*[in]*/, 
                                          Speechlib_tlb::LONG_PTR lParam/*[in]*/)
{
  return (*this)->InitCallback(pfnCallback, wParam, lParam);
}

template <class T> HRESULT __fastcall
TCOMISpNotifyTranslatorT<T>::InitSpNotifyCallback(void** pSpCallback/*[in]*/, 
                                                  Speechlib_tlb::UINT_PTR wParam/*[in]*/, 
                                                  Speechlib_tlb::LONG_PTR lParam/*[in]*/)
{
  return (*this)->InitSpNotifyCallback(pSpCallback, wParam, lParam);
}

template <class T> HRESULT __fastcall
TCOMISpNotifyTranslatorT<T>::InitWin32Event(void* hEvent/*[in]*/, long fCloseHandleOnRelease/*[in]*/)
{
  return (*this)->InitWin32Event(hEvent, fCloseHandleOnRelease);
}

template <class T> HRESULT __fastcall
TCOMISpNotifyTranslatorT<T>::Wait(unsigned_long dwMilliseconds/*[in]*/)
{
  return (*this)->Wait(dwMilliseconds);
}

template <class T> void* __fastcall
TCOMISpNotifyTranslatorT<T>::GetEventHandle(void)
{
  return (*this)->GetEventHandle();
}

// *********************************************************************//
// SmartIntf: TCOMIEnumSpObjectTokens
// Interface: IEnumSpObjectTokens
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMIEnumSpObjectTokensT<T>::Next(unsigned_long celt/*[in]*/, 
                                  Speechlib_tlb::ISpObjectToken** pelt/*[out]*/, 
                                  unsigned_long* pceltFetched/*[out]*/)
{
  return (*this)->Next(celt, pelt, pceltFetched);
}

template <class T> HRESULT __fastcall
TCOMIEnumSpObjectTokensT<T>::Skip(unsigned_long celt/*[in]*/)
{
  return (*this)->Skip(celt);
}

template <class T> HRESULT __fastcall
TCOMIEnumSpObjectTokensT<T>::Reset(void)
{
  return (*this)->Reset();
}

template <class T> HRESULT __fastcall
TCOMIEnumSpObjectTokensT<T>::Clone(Speechlib_tlb::IEnumSpObjectTokens** ppEnum/*[out]*/)
{
  return (*this)->Clone(ppEnum);
}

template <class T> HRESULT __fastcall
TCOMIEnumSpObjectTokensT<T>::Item(unsigned_long Index/*[in]*/, 
                                  Speechlib_tlb::ISpObjectToken** ppToken/*[out]*/)
{
  return (*this)->Item(Index, ppToken);
}

template <class T> HRESULT __fastcall
TCOMIEnumSpObjectTokensT<T>::GetCount(unsigned_long* pCount/*[out]*/)
{
  return (*this)->GetCount(pCount);
}

// *********************************************************************//
// SmartIntf: TCOMISpResourceManager
// Interface: ISpResourceManager
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMISpResourceManagerT<T>::SetObject(System::TGUID* guidServiceId/*[in]*/, 
                                      LPUNKNOWN punkObject/*[in]*/)
{
  return (*this)->SetObject(guidServiceId, punkObject);
}

template <class T> HRESULT __fastcall
TCOMISpResourceManagerT<T>::GetObject(System::TGUID* guidServiceId/*[in]*/, 
                                      System::TGUID* ObjectCLSID/*[in]*/, 
                                      System::TGUID* ObjectIID/*[in]*/, 
                                      long fReleaseWhenLastExternalRefReleased/*[in]*/, 
                                      void** ppObject/*[out]*/)
{
  return (*this)->GetObject(guidServiceId, ObjectCLSID, ObjectIID, 
                            fReleaseWhenLastExternalRefReleased, ppObject);
}

// *********************************************************************//
// SmartIntf: TCOMISpStreamFormatConverter
// Interface: ISpStreamFormatConverter
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMISpStreamFormatConverterT<T>::SetBaseStream(Speechlib_tlb::ISpStreamFormat* pStream/*[in]*/, 
                                                long fSetFormatToBaseStreamFormat/*[in]*/, 
                                                long fWriteToBaseStream/*[in]*/)
{
  return (*this)->SetBaseStream(pStream, fSetFormatToBaseStreamFormat, fWriteToBaseStream);
}

template <class T> HRESULT __fastcall
TCOMISpStreamFormatConverterT<T>::GetBaseStream(Speechlib_tlb::ISpStreamFormat** ppStream/*[out]*/)
{
  return (*this)->GetBaseStream(ppStream);
}

template <class T> HRESULT __fastcall
TCOMISpStreamFormatConverterT<T>::SetFormat(System::TGUID* rguidFormatIdOfConvertedStream/*[in]*/, 
                                            Speechlib_tlb::WAVEFORMATEX* pWaveFormatExOfConvertedStream/*[in]*/)
{
  return (*this)->SetFormat(rguidFormatIdOfConvertedStream, pWaveFormatExOfConvertedStream);
}

template <class T> HRESULT __fastcall
TCOMISpStreamFormatConverterT<T>::ResetSeekPosition(void)
{
  return (*this)->ResetSeekPosition();
}

template <class T> HRESULT __fastcall
TCOMISpStreamFormatConverterT<T>::ScaleConvertedToBaseOffset(unsigned_int64 ullOffsetConvertedStream/*[in]*/, 
                                                             unsigned_int64* pullOffsetBaseStream/*[out]*/)
{
  return (*this)->ScaleConvertedToBaseOffset(ullOffsetConvertedStream, pullOffsetBaseStream);
}

template <class T> HRESULT __fastcall
TCOMISpStreamFormatConverterT<T>::ScaleBaseToConvertedOffset(unsigned_int64 ullOffsetBaseStream/*[in]*/, 
                                                             unsigned_int64* pullOffsetConvertedStream/*[out]*/)
{
  return (*this)->ScaleBaseToConvertedOffset(ullOffsetBaseStream, pullOffsetConvertedStream);
}

// *********************************************************************//
// SmartIntf: TCOMISpStream
// Interface: ISpStream
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMISpStreamT<T>::SetBaseStream(Speechlib_tlb::IStream* pStream/*[in]*/, 
                                 System::TGUID* rguidFormat/*[in]*/, 
                                 Speechlib_tlb::WAVEFORMATEX* pWaveFormatEx/*[in]*/)
{
  return (*this)->SetBaseStream(pStream, rguidFormat, pWaveFormatEx);
}

template <class T> HRESULT __fastcall
TCOMISpStreamT<T>::GetBaseStream(Speechlib_tlb::IStream** ppStream/*[out]*/)
{
  return (*this)->GetBaseStream(ppStream);
}

template <class T> HRESULT __fastcall
TCOMISpStreamT<T>::BindToFile(LPWSTR pszFileName/*[in]*/, Speechlib_tlb::SPFILEMODE eMode/*[in]*/, 
                              System::TGUID* pFormatId/*[in]*/, 
                              Speechlib_tlb::WAVEFORMATEX* pWaveFormatEx, 
                              unsigned_int64 ullEventInterest/*[in]*/)
{
  return (*this)->BindToFile(pszFileName, eMode, pFormatId, pWaveFormatEx, ullEventInterest);
}

template <class T> HRESULT __fastcall
TCOMISpStreamT<T>::Close(void)
{
  return (*this)->Close();
}

// *********************************************************************//
// SmartIntf: TCOMISpLexicon
// Interface: ISpLexicon
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMISpLexiconT<T>::GetPronunciations(LPWSTR pszWord/*[in]*/, unsigned_short LangId/*[in]*/, 
                                      unsigned_long dwFlags/*[in]*/, 
                                      Speechlib_tlb::SPWORDPRONUNCIATIONLIST* pWordPronunciationList/*[in,out]*/)
{
  return (*this)->GetPronunciations(pszWord, LangId, dwFlags, pWordPronunciationList);
}

template <class T> HRESULT __fastcall
TCOMISpLexiconT<T>::AddPronunciation(LPWSTR pszWord/*[in]*/, unsigned_short LangId/*[in]*/, 
                                     Speechlib_tlb::SPPARTOFSPEECH ePartOfSpeech/*[in]*/, 
                                     LPWSTR pszPronunciation/*[in]*/)
{
  return (*this)->AddPronunciation(pszWord, LangId, ePartOfSpeech, pszPronunciation);
}

template <class T> HRESULT __fastcall
TCOMISpLexiconT<T>::RemovePronunciation(LPWSTR pszWord/*[in]*/, unsigned_short LangId/*[in]*/, 
                                        Speechlib_tlb::SPPARTOFSPEECH ePartOfSpeech/*[in]*/, 
                                        LPWSTR pszPronunciation/*[in]*/)
{
  return (*this)->RemovePronunciation(pszWord, LangId, ePartOfSpeech, pszPronunciation);
}

template <class T> HRESULT __fastcall
TCOMISpLexiconT<T>::GetGeneration(unsigned_long* pdwGeneration/*[out]*/)
{
  return (*this)->GetGeneration(pdwGeneration);
}

template <class T> HRESULT __fastcall
TCOMISpLexiconT<T>::GetGenerationChange(unsigned_long dwFlags/*[in]*/, 
                                        unsigned_long* pdwGeneration/*[in,out]*/, 
                                        Speechlib_tlb::SPWORDLIST* pWordList/*[in,out]*/)
{
  return (*this)->GetGenerationChange(dwFlags, pdwGeneration, pWordList);
}

template <class T> HRESULT __fastcall
TCOMISpLexiconT<T>::GetWords(unsigned_long dwFlags/*[in]*/, unsigned_long* pdwGeneration/*[in,out]*/, 
                             unsigned_long* pdwCookie/*[in,out]*/, 
                             Speechlib_tlb::SPWORDLIST* pWordList/*[in,out]*/)
{
  return (*this)->GetWords(dwFlags, pdwGeneration, pdwCookie, pWordList);
}

// *********************************************************************//
// SmartIntf: TCOMISpShortcut
// Interface: ISpShortcut
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMISpShortcutT<T>::AddShortcut(LPWSTR pszDisplay/*[in]*/, unsigned_short LangId/*[in]*/, 
                                 LPWSTR pszSpoken/*[in]*/, 
                                 Speechlib_tlb::SPSHORTCUTTYPE shType/*[in]*/)
{
  return (*this)->AddShortcut(pszDisplay, LangId, pszSpoken, shType);
}

template <class T> HRESULT __fastcall
TCOMISpShortcutT<T>::RemoveShortcut(LPWSTR pszDisplay/*[in]*/, unsigned_short LangId/*[in]*/, 
                                    LPWSTR pszSpoken/*[in]*/, 
                                    Speechlib_tlb::SPSHORTCUTTYPE shType/*[in]*/)
{
  return (*this)->RemoveShortcut(pszDisplay, LangId, pszSpoken, shType);
}

template <class T> HRESULT __fastcall
TCOMISpShortcutT<T>::GetShortcuts(unsigned_short LangId/*[in]*/, 
                                  Speechlib_tlb::SPSHORTCUTPAIRLIST* pShortcutpairList/*[in,out]*/)
{
  return (*this)->GetShortcuts(LangId, pShortcutpairList);
}

template <class T> HRESULT __fastcall
TCOMISpShortcutT<T>::GetGeneration(unsigned_long* pdwGeneration/*[out]*/)
{
  return (*this)->GetGeneration(pdwGeneration);
}

template <class T> HRESULT __fastcall
TCOMISpShortcutT<T>::GetWordsFromGenerationChange(unsigned_long* pdwGeneration/*[in,out]*/, 
                                                  Speechlib_tlb::SPWORDLIST* pWordList/*[in,out]*/)
{
  return (*this)->GetWordsFromGenerationChange(pdwGeneration, pWordList);
}

template <class T> HRESULT __fastcall
TCOMISpShortcutT<T>::GetWords(unsigned_long* pdwGeneration/*[in,out]*/, 
                              unsigned_long* pdwCookie/*[in,out]*/, 
                              Speechlib_tlb::SPWORDLIST* pWordList/*[in,out]*/)
{
  return (*this)->GetWords(pdwGeneration, pdwCookie, pWordList);
}

template <class T> HRESULT __fastcall
TCOMISpShortcutT<T>::GetShortcutsForGeneration(unsigned_long* pdwGeneration/*[in,out]*/, 
                                               unsigned_long* pdwCookie/*[in,out]*/, 
                                               Speechlib_tlb::SPSHORTCUTPAIRLIST* pShortcutpairList/*[in,out]*/)
{
  return (*this)->GetShortcutsForGeneration(pdwGeneration, pdwCookie, pShortcutpairList);
}

template <class T> HRESULT __fastcall
TCOMISpShortcutT<T>::GetGenerationChange(unsigned_long* pdwGeneration/*[in,out]*/, 
                                         Speechlib_tlb::SPSHORTCUTPAIRLIST* pShortcutpairList/*[in,out]*/)
{
  return (*this)->GetGenerationChange(pdwGeneration, pShortcutpairList);
}

// *********************************************************************//
// SmartIntf: TCOMISpPhoneConverter
// Interface: ISpPhoneConverter
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMISpPhoneConverterT<T>::PhoneToId(LPWSTR pszPhone/*[in]*/, unsigned_short* pId/*[out]*/)
{
  return (*this)->PhoneToId(pszPhone, pId);
}

template <class T> HRESULT __fastcall
TCOMISpPhoneConverterT<T>::IdToPhone(LPWSTR pId/*[in]*/, unsigned_short* pszPhone/*[out]*/)
{
  return (*this)->IdToPhone(pId, pszPhone);
}

// *********************************************************************//
// SmartIntf: TCOMISpPhoneticAlphabetConverter
// Interface: ISpPhoneticAlphabetConverter
// *********************************************************************//
template <class T> HRESULT __fastcall
TCOMISpPhoneticAlphabetConverterT<T>::GetLangId(unsigned_short* pLangID/*[out]*/)
{
  return (*this)->GetLangId(pLangID);
}

template <class T> HRESULT __fastcall
TCOMISpPhoneticAlphabetConverterT<T>::SetLangId(unsigned_short LangId/*[in]*/)
{
  return (*this)->SetLangId(LangId);
}

template <class T> HRESULT __fastcall
TCOMISpPhoneticAlphabetConverterT<T>::SAPI2UPS(unsigned_short* pszSAPIId/*[in]*/, 
                                               unsigned_short* pszUPSId/*[out]*/, 
                                               unsigned_long cMaxLength/*[in]*/)
{
  return (*this)->SAPI2UPS(pszSAPIId, pszUPSId, cMaxLength);
}

template <class T> HRESULT __fastcall
TCOMISpPhoneticAlphabetConverterT<T>::UPS2SAPI(unsigned_short* pszUPSId/*[in]*/, 
                                               unsigned_short* pszSAPIId/*[out]*/, 
                                               unsigned_long cMaxLength/*[in]*/)
{
  return (*this)->UPS2SAPI(pszUPSId, pszSAPIId, cMaxLength);
}

template <class T> HRESULT __fastcall
TCOMISpPhoneticAlphabetConverterT<T>::GetMaxConvertLength(unsigned_long cSrcLength/*[in]*/, 
                                                          long bSAPI2UPS/*[in]*/, 
                                                          unsigned_long* pcMaxDestLength/*[out]*/)
{
  return (*this)->GetMaxConvertLength(cSrcLength, bSAPI2UPS, pcMaxDestLength);
}

// *********************************************************************//
// DispIntf:  ISpeechResourceLoader
// Flags:     (4416) Dual OleAutomation Dispatchable
// GUID:      {B9AC5783-FCD0-4B21-B119-B4F8DA8FD2C3}
// *********************************************************************//
template <class T> HRESULT __fastcall
ISpeechResourceLoaderDispT<T>::LoadResource(BSTR bstrResourceUri/*[in]*/, 
                                            VARIANT_BOOL fAlwaysReload/*[in]*/, 
                                            LPUNKNOWN* pStream/*[out]*/, 
                                            BSTR* pbstrMIMEType/*[out]*/, 
                                            VARIANT_BOOL* pfModified/*[out]*/, 
                                            BSTR* pbstrRedirectUrl/*[out]*/)
{
  _TDispID _dispid(*this, OLETEXT("LoadResource"), DISPID(1));
  TAutoArgs<6> _args;
  _args[1] = bstrResourceUri /*[VT_BSTR:0]*/;
  _args[2] = fAlwaysReload /*[VT_BOOL:0]*/;
  _args[3] = pStream /*[VT_UNKNOWN:1]*/;
  _args[4] = pbstrMIMEType /*[VT_BSTR:1]*/;
  _args[5] = pfModified /*[VT_BOOL:1]*/;
  _args[6] = pbstrRedirectUrl /*[VT_BSTR:1]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechResourceLoaderDispT<T>::GetLocalCopy(BSTR bstrResourceUri/*[in]*/, 
                                            BSTR* pbstrLocalPath/*[out]*/, 
                                            BSTR* pbstrMIMEType/*[out]*/, 
                                            BSTR* pbstrRedirectUrl/*[out]*/)
{
  _TDispID _dispid(*this, OLETEXT("GetLocalCopy"), DISPID(2));
  TAutoArgs<4> _args;
  _args[1] = bstrResourceUri /*[VT_BSTR:0]*/;
  _args[2] = pbstrLocalPath /*[VT_BSTR:1]*/;
  _args[3] = pbstrMIMEType /*[VT_BSTR:1]*/;
  _args[4] = pbstrRedirectUrl /*[VT_BSTR:1]*/;
  return OleFunction(_dispid, _args);
}

template <class T> HRESULT __fastcall
ISpeechResourceLoaderDispT<T>::ReleaseLocalCopy(BSTR pbstrLocalPath/*[in]*/)
{
  _TDispID _dispid(*this, OLETEXT("ReleaseLocalCopy"), DISPID(3));
  TAutoArgs<1> _args;
  _args[1] = pbstrLocalPath /*[VT_BSTR:0]*/;
  return OleFunction(_dispid, _args);
}

// *********************************************************************//
// The following typedefs expose classes (named CoCoClassName) that       
// provide static Create() and CreateRemote(LPWSTR machineName) methods   
// for creating an instance of an exposed object. These functions can     
// be used by client wishing to automate CoClasses exposed by this        
// typelibrary.                                                           
// *********************************************************************//

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpNotifyTranslator
// Interface: TCOMISpNotifyTranslator
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpNotifyTranslator, ISpNotifyTranslator, &CLSID_SpNotifyTranslator, &IID_ISpNotifyTranslator> CoSpNotifyTranslator;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpObjectTokenCategory
// Interface: TCOMISpeechObjectTokenCategory
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpeechObjectTokenCategory, ISpeechObjectTokenCategory, &CLSID_SpObjectTokenCategory, &IID_ISpeechObjectTokenCategory> CoSpObjectTokenCategory;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpObjectToken
// Interface: TCOMISpeechObjectToken
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpeechObjectToken, ISpeechObjectToken, &CLSID_SpObjectToken, &IID_ISpeechObjectToken> CoSpObjectToken;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpResourceManager
// Interface: TCOMISpResourceManager
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpResourceManager, ISpResourceManager, &CLSID_SpResourceManager, &IID_ISpResourceManager> CoSpResourceManager;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpStreamFormatConverter
// Interface: TCOMISpStreamFormatConverter
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpStreamFormatConverter, ISpStreamFormatConverter, &CLSID_SpStreamFormatConverter, &IID_ISpStreamFormatConverter> CoSpStreamFormatConverter;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpMMAudioEnum
// Interface: TCOMIEnumSpObjectTokens
// *********************************************************************//
typedef TCoClassCreatorT<TCOMIEnumSpObjectTokens, IEnumSpObjectTokens, &CLSID_SpMMAudioEnum, &IID_IEnumSpObjectTokens> CoSpMMAudioEnum;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpMMAudioIn
// Interface: TCOMISpeechMMSysAudio
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpeechMMSysAudio, ISpeechMMSysAudio, &CLSID_SpMMAudioIn, &IID_ISpeechMMSysAudio> CoSpMMAudioIn;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpMMAudioOut
// Interface: TCOMISpeechMMSysAudio
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpeechMMSysAudio, ISpeechMMSysAudio, &CLSID_SpMMAudioOut, &IID_ISpeechMMSysAudio> CoSpMMAudioOut;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpStream
// Interface: TCOMISpStream
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpStream, ISpStream, &CLSID_SpStream, &IID_ISpStream> CoSpStream;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpVoice
// Interface: TCOMISpeechVoice
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpeechVoice, ISpeechVoice, &CLSID_SpVoice, &IID_ISpeechVoice> CoSpVoice;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpSharedRecoContext
// Interface: TCOMISpeechRecoContext
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpeechRecoContext, ISpeechRecoContext, &CLSID_SpSharedRecoContext, &IID_ISpeechRecoContext> CoSpSharedRecoContext;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpInprocRecognizer
// Interface: TCOMISpeechRecognizer
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpeechRecognizer, ISpeechRecognizer, &CLSID_SpInprocRecognizer, &IID_ISpeechRecognizer> CoSpInprocRecognizer;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpSharedRecognizer
// Interface: TCOMISpeechRecognizer
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpeechRecognizer, ISpeechRecognizer, &CLSID_SpSharedRecognizer, &IID_ISpeechRecognizer> CoSpSharedRecognizer;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpLexicon
// Interface: TCOMISpeechLexicon
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpeechLexicon, ISpeechLexicon, &CLSID_SpLexicon, &IID_ISpeechLexicon> CoSpLexicon;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpUnCompressedLexicon
// Interface: TCOMISpeechLexicon
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpeechLexicon, ISpeechLexicon, &CLSID_SpUnCompressedLexicon, &IID_ISpeechLexicon> CoSpUnCompressedLexicon;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpCompressedLexicon
// Interface: TCOMISpLexicon
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpLexicon, ISpLexicon, &CLSID_SpCompressedLexicon, &IID_ISpLexicon> CoSpCompressedLexicon;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpShortcut
// Interface: TCOMISpShortcut
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpShortcut, ISpShortcut, &CLSID_SpShortcut, &IID_ISpShortcut> CoSpShortcut;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpPhoneConverter
// Interface: TCOMISpeechPhoneConverter
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpeechPhoneConverter, ISpeechPhoneConverter, &CLSID_SpPhoneConverter, &IID_ISpeechPhoneConverter> CoSpPhoneConverter;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpPhoneticAlphabetConverter
// Interface: TCOMISpPhoneticAlphabetConverter
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpPhoneticAlphabetConverter, ISpPhoneticAlphabetConverter, &CLSID_SpPhoneticAlphabetConverter, &IID_ISpPhoneticAlphabetConverter> CoSpPhoneticAlphabetConverter;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpNullPhoneConverter
// Interface: TCOMISpPhoneConverter
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpPhoneConverter, ISpPhoneConverter, &CLSID_SpNullPhoneConverter, &IID_ISpPhoneConverter> CoSpNullPhoneConverter;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpTextSelectionInformation
// Interface: TCOMISpeechTextSelectionInformation
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpeechTextSelectionInformation, ISpeechTextSelectionInformation, &CLSID_SpTextSelectionInformation, &IID_ISpeechTextSelectionInformation> CoSpTextSelectionInformation;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpPhraseInfoBuilder
// Interface: TCOMISpeechPhraseInfoBuilder
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpeechPhraseInfoBuilder, ISpeechPhraseInfoBuilder, &CLSID_SpPhraseInfoBuilder, &IID_ISpeechPhraseInfoBuilder> CoSpPhraseInfoBuilder;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpAudioFormat
// Interface: TCOMISpeechAudioFormat
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpeechAudioFormat, ISpeechAudioFormat, &CLSID_SpAudioFormat, &IID_ISpeechAudioFormat> CoSpAudioFormat;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpWaveFormatEx
// Interface: TCOMISpeechWaveFormatEx
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpeechWaveFormatEx, ISpeechWaveFormatEx, &CLSID_SpWaveFormatEx, &IID_ISpeechWaveFormatEx> CoSpWaveFormatEx;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpInProcRecoContext
// Interface: TCOMISpeechRecoContext
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpeechRecoContext, ISpeechRecoContext, &CLSID_SpInProcRecoContext, &IID_ISpeechRecoContext> CoSpInProcRecoContext;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpCustomStream
// Interface: TCOMISpeechCustomStream
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpeechCustomStream, ISpeechCustomStream, &CLSID_SpCustomStream, &IID_ISpeechCustomStream> CoSpCustomStream;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpFileStream
// Interface: TCOMISpeechFileStream
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpeechFileStream, ISpeechFileStream, &CLSID_SpFileStream, &IID_ISpeechFileStream> CoSpFileStream;

// *********************************************************************//
// COCLASS DEFAULT INTERFACE CREATOR
// CoClass  : SpMemoryStream
// Interface: TCOMISpeechMemoryStream
// *********************************************************************//
typedef TCoClassCreatorT<TCOMISpeechMemoryStream, ISpeechMemoryStream, &CLSID_SpMemoryStream, &IID_ISpeechMemoryStream> CoSpMemoryStream;
#endif  //   __TLB_NO_INTERFACE_WRAPPERS


#if !defined(__TLB_NO_EVENT_WRAPPERS) && defined(USING_ATLVCL)
// *********************************************************************//
// CONNECTIONPOINT/EVENT PROXY
// CoClass         : SpVoice
// Event Interface : _ISpeechVoiceEvents
// *********************************************************************//
template <class T>
class TEvents_SpVoice : public IConnectionPointImpl<T,
                                                 &DIID__ISpeechVoiceEvents,
#if !defined(_TLB_DYNAMIC_CONNECTIONPOINT_ARRAY)
                                                 CComUnkArray<CONNECTIONPOINT_ARRAY_SIZE> >
#else
                                                 CComDynamicArray>
#endif
{
public:
  void            Fire_StartStream(long StreamNumber, VARIANT StreamPosition);
  void            Fire_EndStream(long StreamNumber, VARIANT StreamPosition);
  void            Fire_VoiceChange(long StreamNumber, VARIANT StreamPosition, 
                                   Speechlib_tlb::ISpeechObjectToken* VoiceObjectToken);
  void            Fire_Bookmark(long StreamNumber, VARIANT StreamPosition, BSTR Bookmark, 
                                long BookmarkId);
  void            Fire_Word(long StreamNumber, VARIANT StreamPosition, long CharacterPosition, 
                            long Length);
  void            Fire_Sentence(long StreamNumber, VARIANT StreamPosition, long CharacterPosition, 
                                long Length);
  void            Fire_Phoneme(long StreamNumber, VARIANT StreamPosition, long Duration, 
                               short NextPhoneId, Speechlib_tlb::SpeechVisemeFeature Feature, 
                               short CurrentPhoneId);
  void            Fire_Viseme(long StreamNumber, VARIANT StreamPosition, long Duration, 
                              Speechlib_tlb::SpeechVisemeType NextVisemeId, 
                              Speechlib_tlb::SpeechVisemeFeature Feature, 
                              Speechlib_tlb::SpeechVisemeType CurrentVisemeId);
  void            Fire_AudioLevel(long StreamNumber, VARIANT StreamPosition, long AudioLevel);
  void            Fire_EnginePrivate(long StreamNumber, long StreamPosition, VARIANT EngineData);
protected:
  _ISpeechVoiceEventsDisp m_EventIntfObj;
};

template <class T> void
TEvents_SpVoice<T>::Fire_StartStream(long StreamNumber, VARIANT StreamPosition)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.StartStream(StreamNumber, StreamPosition);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpVoice<T>::Fire_EndStream(long StreamNumber, VARIANT StreamPosition)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.EndStream(StreamNumber, StreamPosition);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpVoice<T>::Fire_VoiceChange(long StreamNumber, VARIANT StreamPosition, 
                                     Speechlib_tlb::ISpeechObjectToken* VoiceObjectToken)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.VoiceChange(StreamNumber, StreamPosition, VoiceObjectToken);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpVoice<T>::Fire_Bookmark(long StreamNumber, VARIANT StreamPosition, BSTR Bookmark, 
                                  long BookmarkId)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.Bookmark(StreamNumber, StreamPosition, Bookmark, BookmarkId);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpVoice<T>::Fire_Word(long StreamNumber, VARIANT StreamPosition, long CharacterPosition, 
                              long Length)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.Word(StreamNumber, StreamPosition, CharacterPosition, Length);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpVoice<T>::Fire_Sentence(long StreamNumber, VARIANT StreamPosition, long CharacterPosition, 
                                  long Length)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.Sentence(StreamNumber, StreamPosition, CharacterPosition, Length);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpVoice<T>::Fire_Phoneme(long StreamNumber, VARIANT StreamPosition, long Duration, 
                                 short NextPhoneId, Speechlib_tlb::SpeechVisemeFeature Feature, 
                                 short CurrentPhoneId)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.Phoneme(StreamNumber, StreamPosition, Duration, NextPhoneId, Feature, 
                             CurrentPhoneId);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpVoice<T>::Fire_Viseme(long StreamNumber, VARIANT StreamPosition, long Duration, 
                                Speechlib_tlb::SpeechVisemeType NextVisemeId, 
                                Speechlib_tlb::SpeechVisemeFeature Feature, 
                                Speechlib_tlb::SpeechVisemeType CurrentVisemeId)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.Viseme(StreamNumber, StreamPosition, Duration, NextVisemeId, Feature, 
                            CurrentVisemeId);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpVoice<T>::Fire_AudioLevel(long StreamNumber, VARIANT StreamPosition, long AudioLevel)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.AudioLevel(StreamNumber, StreamPosition, AudioLevel);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpVoice<T>::Fire_EnginePrivate(long StreamNumber, long StreamPosition, VARIANT EngineData)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.EnginePrivate(StreamNumber, StreamPosition, EngineData);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

// *********************************************************************//
// CONNECTIONPOINT/EVENT PROXY
// CoClass         : SpSharedRecoContext
// Event Interface : _ISpeechRecoContextEvents
// *********************************************************************//
template <class T>
class TEvents_SpSharedRecoContext : public IConnectionPointImpl<T,
                                                 &DIID__ISpeechRecoContextEvents,
#if !defined(_TLB_DYNAMIC_CONNECTIONPOINT_ARRAY)
                                                 CComUnkArray<CONNECTIONPOINT_ARRAY_SIZE> >
#else
                                                 CComDynamicArray>
#endif
{
public:
  void            Fire_StartStream(long StreamNumber, VARIANT StreamPosition);
  void            Fire_EndStream(long StreamNumber, VARIANT StreamPosition, 
                                 VARIANT_BOOL StreamReleased);
  void            Fire_Bookmark(long StreamNumber, VARIANT StreamPosition, VARIANT BookmarkId, 
                                Speechlib_tlb::SpeechBookmarkOptions Options);
  void            Fire_SoundStart(long StreamNumber, VARIANT StreamPosition);
  void            Fire_SoundEnd(long StreamNumber, VARIANT StreamPosition);
  void            Fire_PhraseStart(long StreamNumber, VARIANT StreamPosition);
  void            Fire_Recognition(long StreamNumber, VARIANT StreamPosition, 
                                   Speechlib_tlb::SpeechRecognitionType RecognitionType, 
                                   Speechlib_tlb::ISpeechRecoResult* Result);
  void            Fire_Hypothesis(long StreamNumber, VARIANT StreamPosition, 
                                  Speechlib_tlb::ISpeechRecoResult* Result);
  void            Fire_PropertyNumberChange(long StreamNumber, VARIANT StreamPosition, 
                                            BSTR PropertyName, long NewNumberValue);
  void            Fire_PropertyStringChange(long StreamNumber, VARIANT StreamPosition, 
                                            BSTR PropertyName, BSTR NewStringValue);
  void            Fire_FalseRecognition(long StreamNumber, VARIANT StreamPosition, 
                                        Speechlib_tlb::ISpeechRecoResult* Result);
  void            Fire_Interference(long StreamNumber, VARIANT StreamPosition, 
                                    Speechlib_tlb::SpeechInterference Interference);
  void            Fire_RequestUI(long StreamNumber, VARIANT StreamPosition, BSTR UIType);
  void            Fire_RecognizerStateChange(long StreamNumber, VARIANT StreamPosition, 
                                             Speechlib_tlb::SpeechRecognizerState NewState);
  void            Fire_Adaptation(long StreamNumber, VARIANT StreamPosition);
  void            Fire_RecognitionForOtherContext(long StreamNumber, VARIANT StreamPosition);
  void            Fire_AudioLevel(long StreamNumber, VARIANT StreamPosition, long AudioLevel);
  void            Fire_EnginePrivate(long StreamNumber, VARIANT StreamPosition, VARIANT EngineData);
protected:
  _ISpeechRecoContextEventsDisp m_EventIntfObj;
};

template <class T> void
TEvents_SpSharedRecoContext<T>::Fire_StartStream(long StreamNumber, VARIANT StreamPosition)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.StartStream(StreamNumber, StreamPosition);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpSharedRecoContext<T>::Fire_EndStream(long StreamNumber, VARIANT StreamPosition, 
                                               VARIANT_BOOL StreamReleased)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.EndStream(StreamNumber, StreamPosition, StreamReleased);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpSharedRecoContext<T>::Fire_Bookmark(long StreamNumber, VARIANT StreamPosition, 
                                              VARIANT BookmarkId, 
                                              Speechlib_tlb::SpeechBookmarkOptions Options)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.Bookmark(StreamNumber, StreamPosition, BookmarkId, Options);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpSharedRecoContext<T>::Fire_SoundStart(long StreamNumber, VARIANT StreamPosition)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.SoundStart(StreamNumber, StreamPosition);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpSharedRecoContext<T>::Fire_SoundEnd(long StreamNumber, VARIANT StreamPosition)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.SoundEnd(StreamNumber, StreamPosition);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpSharedRecoContext<T>::Fire_PhraseStart(long StreamNumber, VARIANT StreamPosition)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.PhraseStart(StreamNumber, StreamPosition);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpSharedRecoContext<T>::Fire_Recognition(long StreamNumber, VARIANT StreamPosition, 
                                                 Speechlib_tlb::SpeechRecognitionType RecognitionType, 
                                                 Speechlib_tlb::ISpeechRecoResult* Result)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.Recognition(StreamNumber, StreamPosition, RecognitionType, Result);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpSharedRecoContext<T>::Fire_Hypothesis(long StreamNumber, VARIANT StreamPosition, 
                                                Speechlib_tlb::ISpeechRecoResult* Result)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.Hypothesis(StreamNumber, StreamPosition, Result);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpSharedRecoContext<T>::Fire_PropertyNumberChange(long StreamNumber, VARIANT StreamPosition, 
                                                          BSTR PropertyName, long NewNumberValue)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.PropertyNumberChange(StreamNumber, StreamPosition, PropertyName, NewNumberValue);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpSharedRecoContext<T>::Fire_PropertyStringChange(long StreamNumber, VARIANT StreamPosition, 
                                                          BSTR PropertyName, BSTR NewStringValue)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.PropertyStringChange(StreamNumber, StreamPosition, PropertyName, NewStringValue);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpSharedRecoContext<T>::Fire_FalseRecognition(long StreamNumber, VARIANT StreamPosition, 
                                                      Speechlib_tlb::ISpeechRecoResult* Result)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.FalseRecognition(StreamNumber, StreamPosition, Result);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpSharedRecoContext<T>::Fire_Interference(long StreamNumber, VARIANT StreamPosition, 
                                                  Speechlib_tlb::SpeechInterference Interference)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.Interference(StreamNumber, StreamPosition, Interference);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpSharedRecoContext<T>::Fire_RequestUI(long StreamNumber, VARIANT StreamPosition, 
                                               BSTR UIType)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.RequestUI(StreamNumber, StreamPosition, UIType);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpSharedRecoContext<T>::Fire_RecognizerStateChange(long StreamNumber, VARIANT StreamPosition, 
                                                           Speechlib_tlb::SpeechRecognizerState NewState)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.RecognizerStateChange(StreamNumber, StreamPosition, NewState);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpSharedRecoContext<T>::Fire_Adaptation(long StreamNumber, VARIANT StreamPosition)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.Adaptation(StreamNumber, StreamPosition);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpSharedRecoContext<T>::Fire_RecognitionForOtherContext(long StreamNumber, 
                                                                VARIANT StreamPosition)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.RecognitionForOtherContext(StreamNumber, StreamPosition);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpSharedRecoContext<T>::Fire_AudioLevel(long StreamNumber, VARIANT StreamPosition, 
                                                long AudioLevel)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.AudioLevel(StreamNumber, StreamPosition, AudioLevel);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpSharedRecoContext<T>::Fire_EnginePrivate(long StreamNumber, VARIANT StreamPosition, 
                                                   VARIANT EngineData)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.EnginePrivate(StreamNumber, StreamPosition, EngineData);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

// *********************************************************************//
// CONNECTIONPOINT/EVENT PROXY
// CoClass         : SpInProcRecoContext
// Event Interface : _ISpeechRecoContextEvents
// *********************************************************************//
template <class T>
class TEvents_SpInProcRecoContext : public IConnectionPointImpl<T,
                                                 &DIID__ISpeechRecoContextEvents,
#if !defined(_TLB_DYNAMIC_CONNECTIONPOINT_ARRAY)
                                                 CComUnkArray<CONNECTIONPOINT_ARRAY_SIZE> >
#else
                                                 CComDynamicArray>
#endif
{
public:
  void            Fire_StartStream(long StreamNumber, VARIANT StreamPosition);
  void            Fire_EndStream(long StreamNumber, VARIANT StreamPosition, 
                                 VARIANT_BOOL StreamReleased);
  void            Fire_Bookmark(long StreamNumber, VARIANT StreamPosition, VARIANT BookmarkId, 
                                Speechlib_tlb::SpeechBookmarkOptions Options);
  void            Fire_SoundStart(long StreamNumber, VARIANT StreamPosition);
  void            Fire_SoundEnd(long StreamNumber, VARIANT StreamPosition);
  void            Fire_PhraseStart(long StreamNumber, VARIANT StreamPosition);
  void            Fire_Recognition(long StreamNumber, VARIANT StreamPosition, 
                                   Speechlib_tlb::SpeechRecognitionType RecognitionType, 
                                   Speechlib_tlb::ISpeechRecoResult* Result);
  void            Fire_Hypothesis(long StreamNumber, VARIANT StreamPosition, 
                                  Speechlib_tlb::ISpeechRecoResult* Result);
  void            Fire_PropertyNumberChange(long StreamNumber, VARIANT StreamPosition, 
                                            BSTR PropertyName, long NewNumberValue);
  void            Fire_PropertyStringChange(long StreamNumber, VARIANT StreamPosition, 
                                            BSTR PropertyName, BSTR NewStringValue);
  void            Fire_FalseRecognition(long StreamNumber, VARIANT StreamPosition, 
                                        Speechlib_tlb::ISpeechRecoResult* Result);
  void            Fire_Interference(long StreamNumber, VARIANT StreamPosition, 
                                    Speechlib_tlb::SpeechInterference Interference);
  void            Fire_RequestUI(long StreamNumber, VARIANT StreamPosition, BSTR UIType);
  void            Fire_RecognizerStateChange(long StreamNumber, VARIANT StreamPosition, 
                                             Speechlib_tlb::SpeechRecognizerState NewState);
  void            Fire_Adaptation(long StreamNumber, VARIANT StreamPosition);
  void            Fire_RecognitionForOtherContext(long StreamNumber, VARIANT StreamPosition);
  void            Fire_AudioLevel(long StreamNumber, VARIANT StreamPosition, long AudioLevel);
  void            Fire_EnginePrivate(long StreamNumber, VARIANT StreamPosition, VARIANT EngineData);
protected:
  _ISpeechRecoContextEventsDisp m_EventIntfObj;
};

template <class T> void
TEvents_SpInProcRecoContext<T>::Fire_StartStream(long StreamNumber, VARIANT StreamPosition)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.StartStream(StreamNumber, StreamPosition);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpInProcRecoContext<T>::Fire_EndStream(long StreamNumber, VARIANT StreamPosition, 
                                               VARIANT_BOOL StreamReleased)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.EndStream(StreamNumber, StreamPosition, StreamReleased);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpInProcRecoContext<T>::Fire_Bookmark(long StreamNumber, VARIANT StreamPosition, 
                                              VARIANT BookmarkId, 
                                              Speechlib_tlb::SpeechBookmarkOptions Options)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.Bookmark(StreamNumber, StreamPosition, BookmarkId, Options);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpInProcRecoContext<T>::Fire_SoundStart(long StreamNumber, VARIANT StreamPosition)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.SoundStart(StreamNumber, StreamPosition);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpInProcRecoContext<T>::Fire_SoundEnd(long StreamNumber, VARIANT StreamPosition)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.SoundEnd(StreamNumber, StreamPosition);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpInProcRecoContext<T>::Fire_PhraseStart(long StreamNumber, VARIANT StreamPosition)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.PhraseStart(StreamNumber, StreamPosition);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpInProcRecoContext<T>::Fire_Recognition(long StreamNumber, VARIANT StreamPosition, 
                                                 Speechlib_tlb::SpeechRecognitionType RecognitionType, 
                                                 Speechlib_tlb::ISpeechRecoResult* Result)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.Recognition(StreamNumber, StreamPosition, RecognitionType, Result);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpInProcRecoContext<T>::Fire_Hypothesis(long StreamNumber, VARIANT StreamPosition, 
                                                Speechlib_tlb::ISpeechRecoResult* Result)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.Hypothesis(StreamNumber, StreamPosition, Result);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpInProcRecoContext<T>::Fire_PropertyNumberChange(long StreamNumber, VARIANT StreamPosition, 
                                                          BSTR PropertyName, long NewNumberValue)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.PropertyNumberChange(StreamNumber, StreamPosition, PropertyName, NewNumberValue);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpInProcRecoContext<T>::Fire_PropertyStringChange(long StreamNumber, VARIANT StreamPosition, 
                                                          BSTR PropertyName, BSTR NewStringValue)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.PropertyStringChange(StreamNumber, StreamPosition, PropertyName, NewStringValue);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpInProcRecoContext<T>::Fire_FalseRecognition(long StreamNumber, VARIANT StreamPosition, 
                                                      Speechlib_tlb::ISpeechRecoResult* Result)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.FalseRecognition(StreamNumber, StreamPosition, Result);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpInProcRecoContext<T>::Fire_Interference(long StreamNumber, VARIANT StreamPosition, 
                                                  Speechlib_tlb::SpeechInterference Interference)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.Interference(StreamNumber, StreamPosition, Interference);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpInProcRecoContext<T>::Fire_RequestUI(long StreamNumber, VARIANT StreamPosition, 
                                               BSTR UIType)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.RequestUI(StreamNumber, StreamPosition, UIType);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpInProcRecoContext<T>::Fire_RecognizerStateChange(long StreamNumber, VARIANT StreamPosition, 
                                                           Speechlib_tlb::SpeechRecognizerState NewState)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.RecognizerStateChange(StreamNumber, StreamPosition, NewState);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpInProcRecoContext<T>::Fire_Adaptation(long StreamNumber, VARIANT StreamPosition)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.Adaptation(StreamNumber, StreamPosition);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpInProcRecoContext<T>::Fire_RecognitionForOtherContext(long StreamNumber, 
                                                                VARIANT StreamPosition)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.RecognitionForOtherContext(StreamNumber, StreamPosition);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpInProcRecoContext<T>::Fire_AudioLevel(long StreamNumber, VARIANT StreamPosition, 
                                                long AudioLevel)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.AudioLevel(StreamNumber, StreamPosition, AudioLevel);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

template <class T> void
TEvents_SpInProcRecoContext<T>::Fire_EnginePrivate(long StreamNumber, VARIANT StreamPosition, 
                                                   VARIANT EngineData)
{
  T * pT = (T*)this;
  pT->Lock();
  IUnknown ** pp = m_vec.begin();
  while (pp < m_vec.end())
  {
    if (*pp != NULL)
    {
      m_EventIntfObj.Attach(*pp);
      m_EventIntfObj.EnginePrivate(StreamNumber, StreamPosition, EngineData);
      m_EventIntfObj.Attach(0);
    }
    pp++;
  }
  pT->Unlock();
}

#endif    //   __TLB_NO_EVENT_WRAPPERS

#if !defined(__TLB_NO_EVENT_WRAPPERS) && defined(USING_DAX)
// *********************************************************************//
// CONNECTIONPOINT/EVENT PROXY
// CoClass         : SpVoice
// Event Interface : _ISpeechVoiceEvents
// *********************************************************************//
template <typename T>
class ISpVoice_EventsDispatcher : public IUnknown
{
public:
  void Fire_StartStream(long StreamNumber, VARIANT StreamPosition)
  {
    _ISpeechVoiceEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.StartStream(StreamNumber, StreamPosition);
      }
    }
  }

  void Fire_EndStream(long StreamNumber, VARIANT StreamPosition)
  {
    _ISpeechVoiceEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.EndStream(StreamNumber, StreamPosition);
      }
    }
  }

  void Fire_VoiceChange(long StreamNumber, VARIANT StreamPosition, 
                        Speechlib_tlb::ISpeechObjectToken* VoiceObjectToken)
  {
    _ISpeechVoiceEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.VoiceChange(StreamNumber, StreamPosition, VoiceObjectToken);
      }
    }
  }

  void Fire_Bookmark(long StreamNumber, VARIANT StreamPosition, BSTR Bookmark, long BookmarkId)
  {
    _ISpeechVoiceEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.Bookmark(StreamNumber, StreamPosition, Bookmark, BookmarkId);
      }
    }
  }

  void Fire_Word(long StreamNumber, VARIANT StreamPosition, long CharacterPosition, long Length)
  {
    _ISpeechVoiceEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.Word(StreamNumber, StreamPosition, CharacterPosition, Length);
      }
    }
  }

  void Fire_Sentence(long StreamNumber, VARIANT StreamPosition, long CharacterPosition, long Length)
  {
    _ISpeechVoiceEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.Sentence(StreamNumber, StreamPosition, CharacterPosition, Length);
      }
    }
  }

  void Fire_Phoneme(long StreamNumber, VARIANT StreamPosition, long Duration, short NextPhoneId, 
                    Speechlib_tlb::SpeechVisemeFeature Feature, short CurrentPhoneId)
  {
    _ISpeechVoiceEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.Phoneme(StreamNumber, StreamPosition, Duration, NextPhoneId, Feature, 
                              CurrentPhoneId);
      }
    }
  }

  void Fire_Viseme(long StreamNumber, VARIANT StreamPosition, long Duration, 
                   Speechlib_tlb::SpeechVisemeType NextVisemeId, 
                   Speechlib_tlb::SpeechVisemeFeature Feature, 
                   Speechlib_tlb::SpeechVisemeType CurrentVisemeId)
  {
    _ISpeechVoiceEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.Viseme(StreamNumber, StreamPosition, Duration, NextVisemeId, Feature, 
                             CurrentVisemeId);
      }
    }
  }

  void Fire_AudioLevel(long StreamNumber, VARIANT StreamPosition, long AudioLevel)
  {
    _ISpeechVoiceEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.AudioLevel(StreamNumber, StreamPosition, AudioLevel);
      }
    }
  }

  void Fire_EnginePrivate(long StreamNumber, long StreamPosition, VARIANT EngineData)
  {
    _ISpeechVoiceEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.EnginePrivate(StreamNumber, StreamPosition, EngineData);
      }
    }
  }

};

// *********************************************************************//
// CONNECTIONPOINT/EVENT PROXY
// CoClass         : SpSharedRecoContext
// Event Interface : _ISpeechRecoContextEvents
// *********************************************************************//
template <typename T>
class ISpSharedRecoContext_EventsDispatcher : public IUnknown
{
public:
  void Fire_StartStream(long StreamNumber, VARIANT StreamPosition)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.StartStream(StreamNumber, StreamPosition);
      }
    }
  }

  void Fire_EndStream(long StreamNumber, VARIANT StreamPosition, VARIANT_BOOL StreamReleased)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.EndStream(StreamNumber, StreamPosition, StreamReleased);
      }
    }
  }

  void Fire_Bookmark(long StreamNumber, VARIANT StreamPosition, VARIANT BookmarkId, 
                     Speechlib_tlb::SpeechBookmarkOptions Options)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.Bookmark(StreamNumber, StreamPosition, BookmarkId, Options);
      }
    }
  }

  void Fire_SoundStart(long StreamNumber, VARIANT StreamPosition)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.SoundStart(StreamNumber, StreamPosition);
      }
    }
  }

  void Fire_SoundEnd(long StreamNumber, VARIANT StreamPosition)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.SoundEnd(StreamNumber, StreamPosition);
      }
    }
  }

  void Fire_PhraseStart(long StreamNumber, VARIANT StreamPosition)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.PhraseStart(StreamNumber, StreamPosition);
      }
    }
  }

  void Fire_Recognition(long StreamNumber, VARIANT StreamPosition, 
                        Speechlib_tlb::SpeechRecognitionType RecognitionType, 
                        Speechlib_tlb::ISpeechRecoResult* Result)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.Recognition(StreamNumber, StreamPosition, RecognitionType, Result);
      }
    }
  }

  void Fire_Hypothesis(long StreamNumber, VARIANT StreamPosition, 
                       Speechlib_tlb::ISpeechRecoResult* Result)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.Hypothesis(StreamNumber, StreamPosition, Result);
      }
    }
  }

  void Fire_PropertyNumberChange(long StreamNumber, VARIANT StreamPosition, BSTR PropertyName, 
                                 long NewNumberValue)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.PropertyNumberChange(StreamNumber, StreamPosition, PropertyName, 
                                           NewNumberValue);
      }
    }
  }

  void Fire_PropertyStringChange(long StreamNumber, VARIANT StreamPosition, BSTR PropertyName, 
                                 BSTR NewStringValue)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.PropertyStringChange(StreamNumber, StreamPosition, PropertyName, 
                                           NewStringValue);
      }
    }
  }

  void Fire_FalseRecognition(long StreamNumber, VARIANT StreamPosition, 
                             Speechlib_tlb::ISpeechRecoResult* Result)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.FalseRecognition(StreamNumber, StreamPosition, Result);
      }
    }
  }

  void Fire_Interference(long StreamNumber, VARIANT StreamPosition, 
                         Speechlib_tlb::SpeechInterference Interference)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.Interference(StreamNumber, StreamPosition, Interference);
      }
    }
  }

  void Fire_RequestUI(long StreamNumber, VARIANT StreamPosition, BSTR UIType)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.RequestUI(StreamNumber, StreamPosition, UIType);
      }
    }
  }

  void Fire_RecognizerStateChange(long StreamNumber, VARIANT StreamPosition, 
                                  Speechlib_tlb::SpeechRecognizerState NewState)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.RecognizerStateChange(StreamNumber, StreamPosition, NewState);
      }
    }
  }

  void Fire_Adaptation(long StreamNumber, VARIANT StreamPosition)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.Adaptation(StreamNumber, StreamPosition);
      }
    }
  }

  void Fire_RecognitionForOtherContext(long StreamNumber, VARIANT StreamPosition)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.RecognitionForOtherContext(StreamNumber, StreamPosition);
      }
    }
  }

  void Fire_AudioLevel(long StreamNumber, VARIANT StreamPosition, long AudioLevel)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.AudioLevel(StreamNumber, StreamPosition, AudioLevel);
      }
    }
  }

  void Fire_EnginePrivate(long StreamNumber, VARIANT StreamPosition, VARIANT EngineData)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.EnginePrivate(StreamNumber, StreamPosition, EngineData);
      }
    }
  }

};

// *********************************************************************//
// CONNECTIONPOINT/EVENT PROXY
// CoClass         : SpInProcRecoContext
// Event Interface : _ISpeechRecoContextEvents
// *********************************************************************//
template <typename T>
class ISpInProcRecoContext_EventsDispatcher : public IUnknown
{
public:
  void Fire_StartStream(long StreamNumber, VARIANT StreamPosition)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.StartStream(StreamNumber, StreamPosition);
      }
    }
  }

  void Fire_EndStream(long StreamNumber, VARIANT StreamPosition, VARIANT_BOOL StreamReleased)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.EndStream(StreamNumber, StreamPosition, StreamReleased);
      }
    }
  }

  void Fire_Bookmark(long StreamNumber, VARIANT StreamPosition, VARIANT BookmarkId, 
                     Speechlib_tlb::SpeechBookmarkOptions Options)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.Bookmark(StreamNumber, StreamPosition, BookmarkId, Options);
      }
    }
  }

  void Fire_SoundStart(long StreamNumber, VARIANT StreamPosition)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.SoundStart(StreamNumber, StreamPosition);
      }
    }
  }

  void Fire_SoundEnd(long StreamNumber, VARIANT StreamPosition)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.SoundEnd(StreamNumber, StreamPosition);
      }
    }
  }

  void Fire_PhraseStart(long StreamNumber, VARIANT StreamPosition)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.PhraseStart(StreamNumber, StreamPosition);
      }
    }
  }

  void Fire_Recognition(long StreamNumber, VARIANT StreamPosition, 
                        Speechlib_tlb::SpeechRecognitionType RecognitionType, 
                        Speechlib_tlb::ISpeechRecoResult* Result)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.Recognition(StreamNumber, StreamPosition, RecognitionType, Result);
      }
    }
  }

  void Fire_Hypothesis(long StreamNumber, VARIANT StreamPosition, 
                       Speechlib_tlb::ISpeechRecoResult* Result)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.Hypothesis(StreamNumber, StreamPosition, Result);
      }
    }
  }

  void Fire_PropertyNumberChange(long StreamNumber, VARIANT StreamPosition, BSTR PropertyName, 
                                 long NewNumberValue)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.PropertyNumberChange(StreamNumber, StreamPosition, PropertyName, 
                                           NewNumberValue);
      }
    }
  }

  void Fire_PropertyStringChange(long StreamNumber, VARIANT StreamPosition, BSTR PropertyName, 
                                 BSTR NewStringValue)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.PropertyStringChange(StreamNumber, StreamPosition, PropertyName, 
                                           NewStringValue);
      }
    }
  }

  void Fire_FalseRecognition(long StreamNumber, VARIANT StreamPosition, 
                             Speechlib_tlb::ISpeechRecoResult* Result)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.FalseRecognition(StreamNumber, StreamPosition, Result);
      }
    }
  }

  void Fire_Interference(long StreamNumber, VARIANT StreamPosition, 
                         Speechlib_tlb::SpeechInterference Interference)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.Interference(StreamNumber, StreamPosition, Interference);
      }
    }
  }

  void Fire_RequestUI(long StreamNumber, VARIANT StreamPosition, BSTR UIType)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.RequestUI(StreamNumber, StreamPosition, UIType);
      }
    }
  }

  void Fire_RecognizerStateChange(long StreamNumber, VARIANT StreamPosition, 
                                  Speechlib_tlb::SpeechRecognizerState NewState)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.RecognizerStateChange(StreamNumber, StreamPosition, NewState);
      }
    }
  }

  void Fire_Adaptation(long StreamNumber, VARIANT StreamPosition)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.Adaptation(StreamNumber, StreamPosition);
      }
    }
  }

  void Fire_RecognitionForOtherContext(long StreamNumber, VARIANT StreamPosition)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.RecognitionForOtherContext(StreamNumber, StreamPosition);
      }
    }
  }

  void Fire_AudioLevel(long StreamNumber, VARIANT StreamPosition, long AudioLevel)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.AudioLevel(StreamNumber, StreamPosition, AudioLevel);
      }
    }
  }

  void Fire_EnginePrivate(long StreamNumber, VARIANT StreamPosition, VARIANT EngineData)
  {
    _ISpeechRecoContextEventsDisp dispInvoker;
    T* pClass = static_cast<T*>(this);
    TConnectionPointSinkList<T> cpsl(pClass->ConnectionPoint);
    if (cpsl.HasConnectionPoint()) {
      for (int i=0; i<cpsl.GetCount(); i++) {
        _di_IInterface punk;
        if (cpsl.GetSink(i, punk) && (dispInvoker.Bind(punk)==S_OK))
          dispInvoker.EnginePrivate(StreamNumber, StreamPosition, EngineData);
      }
    }
  }

};

#endif    //   __TLB_NO_EVENT_WRAPPERS

};     // namespace Speechlib_tlb

#if !defined(NO_IMPLICIT_NAMESPACE_USE)
using  namespace Speechlib_tlb;
#endif

#pragma option pop

#endif // SpeechLib_TLBH
